#!/usr/bin/env python3
# Generate instructions opcode list.
#
# (c) Mit authors 2018-2019
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USER’S
# RISK.

import mit_core.vm_data as vm_data
from mit_core.code_buffer import Code
from mit_core.code_util import enum_to_python

import extra_instructions


code = Code()
code.append('''\
# Auto-generated by gen-python-opcodes - DO NOT EDIT.
# Instruction opcodes.
#
# (c) Mit authors 2018-2019
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USER’S
# RISK.

from enum import Enum, IntEnum, unique
''')

register_code = Code('class Register(Enum):')
code.append('')
for register in vm_data.Register:
    register_code.append(Code('{} = object()'.format(register.name)))
code.extend(register_code)
code.append('')

code.extend(enum_to_python(vm_data.Instruction))
code.append('')

# The set of opcodes which must be the last in a word.
code.append('TERMINAL_OPCODES = frozenset({')
for name in [instruction.name
             for instruction in vm_data.Instruction
             if instruction.terminal]:
    code.append(Code('Instruction.{}, '.format(name)))
code.append('})')
code.append('')

code.extend(enum_to_python(vm_data.InternalExtraInstruction))
code.append('')

code.extend(enum_to_python(extra_instructions.LibC))
code.append('')
code.extend(enum_to_python(extra_instructions.LibMit))
code.append('')
code.extend(enum_to_python(extra_instructions.LibInstruction))

print(code.unindented_str())
