'''
Python bindings for libmit.

(c) Mit authors 2019

The package is distributed under the MIT/X11 License.

THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
RISK.
'''

from ctypes import *
from ctypes.util import find_library

from .errors import *


library_file = find_library("mit@PACKAGE_SUFFIX@")
features_library_file = find_library("mitfeatures@PACKAGE_SUFFIX@")
if not library_file:
    # For Windows
    # FIXME: Do this portably
    # FIXME: Substitute version when library is versioned
    library_file = find_library("libmit@PACKAGE_SUFFIX@-0")
    features_library_file = find_library("libmitfeatures@PACKAGE_SUFFIX@-0")
assert(library_file)
assert(features_library_file)
libmit = CDLL(library_file)
assert(libmit)
libmitfeatures = CDLL(features_library_file)
assert(libmitfeatures)


# Errors
class Error(Exception):
    pass

class ErrorCode(Error):
    def __init__(self, error_code, message):
        super().__init__(error_code, message)

def identifier_to_message(id):
    'Convert an identifier to an error message.'
    return id.lower().translate({'_': ' '})

def errcheck(error_enum):
    '''
    Returns a callback suitable for use as `ctypes._FuncPtr.errcheck`.
     - code_to_message - a dict from int to message. If the message is `None`
       the code is considered to be a success, and `None` is returned.
       If the code is not found in `code_to_message`:
        - if an "ok" code exists, an "unknown error" is reported.
        - otherwise the result is returned unchanged.
    '''
    code_to_message = {error.value: identifier_to_message(error.name)
                       for error in error_enum}
    require_match = 'ok' in code_to_message.values()
    def callback(result, _func, _args):
        result = int(result)
        if result in code_to_message:
            message = code_to_message[result]
            if message == 'ok':
                return
        elif require_match:
            message = "unknown error!"
        else:
            return result
        raise ErrorCode(result, message)
    return callback


# Constants (all of type unsigned)
vars().update([(c, c_uint.in_dll(libmit, "mit_{}".format(c)).value)
               for c in ["word_bytes", "endism", "size_word",
                         "byte_bit", "byte_mask", "word_bit",
                         "instruction_bit", "instruction_mask"]])
sign_bit = 1 << (word_bit - 1)


# Types
class c_int128(Structure):
    _fields_ = [('low', c_uint64),
                ('high', c_int64)]

    def __init__(self, n=0):
        self.low = int(n) & ((1 << 64) - 1)
        self.high = int(n) >> 64

    @classmethod
    def from_param(cls, value):
        return cls(value)

    @property
    def value(self):
        return self.low | (self.high << 64)

    def __int__(self):
        return self.value

    def __hash__(self):
        return int.__hash__(self.value)

class c_uint128(c_int128):
    @property
    def value(self):
        return (self.low | (self.high << 64)) & ((1 << 128) - 1)

if word_bytes == 2:
    c_word = c_int16
    c_uword = c_uint16
elif word_bytes == 4:
    c_word = c_int32
    c_uword = c_uint32
elif word_bytes == 8:
    c_word = c_int64
    c_uword = c_uint64
elif word_bytes == 16:
    c_word = c_int128
    c_uword = c_uint128
else:
    raise Exception("Could not make Python C type matching WORD (size {})".format(word_bytes))


# Constants that require VM types
vars().update([(c, cty.in_dll(libmit, "mit_{}".format(c)).value)
               for (c, cty) in [
                       ("word_mask", c_uword),
                       ("uword_max", c_uword),
                       ("word_min", c_word),
                       ("word_max", c_word),
               ]])

# Functions
c_ptrdiff_t = c_ssize_t

# Errors
execution_error = errcheck(ExecutionError)
malloc_error = errcheck(MallocError)

# mit.h
libmit.mit_load.argtypes = [c_void_p, c_uword, c_uint, POINTER(c_word)]
libmit.mit_load.errcheck = execution_error
libmit.mit_store.argtypes = [c_void_p, c_uword, c_uint, c_word]
libmit.mit_store.errcheck = execution_error

libmit.mit_load_stack.argtypes = [c_void_p, c_uword, POINTER(c_word)]
libmit.mit_load_stack.errcheck = execution_error
libmit.mit_store_stack.argtypes = [c_void_p, c_uword, c_word]
libmit.mit_store_stack.errcheck = execution_error
libmit.mit_pop_stack.argtypes = [c_void_p, POINTER(c_word)]
libmit.mit_pop_stack.errcheck = execution_error
libmit.mit_push_stack.argtypes = [c_void_p, c_word]
libmit.mit_push_stack.errcheck = execution_error

libmit.mit_native_address_of_range.restype = POINTER(c_ubyte)
libmit.mit_native_address_of_range.argtypes = [c_void_p, c_uword, c_uword]

libmit.mit_run.restype = c_word
libmit.mit_run.argtypes = [c_void_p]
libmit.mit_run.errcheck = execution_error

libmit.mit_single_step.restype = c_word
libmit.mit_single_step.argtypes = [c_void_p]
libmit.mit_single_step.errcheck = execution_error

libmit.mit_load_object.restype = c_ptrdiff_t
libmit.mit_load_object.argtypes = [c_void_p, c_uword, c_int]
libmit.mit_load_object.errcheck = errcheck(LoadError)

libmit.mit_save_object.argtypes = [c_void_p, c_uword, c_uword, c_int]
libmit.mit_save_object.errcheck = errcheck(SaveError)

libmit.mit_init.restype = c_void_p
libmit.mit_init.argtypes = [c_size_t, c_size_t]

libmit.mit_realloc_memory.argtypes = [c_void_p, c_int]
libmit.mit_realloc_memory.errcheck = malloc_error

libmit.mit_realloc_stack.argtypes = [c_void_p, c_int]
libmit.mit_realloc_stack.errcheck = malloc_error

libmit.mit_destroy.restype = None
libmit.mit_destroy.argtypes = [c_void_p]

libmit.mit_register_args.argtypes = [c_void_p, c_int, c_void_p]

libmit.mit_align.restype = c_uword
libmit.mit_align.argtypes = [c_uword, c_uint]

libmit.mit_is_aligned.argtypes = [c_uword, c_uint]

def align(addr):
    return int(libmit.mit_align(addr, size_word))

def is_aligned(addr):
    return libmit.mit_is_aligned(addr, size_word)

# features.h
libmitfeatures.mit_extra_instruction.argtypes = [c_void_p]
libmitfeatures.mit_extra_instruction.restype = c_word
libmitfeatures.mit_extra_instruction.errcheck = execution_error

libmitfeatures.mit_auto_extend_init.argtypes = None
libmitfeatures.mit_auto_extend_init.restype = c_void_p

libmitfeatures.mit_auto_extend_handler.argtypes = [c_void_p, c_int]

libmitfeatures.mit_core_dump.argtypes = [c_void_p]

libmitfeatures.mit_specializer_run.argtypes = [c_void_p]
libmitfeatures.mit_specializer_run.restype = c_word

libmitfeatures.mit_trace_run.argtypes = [c_void_p, c_void_p]
libmitfeatures.mit_trace_run.restype = c_word
