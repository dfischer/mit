#!/usr/bin/env python3
# Generate front-end.
#
# Copyright (c) 1995-2019 Mit authors
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

from mit_core.vm_data import MitError
from mit_core.errors import LoadError
from mit_core.code_util import Code, disable_warnings


# Command line

class CommandLineElement:
    elements = []
    def __init__(self):
        self.elements.append(self)

class Doc(CommandLineElement):
    '''
    Free-form documentation.

     - text - str - if the string starts and ends with a double quote, it is
       printed literally and may thus contain interpolations. Otherwise, it is
       output in quotes.
    '''
    def __init__(self, text):
        super().__init__()
        self.text = text

class Option(CommandLineElement):
    '''
    A command-line option.

     - long_name - str - long option name
     - docstring - str - argument docstring
     - short_name - str - short option char
     - arg - str - 'no_argument' (default), 'required_argument' or 'optional_argument'
     - arg_name - str - name for the argument, if any
     - parse_code - str - code run when the option is parsed
    '''
    options = []
    def __init__(self, long_name, docstring, short_name=None,
                 arg=None, arg_name=None, parse_code=None):
        super().__init__()
        self.options.append(self)
        self.long_name = long_name
        self.docstring = docstring
        self.short_name = short_name
        self.arg = arg or 'no_argument'
        self.arg_name = arg_name
        self.parse_code = parse_code

class Arg(CommandLineElement):
    '''
    A command-line argument.

     - arg - str - argument name
     - docstring - str - argument docstring
    '''
    def __init__(self, arg, docstring):
        self.arg = arg
        self.docstring = docstring

Option('specializer',
       'use specializing interpreter',
       short_name='O',
       parse_code=Code('run_fn = mit_specializer_run;'),
)

Option('no-auto-extend',
       'do not automatically extend stack or memory',
       parse_code=Code('auto_extend = false;'),
)

default_max_backtrace = 16
Option('backtrace',
       '''show registers and top N stack items on error\\n\\
                            [default {}; 0 to show entire stack]'''.format(default_max_backtrace),
       arg='optional_argument', arg_name='N',
       parse_code=Code('''\
       {
           backtrace = true;
           if (optarg) {
               char *endptr;
               max_backtrace = parse_unsigned(optarg, &endptr);
               if (*optarg == '\\0' || *endptr != '\\0')
                   die("invalid maximum backtrace size");
           }
       }
       '''),
)

Option('core-dump',
       'dump core on memory error',
       short_name='c',
       parse_code=Code('''
           {
               core_dump = true;

               // Set signal handlers for core dump
       #ifdef SIGQUIT
               sig_catch(SIGQUIT, sig_core_dump);
       #endif
       #ifdef SIGABRT
               sig_catch(SIGABRT, sig_core_dump);
       #endif
           }
       '''),
)

Option('help',
       'display this help message and exit',
       parse_code=Code('usage();'),
)

Option('version',
       'display version information and exit',
       parse_code=Code('''\
           {
               printf(PACKAGE_NAME " " VERSION " (%d-byte word, %s-endian)\\n"
                      "(c) Mit authors 1994-2019\\n"
                      PACKAGE_NAME " comes with ABSOLUTELY NO WARRANTY.\\n"
                      "You may redistribute copies of " PACKAGE_NAME "\\n"
                      "under the terms of the MIT/X11 License.\\n",
                      MIT_WORD_BYTES, MIT_ENDISM ? "big" : "little");
               exit(EXIT_SUCCESS);
           }
       ''')
)

Arg('OBJECT-FILE', 'load and run object OBJECT-FILE')
Doc('')
Doc('"The ARGUMENTS are available to "PACKAGE_NAME"."')
Doc('''
If an error occurs during execution, the exit status is the error code; if
execution halts normally, the exit status is 0. Note that the VM code may
cause an exit with a different status.
''')
Doc('"Report bugs to "PACKAGE_BUGREPORT"."')


# Features

class Feature:
    '''
    A command-line option.

     - top_level - Code - additional top-level code for the option
     - init - Code - declarations inside main, and initialisation
     - handler - Code - cases added to the error handler
     - exit - Code - code run immediately before exit
    '''
    features = []
    def __init__(self, top_level=None, init=None, handler=None, exit=None):
        self.features.append(self)
        self.top_level = top_level
        self.init = init
        self.handler = handler
        self.exit = exit

Feature(# Extra instructions
    handler=Code('''\
        case MIT_ERROR_INVALID_OPCODE:
            if ((S->I & MIT_OPCODE_MASK) == MIT_INSTRUCTION_JUMP) {
                error = mit_extra_instruction(S);
                if (error == 0) {
                    S->I = 0;
                    continue;
                }
            }
            break;
    ''')
)

Feature(# Auto-extend stack and memory
    init=Code('bool auto_extend = true;'),
    handler=Code('''\
        case MIT_ERROR_STACK_OVERFLOW:
        case MIT_ERROR_INVALID_MEMORY_READ:
        case MIT_ERROR_INVALID_MEMORY_WRITE:
            if (auto_extend == true && mit_auto_extend_handler(S, error) == 0)
                continue;
            break;
    ''')
)

Feature(# Error message on error exit
    exit=Code('''
        if (error != MIT_ERROR_HALT)
            // Cast error to size_t for printing because we might not be
            // able to print mit_uword.
            warn("error %zu: %s", (size_t)error, error_msg[error]);
    '''),
)

Feature(# Register and stack backtrace
    top_level=Code('''
        #define WORD_STRLEN (MIT_WORD_BYTES * 2)

        static char hex[] = "0123456789abcdef";

        static void word_to_str(mit_word w, char s[WORD_STRLEN])
        {
            for (unsigned i = 0; i < WORD_STRLEN; i++) {
                s[WORD_STRLEN - i - 1] = hex[w & 0xf];
                w >>= 4;
            }
        }

        static unsigned long parse_unsigned(const char *s, char **endp)
        {
            return (s[0] == '0' && (s[1] == 'X' || s[1] == 'x')) ?
                strtoul(s + 2, endp, 16) : strtoul(s, endp, 10);
        }
        '''),
    init=Code('''
        bool backtrace = false;
        unsigned long default_max_backtrace = {};
        unsigned long max_backtrace = default_max_backtrace;
    '''.format(default_max_backtrace)),
    exit=disable_warnings(
        ['-Wpointer-to-int-cast'], Code('''
        if (backtrace == true) {
            fprintf(stderr, "\\nRegisters:\\n");
            char word_str[WORD_STRLEN];
            #define R(name, type, return_type) \\
            word_to_str((mit_uword)S->name, &word_str[0]); \\
            fprintf(stderr, #name "=0x%.*s\\n", WORD_STRLEN, word_str);
            #include "mit/registers.h"
            #undef R
            if (S->STACK_DEPTH <= S->stack_size) {
                fprintf(stderr, "\\nStack:\\n");
                mit_uword items = MIN(max_backtrace, S->STACK_DEPTH);
                if (max_backtrace == 0)
                    items = S->STACK_DEPTH;
                for (mit_uword pos = 0; pos < items; pos++) {
                    mit_word w;
                    if (load_stack(S->stack, S->STACK_DEPTH, pos, &w) == 0) {
                        word_to_str(w, &word_str[0]);
                        fprintf(stderr, "0x%.*s\\n", WORD_STRLEN, word_str);
                    }
                }
            }
        }
    '''))
)

Feature(# VM core dump
    top_level=Code('''
        static void sig_catch(int sig, void (*handler)(int))
        {
            struct sigaction sa;
            sa.sa_handler = handler;
            sa.sa_flags = 0;
            sigemptyset(&sa.sa_mask);
            sigaction(sig, &sa, NULL);  /* ignore error: none possible */
        }

        static void do_core_dump(void)
        {
            const char *filename = mit_core_dump(S);
            if (filename != NULL)
                warn("core dumped to %s", filename);
        }

        static void sig_core_dump(_GL_UNUSED_PARAMETER int sig)
        {
            do_core_dump();
            exit(MIT_ERROR_DUMPED_CORE_ON_SIGNAL);
        }
    '''),
    init=Code('bool core_dump = false;'),
    exit=Code('''
        if (error != MIT_ERROR_HALT && core_dump)
            do_core_dump();
    ''')
)


# Generate output

# Errors
error_enum = Code()
for error in MitError:
    error_enum.append('"{}",'.format(
        error.name.lower().translate(str.maketrans('_', ' '))
    ))

# Command-line documentation
help_code = Code()
for element in CommandLineElement.elements:
    if isinstance(element, Option):
        arg = ''
        if element.arg_name: arg = element.arg_name
        if element.arg == 'optional_argument':
            arg = '[{}]'.format(arg)
        help_code.append('    printf("  %-26s%s\\n", "--{long_name}{short_opt} {arg}", "{docstring}");'.format(
            long_name=element.long_name,
            short_opt=', -{}'.format(element.short_name) if element.short_name else '',
            arg=arg,
            docstring=element.docstring,
        ))
    elif isinstance(element, Arg):
        help_code.append('printf("  %-26s%s\\n", {arg}, {docstring});'.format(
            arg=element.arg,
            docstring=element.docstring
        ))
    elif isinstance(element, Doc):
        text = element.text
        if len(text) > 1 and not(text[0] == '"' and text[-1] == '"'):
            text = '"{}"'.format(repr(text)[1:-1])
        help_code.append('    printf({}"\\n");'.format(text))

# Command-line options
getopt_code = Code()
shortopts = ''
short_options_code = Code()
long_options_code = Code()
else_code = ''
for i, option in enumerate(Option.options):
    getopt_code.append('{{"{long_name}", {arg}, NULL, \'{short_name}\'}},'.format(
        long_name=option.long_name, arg=option.arg or '""',
        short_name=option.short_name or "\\0"))
    if option.short_name:
        shortopts += option.short_name
        if option.arg == 'required_argument':
            shortopts += ':'
        elif option.arg == 'optional_argument':
            shortopts += '::'
        short_options_code.append('''\
            if (c == '{short_name}')
                longindex = {index};'''.format(
                    short_name = option.short_name,
                    index = i
                ))
    if option.parse_code:
        long_options_code.append('{}if (longindex == {})'.format(else_code, i))
        long_options_code.append(option.parse_code)
        else_code = 'else '
getopt_code.append('{0, 0, 0, 0}')

# Features
top_level_code = Code()
init_code = Code('''\
    set_program_name(argv[0]);
    mit_word (*run_fn)(mit_state *) = mit_run;
''')
handlers_code = Code()
exit_code = Code()
for feature in Feature.features:
    if feature.top_level:
        top_level_code.extend(feature.top_level)
    if feature.init:
        init_code.extend(feature.init)
    if feature.handler:
        handlers_code.extend(feature.handler)
    if feature.exit:
        exit_code.extend(feature.exit)

# main.c
code = Code('''\
// Auto-generated by gen-main - DO NOT EDIT.

// Front-end.

#include "config.h"

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdbool.h>
#include <signal.h>
#include <getopt.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>

#include "unused-parameter.h"
#include "progname.h"
#include "binary-io.h"
#include "minmax.h"

#include "mit/mit.h"
#include "mit/features.h"

#include "warn.h"


// Error messages
const char *error_msg[] = {
''',
             error_enum,
             '''\
};

// Options table
struct option longopts[] = {''',
              getopt_code,
              '''\
};

static void usage(void)
{
    printf("Usage: %s [OPTION...] [OBJECT-FILE ARGUMENT...]\\n"
           "\\n"
           "Run " PACKAGE_NAME ".\\n"
           "\\n",
           program_name);''',
              help_code,
              '''
    exit(EXIT_SUCCESS);
}

static mit_state *S;

static void exit_function(void)
{
    mit_destroy(S);
}''')

code.extend(top_level_code)
code.extend(Code('''
int main(int argc, char *argv[])
{
''',
              init_code,
              Code('''
    // Options string starts with '+' to stop option processing at first
    // non-option, then leading ':' so as to return ':' for a missing arg,
    // not '?'
    const char *shortopts = "+:{}";'''.format(shortopts)),
              Code('''
    for (;;) {
        int this_optind = optind ? optind : 1, longindex = -1;
        int c = getopt_long(argc, argv, shortopts, longopts, &longindex);

        if (c == -1)
            break;
        else if (c == ':')
            die("option '%s' requires an argument", argv[this_optind]);
        else if (c == '?')
            die("unrecognised option '%s'\\nTry '%s --help' for more information.", argv[this_optind], program_name);
'''),
              short_options_code,
              long_options_code,
              Code('}'),
              Code('''
    // If invoked without an object file, give usage message and exit
    argc -= optind;
    if (argc < 1)
        usage();

    // Set up VM
    S = mit_auto_extend_init();
    if (S == NULL)
        die("could not allocate virtual machine state");
    if (atexit(exit_function) != 0)
        die("could not register atexit handler");
    if (mit_register_args(S, argc, (const char **)(argv + optind)) != 0)
        die("could not register command-line arguments");

    // Load object file and report any error
    int fd = open(argv[optind], O_RDONLY);
    if (fd < 0)
        die("cannot not open file %s", argv[optind]);
    if (set_binary_mode(fd, O_BINARY) == -1)
        die("cannot read file %s as binary", argv[optind]);
    int ret = mit_load_object(S, 0, fd);
    close(fd);
    const char *err = NULL;
    if (ret < 0)
        switch (ret) {''',
                 Code(*[
                     '''\
                     case MIT_LOAD_ERROR_{}:
                         err = "{}";
                         break;'''.format(
                         error.name,
                         error.name.lower().translate(str.maketrans('_', ' '))
                     ) for error in LoadError
                 ], '''\
                 default:
                     err = "unknown error!";
                     break;''')
              ),
            Code('''
    }
    if (err != NULL)
        die("%s: %s", argv[optind], err);

    // Run
    for (;;) {
        mit_word error = run_fn(S);''',
                 Code('''switch (error) {''',
                      handlers_code,
                      Code('''\
                      default:
                          break;'''),
                      '''\
                      }'''),
                 exit_code),
            '''
        return error == MIT_ERROR_HALT ? 0 : error;
    }
}''',
))

print(code)
