#!/usr/bin/env python3
# Generate front-end.
#
# Copyright (c) 1995-2020 Mit authors
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

from mit_core.spec import MitErrorCode
from mit_core.errors import LoadErrorCode
from mit_core.code_util import Code, copyright_banner, disable_warnings


GENERATOR_PROGRAM = 'gen-main'
PURPOSE = 'Command-line front end for Mit.'
COPYRIGHT_YEARS = '1995-2020'


# Command line

class Doc:
    '''
    Free-form documentation.

     - docstring - str or list of str - if the string (or first string)
       starts and ends with a double quote, it is printed literally and may
       thus contain interpolations. Otherwise, it is output in quotes. For a
       list, the other strings are printed literally; they are intended to
       be arguments for `printf` substitutions.
    '''
    elements = []
    def __init__(self, docstring):
        self.elements.append(self)
        if not isinstance(docstring, list):
            docstring = [docstring]
        if docstring[0][:1] != '"' or docstring[0][-1:] != '"':
            docstring[0] = '"{}"'.format(repr(docstring[0])[1:-1])
        self._docstring = docstring

    @property
    def docstring(self):
        return ', '.join(self._docstring)

class Option(Doc):
    '''
    A command-line option.

     - long_name - str - long option name
     - docstring - str - argument docstring as for Doc class.
     - short_name - str - short option char
     - arg - str - 'no_argument' (default), 'required_argument' or
       'optional_argument'
     - arg_name - str - name for the argument, if any
     - parse_code - str - code run when the option is parsed
    '''
    options = []
    def __init__(self, long_name, docstring, short_name=None,
                 arg=None, arg_name=None, parse_code=None):
        super().__init__(docstring)
        self.options.append(self)
        self.long_name = long_name
        self.short_name = short_name
        self.arg = arg or 'no_argument'
        self.arg_name = arg_name
        self.parse_code = parse_code

class Arg(Doc):
    '''
    A command-line argument.

     - arg - str - argument name
     - docstring - str - argument docstring as for Doc class.
    '''
    def __init__(self, arg, docstring):
        super().__init__(docstring)
        self.arg = arg

Doc('Execution:')
Option('memory',
       ['size of memory in words [default %zu]', '(size_t)memory_words'],
       short_name='m',
       arg='required_argument', arg_name='N',
       parse_code=Code('''\
       {
           size_t max = SIZE_MAX / MIT_WORD_BYTES;
           char *endptr;
           errno = 0;
           uintmax_t size = strtoumax(optarg, &endptr, 10);
           if (*optarg == '\\0' || *endptr != '\\0' || size == 0 || size > (uintmax_t)max)
               die("memory size must be a positive number up to %zu", max);
           memory_words = (mit_uword)size;
       }
     ''')
)

Option('optimize',
       'use optimizing interpreter',
       short_name='O',
       parse_code=Code('set_run_function(mit_specializer_run);'),
)

Option('profile',
       '''write execution profile to FILE
                            (implies --optimize)''',
       arg='required_argument', arg_name='FILE',
       parse_code=Code('''\
       {
           mit_profile_init();
           set_run_function(mit_profile_run);
           profile_file = optarg;
       }
       '''),
)

Doc('\nMiscellaneous:')
Option('no-auto-extend',
       'do not automatically extend the stack',
       parse_code=Code('auto_extend_stack = false;'),
)

default_max_backtrace = 16
Option('backtrace',
       '''show registers and top N stack items on error
                            [default {}; 0 to show entire stack]'''.format(default_max_backtrace),
       arg='optional_argument', arg_name='N',
       parse_code=Code('''\
       {
           backtrace = true;
           if (optarg) {
               char *endptr;
               max_backtrace = parse_unsigned(optarg, &endptr);
               if (*optarg == '\\0' || *endptr != '\\0')
                   die("invalid maximum backtrace size");
           }
       }
       '''),
)

Option('core-dump',
       'dump core on memory error',
       short_name='c',
       parse_code=Code('''
           {
               core_dump = true;

               // Set signal handlers for core dump
       #ifdef SIGQUIT
               sig_catch(SIGQUIT, sig_core_dump);
       #endif
       #ifdef SIGABRT
               sig_catch(SIGABRT, sig_core_dump);
       #endif
           }
       '''),
)

Option('help',
       'display this help message and exit',
       parse_code=Code('usage();'),
)

Option('version',
       'display version information and exit',
       parse_code=Code('''\
           {
               printf(PACKAGE_NAME " " VERSION " (%d-byte word, %s-endian)\\n"
                      "Copyright (c) Mit authors 1994-2019.\\n"
                      PACKAGE_NAME " comes with ABSOLUTELY NO WARRANTY.\\n"
                      "You may redistribute copies of " PACKAGE_NAME "\\n"
                      "under the terms of the MIT/X11 License.\\n",
                      MIT_WORD_BYTES, MIT_ENDISM ? "big" : "little");
               exit(EXIT_SUCCESS);
           }
       ''')
)

Arg('OBJECT-FILE', 'load and run object OBJECT-FILE')
Doc('')
Doc('"The ARGUMENTs are passed to "PACKAGE_NAME"."')
Doc('''
If an error occurs during execution, the exit status is the error code; if
execution halts normally, the exit status is 0. Note that the VM code may
cause an exit with a different status.''')


# Features

class Feature:
    '''
    A command-line option.

     - top_level - Code - additional top-level code for the option
     - init - Code - declarations inside main, and initialisation
     - handler - Code - code added to the error handler (in Feature order).
       A handler should "continue" if it does not want execution to stop.
     - exit - Code - code run immediately before exit
    '''
    features = []
    def __init__(self, top_level=None, init=None, handler=None, exit=None):
        self.features.append(self)
        self.top_level = top_level
        self.init = init
        self.handler = handler
        self.exit = exit

Feature(# Extra instructions
    handler=Code('''\
        if (error == MIT_ERROR_INVALID_OPCODE)
            if ((S->ir & MIT_OPCODE_MASK) == MIT_INSTRUCTION_JUMP) {
                error = mit_extra_instruction(S);
                if (error == 0) {
                    S->ir = 0;
                    continue;
                }
            }
    '''),
)

Feature(# Auto-extend stack
    init=Code('bool auto_extend_stack = true;'),
    handler=Code('''\
        if (error == MIT_ERROR_STACK_OVERFLOW)
            if (auto_extend_stack == true &&
                REALLOC_N(S, MIT_ROUND_UP(S->stack_words + 1,
                    page_size / MIT_WORD_BYTES)) == 0)
                continue;
    '''),
)

Feature(# Error message on error exit
    exit=Code('''
        if (error != MIT_ERROR_HALT)
            // Cast error to size_t for printing because we might not be
            // able to print mit_uword.
            warn("error %zu: %s", (size_t)error, error_msg[error]);
    '''),
)

Feature(# Register and stack backtrace
    top_level=Code('''
        #define MAX_STACK_ITEM_STRLEN (sizeof(mit_max_stack_item_t) * 2)

        static void stack_item_to_str(mit_max_stack_item_t x, unsigned size, char s[MAX_STACK_ITEM_STRLEN])
        {
            static const char hex[] = "0123456789abcdef";
            for (unsigned i = 0, digits = size * 2; i < digits; i++) {
                s[digits - i - 1] = hex[x & 0xf];
                x >>= 4;
            }
        }

        static unsigned long parse_unsigned(const char *s, char **endp)
        {
            return (s[0] == '0' && (s[1] == 'X' || s[1] == 'x')) ?
                strtoul(s + 2, endp, 16) : strtoul(s, endp, 10);
        }
    '''),
    init=Code('''
        bool backtrace = false;
        unsigned long default_max_backtrace = {};
        unsigned long max_backtrace = default_max_backtrace;
    '''.format(default_max_backtrace)),
    exit=disable_warnings(
        ['-Wpointer-to-int-cast'], Code('''
        if (error != MIT_ERROR_HALT && backtrace == true) {
            fprintf(stderr, "\\nRegisters:\\n");
            char str[MAX_STACK_ITEM_STRLEN];
            #define R_RO(name, type, return_type) \\
            stack_item_to_str((mit_max_stack_item_t)S->name, sizeof(S->name), &str[0]); \\
            fprintf(stderr, #name "=0x%.*s\\n", (int)(sizeof(S->name) * 2), str);
            #define R(name, type, return_type) R_RO(name,type, return_type)
            #include "mit/registers.h"
            #undef R
            #undef R_RO
            if (S->stack_depth <= S->stack_words) {
                fprintf(stderr, "\\nStack:\\n");
                mit_uword items = MIN(max_backtrace, S->stack_depth);
                if (max_backtrace == 0)
                    items = S->stack_depth;
                for (mit_uword pos = 0; pos < items; pos++) {
                    mit_word w;
                    if (load_stack(S->stack, S->stack_depth, pos, &w) == 0) {
                        stack_item_to_str(w, (int)sizeof(mit_uword), &str[0]);
                        fprintf(stderr, "0x%.*s\\n", (int)(sizeof(mit_uword) * 2), str);
                    }
                }
            }
        }
    ''')),
)

Feature(# VM core dump
    top_level=Code('''
        static void sig_catch(int sig, void (*handler)(int))
        {
            struct sigaction sa;
            sa.sa_handler = handler;
            sa.sa_flags = 0;
            sigemptyset(&sa.sa_mask);
            sigaction(sig, &sa, NULL); // ignore error: none possible
        }

        static void do_core_dump(void)
        {
            const char *filename = mit_core_dump(S);
            if (filename != NULL)
                warn("core dumped to %s", filename);
        }

        static void sig_core_dump(_GL_UNUSED_PARAMETER int sig)
        {
            do_core_dump();
            exit(MIT_ERROR_DUMPED_CORE_ON_SIGNAL);
        }
    '''),
    init=Code('bool core_dump = false;'),
    exit=Code('''
        if (error != MIT_ERROR_HALT && core_dump)
            do_core_dump();
    '''),
)

Feature(# Optimizing interpreter and profiling
    top_level=Code('''
        static void set_run_function(mit_word (*new_run_fn)(mit_state *))
        {
            if (run_fn == new_run_fn ||
                (run_fn == mit_profile_run && new_run_fn == mit_specializer_run))
                ;
            else if (run_fn == mit_run)
                run_fn = new_run_fn;
            else
                die("incompatible execution options given; see %s --help", program_name);
        }
    '''),
    init=Code('char *profile_file = NULL;'),
    exit=Code('''
        if (profile_file != NULL) {{
            FILE *fp = fopen(profile_file, "w");
            if (fp == NULL)
                warn("could not open file %s", profile_file);
            else {{
                if (mit_profile_dump(fileno(fp)) == -1)
                    warn("error writing profile data");
                else
                    warn("wrote profile data to %s", profile_file);
                fclose(fp);
            }}
        }}
    '''),
)


# Generate output

# Errors
error_enum = Code()
for error in MitErrorCode:
    error_enum.append('"{}",'.format(
        error.name.lower().translate(str.maketrans('_', ' '))
    ))

# Command-line documentation
help_code = Code()
for element in Doc.elements:
    if isinstance(element, Option):
        arg = ''
        if element.arg_name: arg = element.arg_name
        if element.arg == 'optional_argument':
            arg = '[{}]'.format(arg)
        help_code.append('    printf("  %-26s", "--{long_name}{short_opt} {arg}");'.format(
            long_name=element.long_name,
            short_opt=', -{}'.format(element.short_name) if element.short_name else '',
            arg=arg,
        ))
        help_code.append('    printf({});'.format(element.docstring))
        help_code.append('    putchar(\'\\n\');')
    elif isinstance(element, Arg):
        help_code.append('printf("  %-26s%s\\n", "{arg}", {docstring});'.format(
            arg=element.arg,
            docstring=element.docstring
        ))
    elif isinstance(element, Doc):
        help_code.append('    printf({}"\\n");'.format(element.docstring))

# Command-line options
getopt_code = Code()
shortopts = ''
short_options_code = Code()
long_options_code = Code()
else_code = ''
for i, option in enumerate(Option.options):
    getopt_code.append('{{"{long_name}", {arg}, NULL, \'{short_name}\'}},'.format(
        long_name=option.long_name, arg=option.arg or '""',
        short_name=option.short_name or "\\0"))
    if option.short_name:
        shortopts += option.short_name
        if option.arg == 'required_argument':
            shortopts += ':'
        elif option.arg == 'optional_argument':
            shortopts += '::'
        short_options_code.append('''\
            if (c == '{short_name}')
                longindex = {index};'''.format(
                    short_name = option.short_name,
                    index = i
                ))
    if option.parse_code:
        long_options_code.append('{}if (longindex == {})'.format(else_code, i))
        long_options_code.append(option.parse_code)
        else_code = 'else '
getopt_code.append('{0, 0, 0, 0}')

# Features
top_level_code = Code('''\
    mit_word (*run_fn)(mit_state *) = mit_run;
    mit_uword memory_words;
''')
init_code = Code('''\
    set_program_name(argv[0]);

    // getpagesize() is obsolete, but gnulib provides it, and
    // sysconf(_SC_PAGESIZE) does not work on some platforms.
    mit_uword page_size = getpagesize();
    memory_words = MIT_WORD_BYTES == 2 ? 0x1000U : 0x100000U;
    mit_uword stack_words = MIT_WORD_BYTES == 2 ? 1024U : 16384U;
''')
handlers_code = Code()
exit_code = Code()
for feature in Feature.features:
    if feature.top_level:
        top_level_code.extend(feature.top_level)
    if feature.init:
        init_code.extend(feature.init)
    if feature.handler:
        handlers_code.extend(feature.handler)
    if feature.exit:
        exit_code.extend(feature.exit)

# main.c
code = copyright_banner(GENERATOR_PROGRAM, PURPOSE, COPYRIGHT_YEARS)
initial_code = Code('''

#include "config.h"

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <inttypes.h>
#include <errno.h>
#include <signal.h>
#include <getopt.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>

#include "unused-parameter.h"
#include "progname.h"
#include "binary-io.h"
#include "minmax.h"
#include "safe-alloc.h"

#include "mit/mit.h"
#include "mit/features.h"

#include "warn.h"
#include "state.h"


// Error messages
const char *error_msg[] = {
''',
             error_enum,
             '''\
};

// Options table
struct option longopts[] = {''',
              getopt_code,
              '''\
};

static mit_state *S;

static void exit_function(void)
{
    mit_free_state(S);
}''')
code.extend(initial_code)

code.extend(top_level_code)
code.extend(Code('''
static void usage(void)
{
    printf("Usage: %s [OPTION...] [OBJECT-FILE ARGUMENT...]\\n"
           "\\n"
           "Run " PACKAGE_NAME " virtual machine code.\\n"
           "\\n",
           program_name);''',
              help_code,
              '''
    exit(EXIT_SUCCESS);
}

int main(int argc, char *argv[])
{
''',
              init_code,
              Code('''
    // Options string starts with '+' to stop option processing at first
    // non-option, then leading ':' so as to return ':' for a missing arg,
    // not '?'
    const char *shortopts = "+:{}";'''.format(shortopts)),
              Code('''
    for (;;) {
        int this_optind = optind ? optind : 1, longindex = -1;
        int c = getopt_long(argc, argv, shortopts, longopts, &longindex);

        if (c == -1)
            break;
        else if (c == ':')
            die("option '%s' requires an argument", argv[this_optind]);
        else if (c == '?')
            die("unrecognised option '%s'\\nTry '%s --help' for more information.", argv[this_optind], program_name);
'''),
              short_options_code,
              long_options_code,
              Code('}'),
              Code('''
    // If invoked without an object file, give usage message and exit
    argc -= optind;
    argv += optind;
    if (argc < 1)
        usage();

    // Set up VM
    S = mit_new_state(memory_words, stack_words);
    if (S == NULL)
        die("could not allocate virtual machine state");
    if (atexit(exit_function) != 0)
        die("could not register atexit handler");
    if (mit_register_args(argc, (const char **)argv) != 0)
        die("could not register command-line arguments");

    // Load object file and report any error
    int fd = open(argv[0], O_RDONLY);
    if (fd < 0)
        die("cannot not open file %s", argv[0]);
    if (set_binary_mode(fd, O_BINARY) == -1)
        die("cannot read file %s as binary", argv[0]);
    int ret = mit_load_object(S, 0, fd);
    close(fd);
    const char *err = NULL;
    if (ret < 0)
        switch (ret) {''',
                 Code(*[
                     '''\
                     case MIT_LOAD_ERROR_{}:
                         err = "{}";
                         break;'''.format(
                         error.name,
                         error.name.lower().translate(str.maketrans('_', ' '))
                     ) for error in LoadErrorCode
                 ], '''\
                 default:
                     err = "unknown error!";
                     break;''')
              ),
            Code('''
    }
    if (err != NULL)
        die("%s: %s", argv[0], err);

    // Run
    for (;;) {
        mit_word error = run_fn(S);''',
                 handlers_code,
                 exit_code),
            '''
        return error == MIT_ERROR_HALT ? 0 : error;
    }
}''',
))

print(code)
