#!/usr/bin/env python3
# Generate front-end.
#
# Copyright (c) 1995-2020 Mit authors
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

from mit_core.spec import MitErrorCode
from mit_core.code_util import Code, copyright_banner, disable_warnings


GENERATOR_PROGRAM = 'gen-main'
PURPOSE = 'Command-line front end for Mit.'
COPYRIGHT_YEARS = '1995-2020'


# Command line

class Doc:
    '''
    Free-form documentation.

     - docstring - str or list of str - if the string (or first string)
       starts and ends with a double quote, it is printed literally and may
       thus contain interpolations. Otherwise, it is output in quotes. For a
       list, the other strings are printed literally; they are intended to
       be arguments for `printf` substitutions.
    '''
    elements = []
    def __init__(self, docstring):
        self.elements.append(self)
        if not isinstance(docstring, list):
            docstring = [docstring]
        if docstring[0][:1] != '"' or docstring[0][-1:] != '"':
            docstring[0] = '"{}"'.format(repr(docstring[0])[1:-1])
        self._docstring = docstring

    @property
    def docstring(self):
        return ', '.join(self._docstring)

class Option(Doc):
    '''
    A command-line option.

     - long_name - str - long option name
     - docstring - str - argument docstring as for Doc class.
     - short_name - str - short option char
     - arg - str - 'no_argument' (default), 'required_argument' or
       'optional_argument'
     - arg_name - str - name for the argument, if any
     - parse_code - str - code run when the option is parsed
    '''
    options = []
    def __init__(self, long_name, docstring, short_name=None,
                 arg=None, arg_name=None, parse_code=None):
        super().__init__(docstring)
        self.options.append(self)
        self.long_name = long_name
        self.short_name = short_name
        self.arg = arg or 'no_argument'
        self.arg_name = arg_name
        self.parse_code = parse_code

class Arg(Doc):
    '''
    A command-line argument.

     - arg - str - argument name
     - docstring - str - argument docstring as for Doc class.
    '''
    def __init__(self, arg, docstring):
        super().__init__(docstring)
        self.arg = arg

Doc('Execution:')
Option('memory',
       ['size of memory in words [default %zu]', '(size_t)memory_words'],
       short_name='m',
       arg='required_argument', arg_name='N',
       parse_code=Code('''\
           memory_words = parse_num_words("memory size must be a positive number up to %zu");
       ''')
)

Option('stack',
       ['size of stack in words [default %zu]', '(size_t)stack_words'],
       short_name='s',
       arg='required_argument', arg_name='N',
       parse_code=Code('''\
           stack_words = parse_num_words("stack size must be a positive number up to %zu");
       ''')
)

Option('optimize',
       'use optimizing interpreter',
       short_name='O',
       parse_code=Code('set_run_function(mit_specializer_run);'),
)

Option('profile',
       '''write execution profile to FILE
                            (implies --optimize)''',
       arg='required_argument', arg_name='FILE',
       parse_code=Code('''\
       {
           mit_profile_init();
           set_run_function(mit_profile_run);
           profile_file = optarg;
       }
       '''),
)

Doc('\nMiscellaneous:')
Option('help',
       'display this help message and exit',
       parse_code=Code('usage();'),
)

Option('version',
       'display version information and exit',
       parse_code=Code('''\
           {
               printf(PACKAGE_NAME " " VERSION " (%d-byte word, %s-endian)\\n"
                      "Copyright (c) Mit authors 1994-2020.\\n"
                      PACKAGE_NAME " comes with ABSOLUTELY NO WARRANTY.\\n"
                      "You may redistribute copies of " PACKAGE_NAME "\\n"
                      "under the terms of the MIT/X11 License.\\n",
                      MIT_WORD_BYTES, MIT_ENDISM ? "big" : "little");
               exit(EXIT_SUCCESS);
           }
       ''')
)

Arg('OBJECT-FILE', 'load and run object OBJECT-FILE')
Doc('')
Doc('"The ARGUMENTs are passed to "PACKAGE_NAME"."')
Doc('''
If an error occurs during execution, the exit status is the error code; if
execution halts normally, the exit status is 0. Note that the VM code may
cause an exit with a different status.''')


# Features

class Feature:
    '''
    A command-line option.

     - top_level - Code - additional top-level code for the option
     - init - Code - declarations inside main, and initialisation
     - handler - Code - code added to the error handler (in Feature order).
       A handler should "continue" if it does not want execution to stop.
     - exit - Code - code run immediately before exit
    '''
    features = []
    def __init__(self, top_level=None, init=None, handler=None, exit=None):
        self.features.append(self)
        self.top_level = top_level
        self.init = init
        self.handler = handler
        self.exit = exit

Feature(# Extra instructions
    handler=Code('''\
        if (error == MIT_ERROR_INVALID_OPCODE)
            if ((S->ir & MIT_OPCODE_MASK) == MIT_INSTRUCTION_JUMP) {
                error = mit_extra_instruction(S);
                if (error == MIT_ERROR_OK) {
                    S->ir = 0;
                    continue;
                }
            }
    '''),
)

Feature(# Parse number of words (for --memory and --stack)
    top_level=Code('''
        static mit_uword parse_num_words(const char *errfmt)
        {
            size_t max = SIZE_MAX / MIT_WORD_BYTES;
            char *endptr;
            errno = 0;
            uintmax_t size = strtoumax(optarg, &endptr, 10);
            if (*optarg == '\\0' || *endptr != '\\0' || size == 0 || size > (uintmax_t)max)
                die(errfmt, max);
            return (mit_uword)size;
        }
    '''),
)

Feature(# Error message on error exit
    exit=Code('''
        if (error != MIT_ERROR_HALT)
            // Cast error to size_t for printing because we might not be
            // able to print mit_uword.
            warn("error %zu: %s", (size_t)error, error_msg[error]);
    '''),
)

Feature(# Optimizing interpreter and profiling
    top_level=Code('''
        static void set_run_function(mit_fn *new_run_fn)
        {
            if (run_fn == new_run_fn ||
                (run_fn == mit_profile_run && new_run_fn == mit_specializer_run))
                ;
            else if (run_fn == mit_run)
                run_fn = new_run_fn;
            else
                die("incompatible execution options given; see %s --help", program_name);
        }
    '''),
    init=Code('char *profile_file = NULL;'),
    exit=Code('''
        if (profile_file != NULL) {{
            FILE *fp = fopen(profile_file, "w");
            if (fp == NULL)
                warn("could not open file %s", profile_file);
            else {{
                if (mit_profile_dump(fileno(fp)) == -1)
                    warn("error writing profile data");
                else
                    warn("wrote profile data to %s", profile_file);
                fclose(fp);
            }}
        }}
    '''),
)


# Generate output

# Errors
error_enum = Code()
for error in MitErrorCode:
    error_enum.append('"{}",'.format(
        error.name.lower().translate(str.maketrans('_', ' '))
    ))

# Command-line documentation
help_code = Code()
for element in Doc.elements:
    if isinstance(element, Option):
        arg = ''
        if element.arg_name: arg = element.arg_name
        if element.arg == 'optional_argument':
            arg = '[{}]'.format(arg)
        help_code.append('    printf("  %-26s", "--{long_name}{short_opt} {arg}");'.format(
            long_name=element.long_name,
            short_opt=', -{}'.format(element.short_name) if element.short_name else '',
            arg=arg,
        ))
        help_code.append('    printf({});'.format(element.docstring))
        help_code.append('    putchar(\'\\n\');')
    elif isinstance(element, Arg):
        help_code.append('printf("  %-26s%s\\n", "{arg}", {docstring});'.format(
            arg=element.arg,
            docstring=element.docstring
        ))
    elif isinstance(element, Doc):
        help_code.append('    printf({}"\\n");'.format(element.docstring))

# Command-line options
getopt_code = Code()
shortopts = ''
short_options_code = Code()
long_options_code = Code()
else_code = ''
for i, option in enumerate(Option.options):
    getopt_code.append('{{"{long_name}", {arg}, NULL, \'{short_name}\'}},'.format(
        long_name=option.long_name, arg=option.arg or '""',
        short_name=option.short_name or "\\0"))
    if option.short_name:
        shortopts += option.short_name
        if option.arg == 'required_argument':
            shortopts += ':'
        elif option.arg == 'optional_argument':
            shortopts += '::'
        short_options_code.append('''\
            if (c == '{short_name}')
                longindex = {index};'''.format(
                    short_name = option.short_name,
                    index = i
                ))
    if option.parse_code:
        long_options_code.append('{}if (longindex == {})'.format(else_code, i))
        long_options_code.append(option.parse_code)
        else_code = 'else '
getopt_code.append('{0, 0, 0, 0}')

# Features
top_level_code = Code('''\
    mit_fn *run_fn = mit_run;
    mit_word *memory;
    mit_uword memory_words, stack_words;
''')
init_code = Code('''\
    set_program_name(argv[0]);

    memory_words = 0x100000U;
    stack_words = 16384U;
''')
handlers_code = Code()
exit_code = Code()
for feature in Feature.features:
    if feature.top_level:
        top_level_code.extend(feature.top_level)
    if feature.init:
        init_code.extend(feature.init)
    if feature.handler:
        handlers_code.extend(feature.handler)
    if feature.exit:
        exit_code.extend(feature.exit)

# main.c
code = copyright_banner(GENERATOR_PROGRAM, PURPOSE, COPYRIGHT_YEARS)
initial_code = Code('''

#include "config.h"

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <inttypes.h>
#include <errno.h>
#include <signal.h>
#include <getopt.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>

#include "unused-parameter.h"
#include "progname.h"
#include "binary-io.h"
#include "minmax.h"
#include "safe-alloc.h"

#include "mit/mit.h"
#include "mit/features.h"

#include "warn.h"


// Error messages
const char *error_msg[] = {
''',
             error_enum,
             '''\
};

// Options table
struct option longopts[] = {''',
              getopt_code,
              '''\
};

static mit_state *S;

static void exit_function(void)
{
    mit_free_state(S);
}''')
code.extend(initial_code)

code.extend(top_level_code)
code.extend(Code('''
static off_t fleno(FILE *fp)
{
  off_t pos = ftello(fp);
  if (pos != -1 && fseeko(fp, 0, SEEK_END) == 0) {
    off_t len = ftello(fp);
    if (len != -1 && fseeko(fp, pos, SEEK_SET) == 0)
      return len;
  }
  return -1;
}

// Skip any #! header
static int skip_hashbang(FILE *fp)
{
    char buf[sizeof("#!") - 1];
    if (fread(&buf[0], 1, sizeof(buf), fp) != sizeof(buf))
        return -1;
    if (buf[0] == '#' && buf[1] == '!') {
        for (int res; (res = getc(fp)) != '\\n'; )
            if (res == EOF)
                return -1;
    }
    rewind(fp);
    return 0;
}

static void usage(void)
{
    printf("Usage: %s [OPTION...] [OBJECT-FILE ARGUMENT...]\\n"
           "\\n"
           "Run " PACKAGE_NAME " virtual machine code.\\n"
           "\\n",
           program_name);''',
              help_code,
              '''
    exit(EXIT_SUCCESS);
}

int main(int argc, char *argv[])
{
''',
              init_code,
              Code('''
    // Options string starts with '+' to stop option processing at first
    // non-option, then leading ':' so as to return ':' for a missing arg,
    // not '?'
    const char *shortopts = "+:{}";'''.format(shortopts)),
              Code('''
    for (;;) {
        int this_optind = optind ? optind : 1, longindex = -1;
        int c = getopt_long(argc, argv, shortopts, longopts, &longindex);

        if (c == -1)
            break;
        else if (c == ':')
            die("option '%s' requires an argument", argv[this_optind]);
        else if (c == '?')
            die("unrecognised option '%s'\\nTry '%s --help' for more information.", argv[this_optind], program_name);
'''),
              short_options_code,
              long_options_code,
              Code('}'),
              Code('''
    // If invoked without an object file, give usage message and exit
    argc -= optind;
    argv += optind;
    if (argc < 1)
        usage();

    // Set up VM
    memory = calloc(memory_words, MIT_WORD_BYTES);
    if (memory == NULL)
        die("could not allocate virtual machine memory");
    S = mit_new_state(stack_words);
    if (S == NULL)
        die("could not allocate virtual machine state");
    if (atexit(exit_function) != 0)
        die("could not register atexit handler");
    mit_argc = argc;
    mit_argv = &argv[0];
    S->pc = (mit_uword)memory;

    // Load object file and report any error
    {
        FILE *fp = fopen(argv[0], "rb");
        if (fp == NULL)
            die("cannot not open file %s", argv[0]);
        int ret = skip_hashbang(fp);
        if (ret == -1)
            die("error reading file %s", argv[0]);
        off_t len = fleno(fp);
        if (len == -1)
            die("error finding size of file %s", argv[0]);
        if ((size_t)len > memory_words * MIT_WORD_BYTES)
            die("file %s is too big to fit in memory", argv[0]);
        if ((off_t)fread(memory, 1, len, fp) != len)
            die("error reading file %s", argv[0]);
        if (fclose(fp) == EOF)
            die("error closing file %s", argv[0]);
    }

    // Run
    for (;;) {
        mit_word error = S->run_fn(S);''',
                 handlers_code,
                 exit_code),
            '''
        return error == MIT_ERROR_HALT ? 0 : error;
    }
}''',
))

print(code)
