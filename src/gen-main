#!/usr/bin/env python3
# Generate front-end.
#
# Copyright (c) 1995-2019 Mit authors
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

import os
import pathlib
import glob
import textwrap


# Command line

class CommandLineElement:
    elements = []
    def __init__(self):
        self.elements.append(self)
    
class Doc(CommandLineElement):
    '''
    Free-form documentation.

     - text - str - if the string starts and ends with a double quote, it is
       printed literally and may thus contain interpolations. Otherwise, it is
       output in quotes.
    '''
    def __init__(self, text):
        super().__init__()
        self.text = text

class Option(CommandLineElement):
    '''
    A command-line option.
    
     - long_name - str - long option name
     - docstring - str - argument docstring
     - short_name - str - short option char
     - arg - str - 'no_argument', 'required_argument' or 'optional_argument'
     - arg_name - str - name for the argument, if any
     - parse_code - str - code run when the option is parsed
    '''
    options = []
    def __init__(self, long_name, docstring, short_name=None,
                 arg=None, arg_name=None, parse_code=None):
        super().__init__()
        self.options.append(self)
        self.long_name = long_name
        self.docstring = docstring
        self.short_name = short_name
        self.arg = arg or 'no_argument'
        self.arg_name = arg_name
        self.parse_code = parse_code

class Arg(CommandLineElement):
    '''
    A command-line argument.

     - arg - str - argument name
     - docstring - str - argument docstring
    '''
    def __init__(self, arg, docstring):
        self.arg = arg
        self.docstring = docstring

Option('specializer',
       'use specializing interpreter',
       short_name='O',
       parse_code='run_fn = mit_specializer_run;',
)

Option('no-auto-extend',
       'do not automatically extend stack or memory',
       parse_code='auto_extend = false;',
)

Option('trace',
       'write dynamic instruction trace to FILE',
       arg='required_argument',
       arg_name='FILE',
       parse_code='''\
{
    trace_fp = fopen(optarg, "wb");
    run_fn = trace_run;
    if (trace_fp == NULL)
        die("cannot not open file %s", optarg);
    warn("trace will be written to %s\\n", optarg);
}
''')

Option('core-dump',
       'dump core on memory exception',
       short_name='c', arg='no_argument',
       parse_code='core_dump = true;',
)

Option('help',
       'display this help message and exit',
       parse_code='usage();'
)

Option('version',
       'display version information and exit',
       parse_code='''\
{
    printf(PACKAGE_NAME " " VERSION " (%d-byte word, %s-endian)\\n"
           "(c) Mit authors 1994-2019\\n"
           PACKAGE_NAME " comes with ABSOLUTELY NO WARRANTY.\\n"
           "You may redistribute copies of " PACKAGE_NAME "\\n"
           "under the terms of the MIT/X11 License.\\n",
           mit_WORD_BYTES, mit_ENDISM ? "big" : "little");
    exit(EXIT_SUCCESS);
}
''')

Arg('OBJECT-FILE', 'load and run object OBJECT-FILE')
Doc('')
Doc('"The ARGUMENTS are available to "PACKAGE_NAME"."')
Doc('''
If an error occurs during execution, the exit status is the error code; if
execution HALTs normally, the exit status is the top-most stack value.
''')
Doc('"Report bugs to "PACKAGE_BUGREPORT"."')


# Features

class Feature:
    '''
    A command-line option.

     - top_level_code - str - additional top-level code for the option
     - init_code - str - declarations inside main, and initialisation
     - exception_handler - str - cases added to the exception handler
    '''
    features = []
    def __init__(self, top_level_code=None, init_code=None,
                 exception_handler=None):
        self.features.append(self)
        self.top_level_code = top_level_code
        self.init_code = init_code
        self.exception_handler = exception_handler

Feature(# Auto-extend stack and memory
    init_code='bool auto_extend = true;',
    exception_handler='''\
case MIT_ERR_STACK_OVERFLOW:
case MIT_ERR_MEMORY_READ:
case MIT_ERR_MEMORY_WRITE:
    if (auto_extend == true && mit_auto_extend_handler(S, error) == 0)
        continue;
    break;''')

Feature(# Output instruction opcode trace
    top_level_code='''\
FILE *trace_fp;
static mit_WORD trace_run(mit_state *state)
{
    return mit_trace_run(state, trace_fp);
}
''',
)

Feature(# VM core dump
    init_code='bool core_dump = false;',
    exception_handler='''\
default:
    if (core_dump)
        mit_core_dump(S);
    break;''')


# Generate output

print('''\
// Auto-generated by gen-main - DO NOT EDIT.

// Front-end.

#include "config.h"

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdbool.h>
#include <getopt.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>

#include "progname.h"

#include "mit/mit.h"
#include "mit/features.h"


static _GL_ATTRIBUTE_FORMAT_PRINTF(1, 0) void verror(const char *format, va_list args)
{
    fprintf(stderr, PACKAGE ": ");
    vfprintf(stderr, format, args);
    fprintf(stderr, "\\n");
}

static _GL_ATTRIBUTE_FORMAT_PRINTF(1, 2) void warn(const char *format, ...)
{
    va_list args;

    va_start(args, format);
    verror(format, args);
}

static _GL_ATTRIBUTE_FORMAT_PRINTF(1, 2) void die(const char *format, ...)
{
    va_list args;

    va_start(args, format);
    verror(format, args);
    exit(1);
}
''')

print('''\
// Options table
struct option longopts[] = {''')
for element in CommandLineElement.elements:
    if isinstance(element, Option):
        print('    {{"{long_name}", {arg}, NULL, \'{short_name}\'}},'.format(
            long_name=element.long_name, arg=element.arg or '""',
            short_name=element.short_name or "\\0"))
print('''\
    {0, 0, 0, 0}
};''')

print('''
static void usage(void)
{
    printf("Usage: %s [OPTION...] [OBJECT-FILE ARGUMENT...]\\n"
           "\\n"
           "Run " PACKAGE_NAME ".\\n"
           "\\n",
           program_name);''')

for element in CommandLineElement.elements:
    if isinstance(element, Option):
        print('    printf("  %-26s%s\\n", "--{long_name}{short_opt} {arg_name}", "{docstring}");'.format(
            long_name=element.long_name,
            short_opt=', -{}'.format(element.short_name) if element.short_name else '',
            arg_name=element.arg_name or '',
            docstring=element.docstring,
        ))
    elif isinstance(element, Arg):
        print('printf("  %-26s%s\\n", {arg}, {docstring});'.format(
            arg=element.arg,
            docstring=element.docstring
        ))
    elif isinstance(element, Doc):
        text = element.text
        if len(text) > 1 and not(text[0] == '"' and text[-1] == '"'):
            text = '"{}"'.format(repr(text)[1:-1])
        print('    printf({}"\\n");'.format(text))

print('''
    exit(EXIT_SUCCESS);
}

static mit_state *S;

static void exit_function(void)
{
    mit_destroy(S);
}''')

for feature in Feature.features:
    if feature.top_level_code:
        print(feature.top_level_code)

print('''

int main(int argc, char *argv[])
{
    set_program_name(argv[0]);
    mit_WORD (*run_fn)(mit_state *) = mit_run;
''')

for feature in Feature.features:
    if feature.init_code:
        print(textwrap.indent(feature.init_code, '    '))

shortopts = ''
for element in CommandLineElement.elements:
    if isinstance(element, Option) and element.short_name:
        shortopts += element.short_name
        if element.arg == 'required_argument':
            shortopts += ':'
        elif element.arg == 'optional_argument':
            shortopts += '::'
print('''\
    // Options string starts with '+' to stop option processing at first
    // non-option, then leading ':' so as to return ':' for a missing arg,
    // not '?'
    const char *shortopts = "+:{}";'''.format(shortopts))

print('''
    for (;;) {
        int this_optind = optind ? optind : 1, longindex = -1;
        int c = getopt_long(argc, argv, shortopts, longopts, &longindex);

        if (c == -1)
            break;
        else if (c == ':')
            die("option '%s' requires an argument", argv[this_optind]);
        else if (c == '?')
            die("unrecognised option '%s'\\nTry '%s --help' for more information.", argv[this_optind], program_name);
''')

for i, option in enumerate(Option.options):
    if option.short_name:
        print('''\
        if (c == '{short_name}')
            longindex = {index};
'''.format(
    short_name = option.short_name,
    index = i
))

for i, option in enumerate(Option.options):
    if option.parse_code:
        print('        if (longindex == {})\n'.format(i) +
              textwrap.indent(option.parse_code, '            '))

print ('    }\n')
        
print('''\
    // If invoked without an object file, give usage message and exit
    argc -= optind;
    if (argc < 1)
        usage();

    // Set up VM
    S = mit_auto_extend_init();
    if (S == NULL)
        die("could not allocate virtual machine state");
    if (atexit(exit_function) != 0)
        die("could not register atexit handler");
    if (mit_register_args(S, argc, argv + optind) != 0)
        die("could not register command-line arguments");

    // Load object file and report any error
    int fd = open(argv[optind], O_RDONLY);
    if (fd < 0)
        die("cannot not open file %s", argv[optind]);
    int ret = mit_load_object(S, 0, fd);
    close(fd);
    const char *err = NULL;
    if (ret < 0)
        switch (ret) {
        case -1:
            err = "file system error";
            break;
        case -2:
            err = "module invalid";
            break;
        case -3:
            err = "module has wrong ENDISM or WORD_BYTES";
            break;
        case -4:
            err = "address out of range or unaligned, or module too large";
            break;
        default:
            err = "unknown error!";
            break;
        }
    if (err != NULL)
        die("%s: %s", argv[optind], err);
''')

print('''\
    // Run
    for (;;) {
        int error = run_fn(S);
        switch (error) {''')

for feature in Feature.features:
    if feature.exception_handler:
        print(textwrap.indent(feature.exception_handler, '        '))

print('''\
        }
        return error == 128 ? 0 : error;
    }
}''')
