#!/usr/bin/env python3
# Generate code for instructions.
#
# (c) Mit authors 1994-2019
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

import sys

from mit_core.vm_data import Instruction, InternalExtraInstruction
from mit_core.code_util import Code
from mit_core.instruction_gen import dispatch, gen_case
from mit_core.opcode_frequency import counts


if len(sys.argv) != 2:
    print("Usage: gen-instructions PREDICTOR-FILENAME", file=sys.stderr)
    sys.exit(1)


# Get instruction counts from predictor and compute order
with open(sys.argv[1]) as f:
    freqs = counts(Instruction, f)
instruction_order = [instruction for count, instruction in freqs]

# Write the output file
code = Code()
code.append('''\
    // Auto-generated by gen-instructions - DO NOT EDIT.
    // Run the virtual machine.

    #include "config.h"

    #include <stdbool.h>

    #include "mit/mit.h"

    #include "run.h"


    _GL_ATTRIBUTE_PURE mit_word mit_internal_extra_instruction(mit_state *S)
    {'''
)

body_code = Code()
body_code.append('mit_word error = MIT_ERROR_OK;')
body_code.append('mit_uword opcode = S->ir >> MIT_OPCODE_BIT;')
body_code.extend(dispatch(InternalExtraInstruction, Code(
    'RAISE(MIT_ERROR_INVALID_OPCODE);',
)))
code.append(body_code)

code.append('''
    error:
        return error;
    }'''
)

body_code = Code()
body_code.append('''\
    error = MIT_ERROR_OK;
    mit_byte opcode = S->ir & MIT_OPCODE_MASK;
    initial_pc = S->pc;
    initial_ir = S->ir;
    S->ir >>= MIT_OPCODE_BIT;

    // Check stack_depth is valid
    if (S->stack_depth > S->stack_words) {
        S->bad = S->stack_depth - S->stack_words;
        RAISE(MIT_ERROR_STACK_OVERFLOW);
    }'''
)
body_code.extend(dispatch(Instruction, Code(
    '/* Undefined instruction. */',
    'RAISE(MIT_ERROR_INVALID_OPCODE);',
), instruction_order))

code.append('''
    static mit_word run_or_step(mit_state * restrict real_S, bool run)
    {'''
)

code.append(Code(*['''\
    mit_state state = *real_S;
    mit_state *const S = &state;
    mit_word error;
    mit_uword initial_pc, initial_ir;

    do {''',
    body_code,
    '',
    'error:',
    Code('''\
        if (error != 0) {
            S->pc = initial_pc;
            S->ir = initial_ir;
        }

        if (error == MIT_ERROR_INVALID_OPCODE &&
            (S->ir & MIT_OPCODE_MASK) == MIT_INSTRUCTION_CALL &&
            (error = mit_internal_extra_instruction(S)) == MIT_ERROR_OK) {
            S->ir = 0;
        }'''
    ),
    '''\
    } while (likely(run == true) && likely(error == 0));

    *real_S = state;
    return error;''',
]))

code.append('''\
    }

    mit_word mit_single_step(mit_state * restrict S)
    {
        return run_or_step(S, false);
    }

    mit_word mit_run(mit_state * restrict S)
    {
        return run_or_step(S, true);
    }'''
)

print(code)
