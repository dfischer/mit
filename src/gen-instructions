#!/usr/bin/env python3
# Generate code for instructions.
#
# (c) Mit authors 1994-2019
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

import sys
import gzip

from mit_core.vm_data import Instruction, InternalExtraInstruction
from mit_core.code_buffer import Code
from mit_core.instruction_gen import dispatch, gen_case


if len(sys.argv) != 2:
    print("Usage: gen-instructions TRACE-FILENAME", file=sys.stderr)
    sys.exit(1)


# Read trace
trace_filename = sys.argv[1]
with gzip.open(trace_filename, 'rb') as f: trace = f.read()


# Write the output file
code = Code()
code.append('''\
    // Auto-generated by gen-instructions - DO NOT EDIT.
    // Run the virtual machine.

    #include "config.h"

    #include <stdbool.h>

    #include "mit/mit.h"

    #define DO_NEXT                                               \\
        do {                                                      \\
            int ret = load(S->memory, S->memory_size, S->PC,      \\
                           MIT_SIZE_WORD, (mit_word *)&(S->I));   \\
            if (ret != 0) {                                       \\
                S->BAD = S->PC;                                   \\
                RAISE(ret);                                       \\
            }                                                     \\
            S->PC += MIT_WORD_BYTES;                              \\
        } while (0)

    #define RAISE(code)                         \\
        return code;                            \\

    _GL_ATTRIBUTE_PURE mit_word mit_internal_extra_instruction(mit_state *S)
    {'''
)

body_code = Code()
body_code.append('mit_uword opcode = S->I >> mit_instruction_bit;')
body_code.extend(dispatch(InternalExtraInstruction, Code(
    'RAISE(MIT_ERROR_INVALID_OPCODE);',
)))
body_code.append('return MIT_ERROR_OK;')
code.append(body_code)

code.append('''\
    }

    #undef RAISE
    #define RAISE(code)                                               \\
        do {                                                          \\
            error = (code);                                           \\
            goto error;                                               \\
        } while (0)

    static mit_word run_or_step(mit_state * restrict S, bool run)
    {'''
)

body_code = Code()
body_code.append('''\
    error = MIT_ERROR_OK;
    initial_PC = S->PC;
    initial_I = S->I;
    mit_byte opcode = S->I & MIT_OPCODE_MASK;
    S->I >>= MIT_OPCODE_BIT;

    // Check STACK_DEPTH is valid
    if (S->STACK_DEPTH > S->stack_size) {
        S->BAD = S->STACK_DEPTH - S->stack_size;
        RAISE(MIT_ERROR_STACK_OVERFLOW);
    }'''
)
body_code.extend(dispatch(Instruction, Code(
    '/* Undefined instruction. */',
    'RAISE(MIT_ERROR_INVALID_OPCODE);',
), trace))
code.append(Code(*['''\
        mit_word error;
        mit_uword initial_PC, initial_I;
        do {''',
            body_code,
            '''
        } while (run == true && error == 0);'''
]))

code.append('''
    error:
        if (error != 0) {
            S->PC = initial_PC;
            S->I = initial_I;
            if (error == MIT_ERROR_INVALID_OPCODE &&
                (initial_I & MIT_OPCODE_MASK) == MIT_INSTRUCTION_CALL &&
                (error = mit_internal_extra_instruction(S)) == MIT_ERROR_OK) {
                S->I = 0;
            }
        }
        return error;
    }

    mit_word mit_single_step(mit_state * restrict S)
    {
        return run_or_step(S, false);
    }

    mit_word mit_run(mit_state * restrict S)
    {
        return run_or_step(S, true);
    }'''
)

print(code.unindented_str())
