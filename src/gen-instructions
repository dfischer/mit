#!/usr/bin/env python3
# Generate code for instructions.
#
# (c) SMite authors 1994-2019
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

import sys, pickle, textwrap

from smite_core.vm_data import Instructions
from smite_core import instruction_gen

# Load language.
if len(sys.argv) != 2:
    print("Usage: gen-instructions LABELS-FILE", file=sys.stderr)
    sys.exit(1)

class Label:
    '''
     - name - str - The C identifier of this Label.
     - cached_depth - int - the number of stack items that are cached in C
       variables at this Label.
     - checked_depth - int - the number of empty stack slots that are known to
       exist above the top of the stack at this Label.
     - guess - Instructions - the most probable next instruction.
     - if_correct - int - the Label index to jump to if `guess` is correct.
     - if_wrong - int - the Label index to jump to if `guess` is wrong.
    '''
    def __init__(
        self,
        name,
        cached_depth=0,
        checked_depth=0,
        guess=None,
        if_correct=None,
        if_wrong=None,
    ):
        self.name = name
        self.cached_depth = cached_depth
        self.checked_depth = checked_depth
        self.guess = guess
        self.if_correct = if_correct
        self.if_wrong = if_wrong

with open(sys.argv[1], "rb") as h:
    labels = [
        Label('A_{}'.format(index), ca, ch, Instructions[gu], ic, iw)
        for index, (ca, ch, gu, ic, iw) in enumerate(pickle.load(h))
    ]

def label_by_index(index):
    if index is None:
        return Label('A_ILLEGAL')
    return labels[index]

# Write the output file.
print('''\
// Auto-generated by gen-instructions - DO NOT EDIT.
// Run the virtual machine.

#include "config.h"

#include <assert.h>

#include "smite.h"
#include "opcodes.h"

#define RAISE(code)                                           \\
    do {                                                      \\
        res = (code);                                         \\
        S->PC = initial_PC;                                   \\
        S->I = initial_I;                                     \\
        goto RET;                                             \\
    } while (0)

#define NEXT                                                  \\
    do {                                                      \\
        if (S->I != 0)                                        \\
            RAISE(SMITE_ERR_INVALID_OPCODE);                  \\
        int ret = load(S, S->PC, smite_SIZE_WORD, (smite_WORD *)&(S->I)); \\
        if (ret != 0)                                         \\
            RAISE(ret);                                       \\
        S->PC += WORD_BYTES;                                  \\
    } while (0)
''')

print('''\
smite_WORD smite_single_step(smite_state *S) {
    smite_UWORD initial_PC = S->PC;
    smite_UWORD initial_I = S->I;
    smite_UWORD cached_depth = 0; // Always zero.
    int res = SMITE_ERR_OK;
    smite_BYTE opcode = S->I & SMITE_INSTRUCTION_MASK;
    S->I >>= SMITE_INSTRUCTION_BIT;

    // Check STACK_DEPTH is valid
    if (S->STACK_DEPTH > S->stack_size) {
        S->BAD = S->STACK_DEPTH - S->stack_size;
        RAISE(SMITE_ERR_STACK_OVERFLOW);
    }
''')

print(instruction_gen.dispatch(Instructions, 'O_', '''\
        /* Undefined instruction. */
        RAISE(SMITE_ERR_INVALID_OPCODE);
'''))

print('''
    return SMITE_ERR_OK;

RET:
    assert(cached_depth == 0);
    return res;
}
''')

print('''\
#define FETCH                                       \\
    do {                                            \\
        initial_PC = S->PC;                         \\
        initial_I = S->I;                           \\
        opcode = S->I & SMITE_INSTRUCTION_MASK;     \\
        S->I >>= SMITE_INSTRUCTION_BIT;             \\
    } while (0)

smite_WORD smite_run(smite_state *S) {
    int res = SMITE_ERR_OK;''')

# Declare stack cache variables.
max_cached_depth = max(label.cached_depth for label in labels)
if max_cached_depth > 0:
    print('''\
    smite_WORD {};'''.format(
        ', '.join(
            instruction_gen.CacheState.var_for_depth(pos, max_cached_depth)
            for pos in reversed(range(max_cached_depth))
        )
    ))

print('''\
    do {
        smite_UWORD initial_PC, initial_I;
        // The number of stack items cached in C variables.
        smite_UWORD cached_depth = 0;
        smite_BYTE opcode;

        FETCH;
        goto A_0;

        // Each A_XXX label has an expectation of what instruction sequence
        // probably comes next. If correct, there is a fast path for executing
        // that sequence, otherwise we fall back on a slow path with broader
        // expectations. Ultimately, we fall back to `A_ILLEGAL` which reports
        // an illegal instruction (the most unexpected case).
        //
        // The calling convention at each A_XXX label is as follows:
        //
        //  - On entry, `res` is `SMITE_ERR_OK`, `opcode` is the next opcode,
        //    and `I` has been right-shifted.
        //  - When an error occurs, call `RAISE(code)`.
        //    It sets `res` to the return code; then it resets PC and
        //    I to their initial values, and does "goto RET".
        //  - "goto RET" (but do not "return") at any time after completely
        //    executing at least one instruction, or never.
        //  - On exit, whether by `RAISE` or otherwise, all SMite
        //    registers must be set according to the SMite spec. In particular,
        //    there must be no side effects before a RAISE, except for the
        //    effects on STACK_DEPTH and PC described above.
        //    In addition, `cached_depth` must be set correctly.
''')

for label in labels:
    print('''\
    {label_name}:
        assert(res == SMITE_ERR_OK);
        assert(cached_depth == {cached_depth});
        if (opcode == O_{guess_name}) {{'''.format(
        label_name=label.name,
        cached_depth=label.cached_depth,
        guess_name=label.guess.name,
    ))
    # If correct.
    cache_state = instruction_gen.CacheState(label.cached_depth)
    label_c = label_by_index(label.if_correct)
    print(textwrap.indent(
        instruction_gen.gen_case(label.guess.value, cache_state),
        '            ',
    ))
    print(textwrap.indent(
        cache_state.flush(label_c.cached_depth),
        '            ',
    ))
    print('''\
            FETCH;
            goto {};
        }}'''.format(label_c.name)
    )
    # If wrong.
    cache_state = instruction_gen.CacheState(label.cached_depth)
    label_w = label_by_index(label.if_wrong)
    print(textwrap.indent(
        cache_state.flush(label_w.cached_depth),
        '            ',
    ))
    print('''\
        goto {};'''.format(label_w.name)
    )
    print()

print('''\
    A_ILLEGAL:
        {{
            assert(res == SMITE_ERR_OK);
            assert(cached_depth == 0);
            assert(opcode > {max_opcode});
            RAISE(SMITE_ERR_INVALID_OPCODE);
        }}'''.format(
    max_opcode=max(i.value.opcode for i in Instructions)
))
print()

print('''\
    RET:
        {
            switch (cached_depth) {'''
)
cache_state = instruction_gen.CacheState(max_cached_depth)
while cache_state.depth > 0:
    print('''\
            case {}:'''.format(cache_state.depth)
    )
    print(textwrap.indent(
        cache_state.flush(cache_state.depth - 1),
        '                ',
    ))
    print('''\
                // Falls through.'''
    )
print('''\
            case 0:
                break;
            default:
                assert(0); // Unreachable.
            }
        }
    } while (res == SMITE_ERR_OK);
    return res;
}''')
