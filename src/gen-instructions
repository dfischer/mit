#!/usr/bin/env python3
#
# (c) Mit authors 1994-2020
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

import argparse

from spec import Instructions
from code_util import Code, copyright_banner
import profile


GENERATOR_PROGRAM = 'gen-instructions'
PURPOSE = 'Run the virtual machine main loop (naive version).'
COPYRIGHT_YEARS = '1994-2020'


# Command-line arguments.
parser = argparse.ArgumentParser(
    prog=GENERATOR_PROGRAM,
    description='Generate naive interpreter',
)
args = parser.parse_args()


# Write the output file
code = copyright_banner(GENERATOR_PROGRAM, PURPOSE, COPYRIGHT_YEARS)
code.append('''

    #include "config.h"

    #include <stdbool.h>

    #include "mit/mit.h"
    #include "mit/features.h"

    #include "run.h"


    MIT_THREAD_LOCAL mit_fn *mit_run = mit_run_simple;
'''
)

body_code = Code()
body_code.append('''\
    mit_byte opcode = S->ir & MIT_OPCODE_MASK;
    initial_pc = S->pc;
    initial_ir = S->ir;
    S->ir = ARSHIFT(S->ir, MIT_OPCODE_BIT);

    // Check stack_depth is valid
    if (S->stack_depth > S->stack_words)
        RAISE(MIT_ERROR_STACK_OVERFLOW);'''
)
body_code.extend(Instructions.dispatch(Code(
    '/* Undefined instruction. */',
    'RAISE(MIT_ERROR_INVALID_OPCODE);',
)))

code.append('''
    static mit_word run_or_step(mit_state * restrict real_S, bool run)
    {'''
)

code.append(Code(*['''\
    mit_state state = *real_S;
    mit_state *const S = &state;
    mit_word error;
    mit_word *initial_pc;
    mit_uword initial_ir;

    do {''',
    body_code,
    '',
    Code('''\
    error = MIT_ERROR_BREAK;
    continue;
    '''),
    'error:',
    Code('''\
        S->pc = initial_pc;
        S->ir = initial_ir;'''
    ),
    '''\
    } while (likely(run == true) && likely(error == MIT_ERROR_BREAK));

    *real_S = state;
    return error;''',
]))

code.append('''\
    }

    mit_word mit_single_step(mit_state * restrict S)
    {
        return run_or_step(S, false);
    }

    mit_word mit_run_simple(mit_state * restrict S)
    {
        return run_or_step(S, true);
    }'''
)

print(code)
