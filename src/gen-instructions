#!/usr/bin/env python3
# Generate code for instructions.
#
# (c) Reuben Thomas 1994-2019
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

import sys, pickle, textwrap

from smite_core.events import Event, ALL_EVENTS, EVENT_NAMES
from smite_core import vm_data, instruction_gen

# Load language.
if len(sys.argv) != 2:
    print("Usage: gen-instructions LABELS-FILE", file=sys.stderr)
    sys.exit(1)
with open(sys.argv[1], "rb") as h:
    # [int, str, int?, int?]
    labels = pickle.load(h)

label_names = {
    label: 'A_{}'.format(label)
    for label, _ in enumerate(labels)
}
label_names[None] = 'A_ILLEGAL'

label_depths = {
    label: depth
    for label, (depth, _, _, _) in enumerate(labels)
}
label_depths[None] = 0

# Write the output file.
print('''\
// Auto-generated by gen-instructions - DO NOT EDIT.
// The interface calls single_step() : integer and run() : integer.

#include "config.h"

#include <assert.h>

#include "smite.h"
#include "opcodes.h"
#include "extra.h"

#define RAISE(code)                         \\
    do {                                    \\
        res = (code);                       \\
        S->PC = initial_PC;                 \\
        S->STACK_DEPTH = initial_STACK_DEPTH; \\
        goto RET;                           \\
    } while(0)

static inline int LOAD_IMMEDIATE_WORD(smite_state *S, smite_UWORD addr, smite_WORD *value)
{
    smite_WORD v = 0;
    for (unsigned i = WORD_SIZE; i > 0; i--) {
        smite_BYTE b;
        int ret = load_byte(S, addr + i - 1, &b);
        if (ret != 0)
            return ret;
        v = (v << smite_BYTE_BIT) | b;
    }
    *value = v;
    return SMITE_ERR_OK;
}
''')

print('''\
smite_WORD smite_single_step(smite_state *S) {
    smite_UWORD initial_PC = S->PC;
    smite_UWORD initial_STACK_DEPTH = S->STACK_DEPTH;
    smite_UWORD cached_depth = 0; // Always zero.
    int res = SMITE_ERR_OK, error;
    smite_BYTE I;
    error = load_byte(S, S->PC++, &I);
    if (error != 0) {
        RAISE(error);
    }
''')

print(instruction_gen.dispatch(vm_data.Instructions, 'O_', '''\
        // Undefined instruction; try extra instructions.
        {
            error = smite_extra(S, I);
            if (error != 0)
                RAISE(error);
        }'''
))

print('''
    return SMITE_ERR_OK;

RET:
    assert(cached_depth == 0);
    return res;
}
''')

print('''\
#define FETCH                                       \\
    do {                                            \\
        initial_PC = S->PC;                         \\
        initial_STACK_DEPTH = S->STACK_DEPTH;       \\
        error = smite_load_byte(S, S->PC++, &NEXT); \\
        if (error != 0)                             \\
            RAISE(error);                           \\
    } while (0)

smite_WORD smite_run(smite_state *S) {
    int res = SMITE_ERR_OK, error;''')

# Declare stack cache variables.
max_cached_depth = max(d for d, _, _, _ in labels)
if max_cached_depth > 0:
    print('''\
    smite_WORD {};'''.format(
        ', '.join(
            instruction_gen.stack_cache_var(pos, max_cached_depth)
            for pos in reversed(range(max_cached_depth))
        )
    ))

print('''\
    do {
        smite_UWORD initial_PC, initial_STACK_DEPTH;
        smite_UWORD cached_depth = 0;
        smite_BYTE NEXT;

        FETCH;
        goto A_0;

        // Each A_XXX label has an expectation of what instruction sequence
        // probably comes next. If correct, there is a fast path for executing
        // that sequence, otherwise we fall back on a slow path with broader
        // expectations. Ultimately, we fall back to `A_ILLEGAL` which reports
        // an illegal instruction (the most unexpected case) or dispatches an
        // extra (implementation-specific) instruction.
        //
        // The calling convention at each A_XXX label is as follows:
        //
        //  - On entry, `res` is `SMITE_ERR_OK`, `NEXT` is the first byte of
        //    the next instruction, `PC` has been incremented, and
        //    `STACK_DEPTH` has been decremented to pop the arguments.
        //  - When an error occurs, call `RAISE(code)`.
        //    It sets `res` to the return code; then it resets the stack depth
        //    to the depth on entry, and does "goto RET".
        //  - "goto RET" (but do not "return") at any time after completely
        //    executing at least one instruction, or never.
        //  - On exit, whether by `RAISE` or otherwise, all SMite
        //    registers must be set according to the SMite spec. In particular,
        //    there must be no side effects before a RAISE, except for the
        //    effects on STACK_DEPTH and PC described above.
''')

for label, (depth, name, if_correct, if_wrong) in enumerate(labels):
    event = EVENT_NAMES[name]
    print('''\
    {label}:
        assert(res == SMITE_ERR_OK);
        cached_depth = {depth};
        if ({guess_code}) {{
            // {name}
{instruction_code}
            FETCH;
            goto {label_if_correct};
        }}
{balance_code}
        goto {label_if_wrong};
'''.format(
            label=label_names[label],
            depth=depth,
            guess_code=event.guess_code,
            name=event.name,
            instruction_code=textwrap.indent(
                instruction_gen.gen_case(
                    event,
                    cached_depth_entry=depth,
                    cached_depth_exit=label_depths[if_correct],
                ),
                '            ',
            ),
            label_if_correct=label_names[if_correct],
            balance_code=textwrap.indent(
                instruction_gen.balance_cache(depth, label_depths[if_wrong]),
                '        ',
            ),
            label_if_wrong=label_names[if_wrong],
        )
    )

print('''\
    A_ILLEGAL:
        {{
            assert(res == SMITE_ERR_OK);
            cached_depth = {};
            // Pretend we fetched the instruction the formal way.
            S->PC--;
            smite_BYTE I;
            error = load_byte(S, S->PC++, &I);
            if (error != 0)
                RAISE(error);

            assert(I > {});
            // Undefined instruction; try extra instructions.
            error = smite_extra(S, I);
            if (error != 0)
                RAISE(error);
            goto RET;
        }}
'''.format(
    label_depths[None],
    max(i.value.opcode for i in vm_data.Instructions)
))

print('''\
    RET:
        {
            switch (cached_depth) {''')
for depth in range(max_cached_depth, 0, -1):
    print('''\
            case {depth}:
                UNCHECKED_STORE_STACK(cached_depth - {depth}, {var});
                // Falls through.'''.format(
        depth=depth,
        var=instruction_gen.stack_cache_var(0, depth),
    ))
print('''\
            case 0:
                break;
            default:
                assert(0); // Unreachable.
            }
        }
    } while (res == SMITE_ERR_OK);
    return res;
}''')
