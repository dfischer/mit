#!/usr/bin/env python3
# Generate code for instructions.
#
# (c) Mit authors 1994-2019
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

from mit_core import vm_data, instruction_gen

from mit_core.vm_data import Instruction, InternalExtraInstruction
from mit_core.code_buffer import Code
from mit_core.instruction_gen import dispatch, gen_case


# Write the output file
print('''\
// Auto-generated by gen-instructions - DO NOT EDIT.
// Run the virtual machine.

#include "config.h"

#include "mit/mit.h"

#define NEXT                                                  \\
    do {                                                      \\
        int ret = load(S, S->PC, MIT_SIZE_WORD, (mit_word *)&(S->I)); \\
        if (ret != 0)                                         \\
            RAISE(ret);                                       \\
        S->PC += MIT_WORD_BYTES;                              \\
    } while (0)

#define RAISE(code)                         \\
    return (code);                          \\

_GL_ATTRIBUTE_PURE mit_word mit_internal_extra_instruction(mit_state *S)
{
    mit_uword opcode = S->I >> mit_instruction_bit;
''')

print(dispatch(InternalExtraInstruction, 'O_EXTRA_', Code('/* FIXME */')))

print('''\
    return MIT_ERROR_OK;
}

#undef RAISE
#define RAISE(code)                                               \\
    do {                                                          \\
        error = (code);                                           \\
        goto error;                                               \\
    } while (0)

mit_word mit_single_step(mit_state * restrict S)
{
    mit_word error = MIT_ERROR_OK;
    mit_uword initial_PC = S->PC;
    mit_uword initial_I = S->I;
    mit_byte opcode = S->I & MIT_INSTRUCTION_MASK;
    S->I >>= MIT_INSTRUCTION_BIT;

    // Check STACK_DEPTH is valid
    if (S->STACK_DEPTH > S->stack_size) {
        S->BAD = S->STACK_DEPTH - S->stack_size;
        RAISE(MIT_ERROR_STACK_OVERFLOW);
    }
''')

print(dispatch(Instruction, 'O_', Code(
    '/* Undefined instruction. */',
    'RAISE(MIT_ERROR_INVALID_OPCODE);',
)))

print('''

    return MIT_ERROR_OK;

error:
    S->PC = initial_PC;
    S->I = initial_I;
    if (error == MIT_ERROR_INVALID_OPCODE &&
        (initial_I & MIT_INSTRUCTION_MASK) == O_CALL &&
        (error = mit_internal_extra_instruction(S)) == 0) {
        S->I = 0;
        return MIT_ERROR_OK;
    }
    return error;
}


mit_word mit_run(mit_state * restrict S)
{
    mit_word ret;
    while ((ret = mit_single_step(S)) == 0)
        ;
    return ret;
}''')
