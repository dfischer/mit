# Specialized interpreter Makefile.am
#
# (c) Mit authors 2019-2020
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

# The specialized interpreter is generated by running `make specialize N=n`,
# which repeatedly runs `make specialize-once`.

# Typically, the first four to seven iterations of `make specialize`
# improves performance significantly, but greater improvements are often
# found later; 20 iterations is recommended.

# `make specialize-once` performs the following steps:
#
# 1. Profile some VM code with `mit_run_profile`. A profile records how
# often each state in the current specialized interpreter was reached, and
# how often the next state was correctly predicted.
#
# 2. `make` then calls itself recursively to regenerate the specialized
# interpreter using the new profile:
#
#   a. `labels.json` is built by `simulate-jit`, which reads
#      a profile and constructs a new control-flow graph for the specialized
#      interpreter.
#
#   b. `specializer.c` is then generated by `gen-specializer`.

# `make specialize` keeps a copy of each profile it produces as
# `profile-N.json`. The best is also left as `profile.json`.

# Mit can be bootstrapped by starting with a `profile.json` containing just
# an empty list "[]".

# `make specialize` times iterations using oprofile (see
# `repeat-specialize`).
#
# oprofile requires Linux. It also needs the following kernel setting:
#
# As root: echo 1 > /proc/sys/kernel/perf_event_paranoid
#
# configure.ac contains code to detect the CPU type, which affects the name
# of the counter to use.

nodist_libmit_la_SOURCES += %D%/specializer.c

TEST_EXTENSIONS = .pforth
PFORTH_LOG_COMPILER = $(SHELL)
TESTS_ENVIRONMENT = \
	export abs_top_srcdir="$(abs_top_srcdir)" \
	export TIME_BINARY="$(TIME)"; \
	export MIT_BINARY="$(MIT_BINARY)";
bench:
	$(MAKE) check TESTS="$(BENCH_TESTS)"

if USING_PFORTH
specializer/pforth/src/highlevel.fs: specializer/pforth/config.status
specializer/pforth/config.status: specializer/pforth/configure
specializer/pforth/configure: specializer/pforth/configure.ac
	cd specializer/pforth && \
	autoreconf -i && \
	./configure --build=mit BUILD_EXECUTOR=$(MIT_BINARY) BUILD_EXECUTOR_FLAGS=-O
check_DATA = specializer/pforth/src/highlevel.fs

TESTS = \
	%D%/build-pforth.pforth

BENCH_TESTS = \
	%D%/pforth-bench.pforth
endif

# Alternative profile-building arguments:
PROFILE_PFORTH_ARGS=make.fs
#PROFILE_PFORTH_ARGS=--evaluate BYE
#PROFILE_PFORTH_ARGS=tests.fs # (needs something on standard input)
specialize-once: mit@PACKAGE_SUFFIX@$(EXEEXT)
	export LD_LIBRARY_PATH=$(abs_top_builddir)/src/@objdir@:$(abs_top_builddir)/src/%D%/@objdir@:$$LD_LIBRARY_PATH; \
	cd %D%/pforth/src/mit && \
	$(abs_top_builddir)/python/mit-profile $(abs_builddir)/%D%/profile.json pforth $(PROFILE_PFORTH_ARGS) && \
	cd $(abs_builddir) && \
	$(MAKE)

%D%/labels.json: mit_core/code_util.py mit_core/params.py mit_core/instruction.py mit_core/spec.py %D%/profile.json %D%/simulate-jit %D%/path.py %D%/profile.py
	$(PYTHON_WITH_PATH) $(srcdir)/%D%/simulate-jit $(srcdir)/%D%/profile.json $@

%D%/specializer.c: mit_core/code_util.py mit_core/instruction.py mit_core/stack.py mit_core/spec.py mit_core/instruction_gen.py %D%/specializer.am %D%/gen-specializer %D%/specializer.py %D%/spec.py %D%/labels.json
	$(PYTHON_WITH_PATH) $(srcdir)/%D%/gen-specializer %D%/labels.json > %D%/specializer.c || ( rm -f %D%/specializer.c; exit 1 )

%D%/specializer.lo: include/mit/mit.h

specialize: mit@PACKAGE_SUFFIX@$(EXEEXT)
	export MIT_BINARY=$(MIT_BINARY); \
	export TIME_BINARY="operf $(OPERF_OPTIONS)"; \
	$(PYTHON_WITH_PATH) $(srcdir)/specializer/repeat-specialize --times $(N)

EXTRA_DIST += \
	%D%/path.py \
	%D%/profile.py \
	%D%/spec.py \
	%D%/specializer.py \
	%D%/simulate-jit \
	%D%/gen-specializer \
	%D%/repeat-specialize \
	%D%/profile.json

DISTCLEANFILES += \
	%D%/labels.json \
	%D%/specializer.c
