// Public data structures and interface calls specified in the VM definition.
// This is the header file to include in programs using an embedded VM.
//
// (c) Reuben Thomas 1994-2018
//
// The package is distributed under the GNU Public License version 3, or,
// at your option, any later version.
//
// THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€˜S
// RISK.

#ifndef PACKAGE_UPPER_PACKAGE_UPPER
#define PACKAGE_UPPER_PACKAGE_UPPER


#include "config.h"

#include <stdio.h>      // for the FILE type
#include <stdbool.h>
#include <stdint.h>
#include <inttypes.h>
#include <limits.h>

#include "gl_list.h"


// Parameters
#define WORD_SIZE @WORD_SIZE@
#define NATIVE_POINTER_SIZE (sizeof(void *))

// Basic types
typedef uint8_t BYTE;
#if WORD_SIZE == 4
typedef int32_t WORD;
#define UWORD_MAX (UINT32_MAX)
#define WORD_MIN (INT32_MIN)
#define PRI_WORD PRId32
#define PRI_UWORD PRIu32
#define PRI_XWORD PRIx32
typedef uint32_t UWORD;
#elif WORD_SIZE == 8
typedef int64_t WORD;
#define UWORD_MAX (UINT64_MAX)
#define WORD_MIN (INT64_MIN)
#define PRI_WORD PRId64
#define PRI_UWORD PRIu64
#define PRI_XWORD PRIx64
typedef uint64_t UWORD;
#else
#error "WORD_SIZE is not 4 or 8!"
#endif
#define BYTE_BIT 8
#define BYTE_MASK ((1 << BYTE_BIT) - 1)
#undef WORD_BIT // FIXME: prefix this and other symbols
#define WORD_BIT (WORD_SIZE * BYTE_BIT)
#define WORD_MASK UWORD_MAX

// VM registers

// ENDISM is fixed at compile-time, which seems reasonable, as
// machines rarely change endianness while switched on!
#ifdef WORDS_BIGENDIAN
#define ENDISM ((BYTE)1)
#else
#define ENDISM ((BYTE)0)
#endif

struct _state {
    UWORD PC;
    WORD I;
    UWORD MEMORY;
    UWORD SP, RP;
    UWORD S0, R0;
    UWORD HASHS, HASHR;
    UWORD HANDLER;
    UWORD BADPC;
    UWORD INVALID;
    WORD *memory;
    gl_list_t mem_areas;
    WORD *d_stack;
    WORD *r_stack;
    UWORD _mem_here;
    UWORD here;	// (FIXME: debug.c) where the next instruction will be stored
    int main_argc;
    UWORD *main_argv;
    UWORD *main_argv_len;
};
typedef struct _state state;

// Memory access

// Return value is 0 if OK, or exception code for invalid or unaligned address
int load_word(state *state, UWORD addr, WORD *value);
int store_word(state *state, UWORD addr, WORD value);
int load_byte(state *state, UWORD addr, BYTE *value);
int store_byte(state *state, UWORD addr, BYTE value);

int pre_dma(state *state, UWORD from, UWORD to, bool write);
int post_dma(state *state, UWORD from, UWORD to);

// Memory mapping
UWORD mem_here(state *state);
UWORD mem_allot(state *state, void *p, size_t n, bool writable);
UWORD mem_align(state *state);

// Interface calls
uint8_t *native_address(state *state, UWORD addr, bool writable);
WORD run(state *state);
WORD single_step(state *state);
int load_object(state *state, FILE *file, UWORD address);

// Additional implementation-specific routines, macros, types and quantities
state *init(WORD *c_array, size_t size, size_t stack_size, size_t return_stack_size);
void destroy(state *state);
int register_args(state *state, int argc, char *argv[]);

// A union to allow storage of machine pointers in VM memory
union _WORD_pointer {
    WORD words[NATIVE_POINTER_SIZE / WORD_SIZE];
    void (*pointer)(state *state);
};
typedef union _WORD_pointer WORD_pointer;

#endif
