// Public data structures and interface calls specified in the VM definition.
// This is the header file to include in programs using an embedded VM.
//
// (c) Reuben Thomas 1994-2019
//
// The package is distributed under the GNU Public License version 3, or,
// at your option, any later version.
//
// THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€˜S
// RISK.

#ifndef PACKAGE_UPPER_PACKAGE_UPPER
#define PACKAGE_UPPER_PACKAGE_UPPER


#include <stddef.h>
#include <stdint.h>
#include <inttypes.h>


// Types
#define WORD_SIZE @WORD_SIZE@
typedef uint8_t BYTE;
#if WORD_SIZE == 4
typedef int32_t WORD;
#define PRI_WORD PRId32
#define PRI_UWORD PRIu32
#define PRI_XWORD "#"PRIx32
typedef uint32_t UWORD;
#elif WORD_SIZE == 8
typedef int64_t WORD;
#define PRI_WORD PRId64
#define PRI_UWORD PRIu64
#define PRI_XWORD "#"PRIx64
typedef uint64_t UWORD;
#else
#error "WORD_SIZE is not 4 or 8!"
#endif
typedef WORD * WORDP;
#define PRI_XUWORD PRI_XWORD
#define PRI_Xsmite_UWORD PRI_XWORD
#define PRI_smite_UWORD PRI_UWORD
#define PRI_XWORDP "p"
#define PRI_WORDP "p"
typedef void (*callback_t)(void *);

// Parameters
extern const unsigned word_size;
extern const unsigned native_pointer_size;
#define BYTE_BIT 8
extern const unsigned byte_bit;
extern const unsigned byte_mask;
extern const unsigned word_bit;
extern const UWORD word_mask;
extern const UWORD uword_max;
extern const WORD word_min;

// VM registers
typedef struct _state state;

#define R_RO(reg, type, utype)                  \
    type get_ ## reg(state *state);
#define R(reg, type, utype)                     \
    R_RO(reg, type, utype)                      \
    void set_ ## reg(state *state, type value);
#include "register-list.h"
#undef R
#undef R_RO

// Memory access
// Return value is 0 if OK, or exception code for invalid or unaligned address
int load_word(state *state, UWORD addr, WORD *value);
int store_word(state *state, UWORD addr, WORD value);
int load_byte(state *state, UWORD addr, BYTE *value);
int store_byte(state *state, UWORD addr, BYTE value);

// Stack access
int load_stack(state *state, UWORD pos, WORD *v);
int store_stack(state *state, UWORD pos, WORD v);
int pop_stack(state *state, WORD *v);
int push_stack(state *state, WORD v);

int load_return_stack(state *state, UWORD pos, WORD *v);
int store_return_stack(state *state, UWORD pos, WORD v);
int pop_return_stack(state *state, WORD *v);
int push_return_stack(state *state, WORD v);

// Interface calls
uint8_t *native_address_of_range(state *state, UWORD addr, UWORD length);
WORD run(state *state);
WORD single_step(state *state);
ptrdiff_t load_object(state *state, UWORD address, int fd);
int save_object(state *state, UWORD address, UWORD length, int fd);

// Additional implementation-specific routines, macros, types and quantities
state *init(size_t size, size_t stack_size, size_t return_stack_size);
int mem_realloc(state *state, UWORD size);
void destroy(state *state);
int register_args(state *state, int argc, char *argv[]);


#endif
