// Public data structures and interface calls.
// This is the header file to include in programs using Mit.
//
// (c) Mit authors 1994-2020
//
// The package is distributed under the MIT/X11 License.
//
// THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
// RISK.

#ifndef MIT_MIT
#define MIT_MIT


#include <stddef.h>
#include <stdint.h>
#include <inttypes.h>

#include <mit/opcodes.h>


// Optimization
// Hint that `x` is usually true/false.
// https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html
#if @HAVE___BUILTIN_EXPECT@ == 1
#define likely(x) __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)
#else
#define likely(x) (x)
#define unlikely(x) (x)
#endif

// Thread-local storage
#define MIT_THREAD_LOCAL @THREAD_LOCAL@

// Build-time parameters
#define MIT_WORD_BYTES @SIZEOF_SIZE_T@
#define MIT_OPCODE_BIT @OPCODE_BIT@

// Types and constants
// Define MIT_WORD_BIT as a number literal so we can token paste it below
#if MIT_WORD_BYTES == 4
#define MIT_WORD_BIT 32
#define MIT_SIZE_WORD 2
#elif MIT_WORD_BYTES == 8
#define MIT_WORD_BIT 64
#define MIT_SIZE_WORD 3
#else
#error "MIT_WORD_BYTES must be 4 or 8!"
#endif

typedef uint8_t mit_byte;
#define MIT_BYTE_BIT @MIT_BYTE_BIT@
#define MIT_BYTE_MASK ((1 << MIT_BYTE_BIT) - 1)

#define MIT_WORD_MASK ((mit_uword)((mit_word)-1))
#define MIT_UWORD_MAX MIT_WORD_MASK
#define MIT_WORD_MIN ((mit_word)(MIT_UWORD_MAX << (MIT_WORD_BIT - 1)))
#define MIT_WORD_MAX ((mit_word)(MIT_UWORD_MAX >> 1))

#define _bits_type_name(prefix, bits) prefix ## bits ## _t
#define bits_type_name(prefix, bits) _bits_type_name(prefix, bits)
typedef bits_type_name(int, MIT_WORD_BIT) mit_word;
typedef bits_type_name(uint, MIT_WORD_BIT) mit_uword;

// TODO: find largest type: bigger of long double and intmax_t?
// Number in next line is sizeof(intmax_t)
#if MIT_WORD_BYTES < @SIZEOF_INTMAX_T@
typedef uintmax_t mit_max_stack_item_t;
#else
typedef mit_uword mit_max_stack_item_t;
#endif

// Forward declaration
typedef struct mit_state mit_state;

// The type of a function that mutates the VM
typedef mit_word mit_fn(mit_state * restrict S);

// VM State
struct mit_state {
#define R(reg, type, return_type) type reg;
#include <mit/registers.h>
#undef R
};

// Constants (for easy FFI binding)
extern const unsigned mit_word_bytes;
extern const unsigned mit_byte_bit;
extern const unsigned mit_byte_mask;
extern const unsigned mit_word_bit;
extern const mit_uword mit_word_mask;
extern const mit_uword mit_uword_max;
extern const mit_word mit_word_min;
extern const mit_word mit_word_max;

// Implementation-defined errors
enum {
    MIT_ERROR_STARTUP_ERROR = 128,
};

// Instructions
#if MIT_OPCODE_BIT < 5 || MIT_OPCODE_BIT > 8
#error "MIT_OPCODE_BIT must be in the range 5 to 8 inclusive!"
#endif
#define MIT_OPCODE_MASK ((1 << MIT_OPCODE_BIT) - 1)
extern const unsigned mit_opcode_bit;
extern const unsigned mit_opcode_mask;

// Inline functions
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
_GL_ATTRIBUTE_CONST static int is_aligned(mit_uword addr, unsigned size)
{
    return (addr & (size - 1)) == 0;
}
#pragma GCC diagnostic pop


// Stack access

int mit_load_stack(mit_state *S, mit_uword pos, mit_word *val_ptr);
/* Load the word position `pos` on the stack into the word pointed to by
   `val_ptr`.

   Return 0 if OK, or error code if `pos` is invalid.
*/

int mit_store_stack(mit_state *S, mit_uword pos, mit_word val);
/* Store the word `val` into the word at position `pos` on the stack.

   Return 0 if OK, or error code if `addr` is invalid.
*/

int mit_pop_stack(mit_state *S, mit_word *val_ptr);
/* Load the word at position `0` on the stack into the word pointed to by
   `val_ptr`, and decrement `stack_depth`.

   Return 0 if OK, or error code if position `0` is invalid.
 */

int mit_push_stack(mit_state *S, mit_word val);
/* Increment `stack_depth`, then store the word `val` at position 0 on
   the stack.

   Return 0 if OK, or error code if `stack_depth` is greater than or equal
   to `S->stack_words`.
*/


// Unchecked macro: UNSAFE!
#define UNCHECKED_STACK(stack, stack_depth, pos) \
    ((stack) + (stack_depth) - (mit_uword)(pos) - 1)

// Inline functions
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
static int load_stack(mit_word * restrict stack, mit_uword stack_depth,
                      mit_uword pos, mit_word *vp)
{
    if (unlikely(pos >= stack_depth))
        return MIT_ERROR_INVALID_STACK_READ;

    *vp = *UNCHECKED_STACK(stack, stack_depth, pos);
    return MIT_ERROR_OK;
}

static int store_stack(mit_word * restrict stack, mit_uword stack_depth,
                       mit_uword pos, mit_word v)
{
    if (unlikely(pos >= stack_depth))
        return MIT_ERROR_INVALID_STACK_WRITE;

    *UNCHECKED_STACK(stack, stack_depth, pos) = v;
    return MIT_ERROR_OK;
}
#pragma GCC diagnostic pop


// VM instantiation and control

mit_state *mit_new_state(size_t stack_words);
/* Create and initialize a virtual machine state.

   - stack_words - number of words of stack space required (may be 0)

   Return a pointer to a new state, or `NULL` if memory cannot be allocated,
   or if any requested size is larger than `MIT_UWORD_MAX`.

   The stack is zeroed, and the registers are initialized as per the spec.
*/

void mit_free_state(mit_state *S);
/* Free the given state, deallocating its memory. */

extern @THREAD_LOCAL@ mit_fn *mit_run;
/* Execute VM code. Defaults to `mit_run_simple`. Can be set to any
   compatible function, which thereby propagates to nested VMs via the `RUN`
   extra instruction. This allows a different implementation (optimized,
   profiling) to be used globally.
*/

mit_word mit_run_simple(mit_state * restrict S);
/* Start the execution cycle in the given state as described in the spec.
   If an error is raised, the code is returned.

   This is the default naive implementation.
*/

mit_word mit_single_step(mit_state * restrict S);
/* Execute a single pass of the execution cycle in the given state.
   Return MIT_ERROR_SINGLE_STEP_COMPLETED if execution completes without
   error, or the error code.
*/

mit_word mit_internal_extra_instruction(mit_state *S);
/* Execute an internal instruction, given by `S->ir`. */

mit_word mit_run_specializer(mit_state * restrict S);
/* Like `mit_run_simple`, but (hopefully) faster. */

// N.B. The profiler is per-thread, not per-`mit_state`.
void mit_profile_reset(void);
/* Clears the profile. */
mit_word mit_run_profile(mit_state * restrict S);
/* Like `mit_run_specializer`, but records profiling information. */
int mit_profile_dump(int fd);
/* Dump profiling information to file descriptor `fd`. */

extern int mit_argc;
/* The registered value of `argc`. */
extern char **mit_argv;
/* The registered value of `argv`. */

#endif
