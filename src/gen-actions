#!/usr/bin/env python3

import sys, pickle

from events import Event, ALL_EVENTS, EVENT_NAMES
import vm_data

# Load language.
if len(sys.argv) != 2:
    print("Usage: gen-actions LANGUAGE-FILE", file=sys.stderr)
    sys.exit(1)
with open(sys.argv[1], "rb") as h:
    # [((str, ...), float)]
    language = pickle.load(h)

all_singletons = set(path[0] for path, _ in language if len(path) == 1)
# FIXME: assert all_singletons == set(event.name for event in ALL_EVENTS)

# path (tuple of event (bytes)) -> count (float).
count_index = {
    path: count
    for path, count in language
}

class Path:
    '''
    Represents one of the plausible sequences of events in the language.

     - path - tuple of event (str).
     - count - estimated occurences of `path`.
     - guesses - possible next Events in decreasing order of probability.
    '''

    def __init__(self, path):
        self.path = path
        self.count = count_index[path]
        self.guesses = sorted(
            [
                event
                for event in ALL_EVENTS
                if path + (event.name,) in count_index
            ],
            key=lambda event: count_index[path + (event.name,)],
            reverse=True,
        )

language_index = {path: Path(path) for path, _ in language}

# TODO: Assert that language is prefix- and suffix-closed.

# Control-flow states, and what to do in them.

class Label:
    '''
    Represents a control-flow state of the interpreter. Successor Labels are
    represented as integers; these are mapped to Labels by the
    `label_map` argument of `generate_body()`.

    `None`, used as a Label, represents the initial state.

     - name - str - the C identifier of this Label.
    '''

    def __init__(self, index):
        '''
         - index - int - used to construct `self.name`.
        '''
        self.name = 'F_{}'.format(index);

    def generate_body(self, label_map):
        raise NotImplementedError

    @staticmethod
    def goto(label):
        '''Returns a C statement that jumps to `label`.'''
        if label is None:
            return '''return EXIT(S);'''
        else:
            return '''return (action){{{}}};'''.format(label.name)

class Guess(Label):
    '''
    A Label at which we will guess the next event.
     - guess - Event.
     - if_correct - int - the label to go to if the guess is correct.
     - if_wrong - int - the label to go to if the guess is wrong.
    '''
    def __init__(self, index, guess, if_correct, if_wrong):
        '''
         - index - passed to superclass.
        '''
        super().__init__(index)
        assert isinstance(guess, Event)
        self.guess = guess
        self.if_correct = if_correct
        self.if_wrong = if_wrong

    def generate_body(self, label_map):
        # TODO: trace().
        print('''\
    if ({}) {{
        // {}
{}
        FETCH
        {}
    }} else
        {}'''.format(
            self.guess.guess_code,
            self.guess.name,
            self.guess.exec_code,
            self.goto(label_map[self.if_correct]),
            self.goto(label_map[self.if_wrong]),
        ))

class Goto(Label):
    '''
    A Label in which we will unconditionally go to another Label.

     - goto - int - the Label to go to.
    '''
    def __init__(self, index, goto):
        '''
         - index - passed to superclass.
        '''
        super().__init__(index)
        self.goto = goto

    def generate_body(self, label_map):
        print('''\
    return {{F_{}}};'''.format(
            label_map[self.goto].name,
        ))

# Generate state space of (path Ã— rejects) with flood fill.
# Decide what to do in each state.

states = [] # List of (path, rejects)
state_index = {} # {(path, rejects): int}
def enqueue(path, rejects):
    '''
     - path - tuple of event.
     - rejects - set of event.
    '''
    key = (path, tuple(sorted(rejects)))
    if key not in state_index:
        state_index[key] = len(state_index)
        states.append((path, rejects))
    return state_index[key]

assert enqueue((), set()) == 0 # Root state.

labels = [] # [Label]
while len(labels) < len(state_index):
    index = len(labels)
    path, rejects = states[index]
    for guess in language_index[path].guesses:
        if guess.name not in rejects:
            # We have a guess.
            labels.append(Guess(
                index,
                guess,
                enqueue(path + (guess.name,), set()),
                enqueue(path, rejects.union({guess.name})),
            ))
            break
    else:
        # There is no good guess.
        new_path = path[1:]
        if new_path:
            labels.append(Goto(
                index,
                enqueue(new_path, rejects),
            ))
        else:
            labels.append(None)

# Short-circuit all the Gotos.

def short_circuit(index):
    '''Follows Gotos to find a non-Goto Label.'''
    while isinstance(labels[index], Goto):
        index = labels[index].goto
    return labels[index]

label_map = [short_circuit(i) for i in range(len(labels))]

# Output actions code.
print('// Auto-generated by gen-actions - DO NOT EDIT.\n')

print('''
// Execute some instructions. On entry, exception is 0.
// If there is an exception, exit using RAISE(exception).
// Otherwise, leave exception set to 0. If we can cheaply guess the next action,
// return it; else return NULL.
typedef struct action {
    struct action (*call)(smite_state *S);
} action;
''')

print('''\
#define RAISE(code)                             \\
    do {                                        \\
        if (exception != 0 || (exception = (code)) != 0) \\
            return (action){NULL};              \\
    } while (0);

#define FETCH                                   \\
    do {                                        \\
        smite_BYTE z;                           \\
        RAISE(smite_load_byte(S, S->PC, &z));   \\
        S->I = z;                               \\
        S->PC++;                                \\
    } while (0);

static action ENTER(smite_state *S);

static action EXIT(smite_state *S);
''')

for label in labels:
    if isinstance(label, Guess):
        print('''\
static action {}(smite_state *S);
'''.format(label.name))

print('''\
static action ENTER(smite_state *S)
{
    FETCH
    return (action){F_0};
}

static action EXIT(smite_state *S)
{
    if (S->I >= O_UNDEFINED)
        exception = -256;
    return (action){NULL};
}
''')

for label in labels:
    if isinstance(label, Guess):
        print('''\
static action {}(smite_state *S)
{{'''.format(label.name))
        label.generate_body(label_map)
        print('''\
}
''')

print('''\
static void STEP(smite_state *S) {
    action next_action = ENTER(S);
    while (next_action.call != NULL) {
        assert(exception == 0);
        next_action = next_action.call(S);
    }
}''')
