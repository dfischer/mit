#!/usr/bin/env python3
# Generate code for instructions.
#
# (c) Reuben Thomas 1994-2019
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

import sys, pickle, re, textwrap

from smite_core.events import Event, ALL_EVENTS, EVENT_NAMES
from smite_core import vm_data, action_gen

# Load language.
if len(sys.argv) != 2:
    print("Usage: gen-actions LABELS-FILE", file=sys.stderr)
    sys.exit(1)
with open(sys.argv[1], "rb") as h:
    # [int, str, int?, int?]
    labels = pickle.load(h)

label_names = {
    label: 'A_{}'.format(label)
    for label in range(len(labels))
}
label_names[None] = 'A_ILLEGAL'

# Write the output file.
print('''\
// Auto-generated by gen-actions - DO NOT EDIT.
// The interface calls single_step() : integer and run() : integer.

#include "config.h"

#include <assert.h>

#include "smite.h"
#include "aux.h"
#include "opcodes.h"
#include "extra.h"

#define RAISE(code)                         \\
    do {                                    \\
        res = (code);                       \\
        S->STACK_DEPTH += static_args;      \\
        S->PC = initial_PC;                 \\
        goto RET;                           \\
    } while(0)

#define DIVZERO(x)                          \\
    if (x == 0)                             \\
        RAISE(8);

#define TRACE(type, opcode)                 \\
    if (S->trace_fp)                        \\
        fprintf(S->trace_fp, "%"PRI_UWORD" %"PRI_XWORD"\\n", (smite_UWORD)type, (smite_UWORD)opcode);
''')

print('''\
smite_WORD smite_single_step(smite_state *S) {
    smite_UWORD initial_PC = S->PC;
    int res = 128, error;
    smite_UWORD ITYPE;
    smite_WORD I;
    error = smite_decode_instruction(S, &S->PC, &ITYPE, &I);
    if (error != 0) {
        const smite_UWORD static_args = 0;
        RAISE(error);
    }

    switch (ITYPE) {
    case INSTRUCTION_NUMBER:
        {
            const smite_UWORD static_args = 0;
            error = smite_push_stack(S, I);
            if (error != 0)
                RAISE(error);
            break;
        }
    case INSTRUCTION_ACTION:''')

print(action_gen.dispatch(vm_data.Actions, 'O_', '''\
            // Undefined instruction; try extra instructions.
            {
                const smite_UWORD static_args = 0;
                error = smite_extra(S, I);
                if (error != 0)
                    RAISE(error);
            }'''))

print('''
        break;

    default: // Bug in smite_decode_instruction!
        return 1;
    }

    TRACE(ITYPE, I);

RET:
    return res;
}
''')

print('''\
#define FETCH                               \\
    do {                                    \\
        initial_PC = S->PC;                 \\
        error = smite_load_byte(S, S->PC++, &NEXT); \\
        if (error != 0)                     \\
            RAISE(error);                   \\
    } while (0)

smite_WORD smite_run(smite_state *S) {
    smite_UWORD initial_PC;
    int res = 128, error;''')

max_cached_depth = max(d for d, _, _, _ in labels)
if max_cached_depth > 0:
    print('''\
    smite_WORD {};'''.format(
        ', '.join(
            action_gen.stack_cache_var(pos, max_cached_depth) 
            for pos in reversed(range(max_cached_depth))
        )
    ))

print('''\
    do {
        smite_BYTE NEXT;
        {
            smite_UWORD static_args = 0;
            FETCH;
        }
        goto A_0;

        // Each A_XXX label has an expectation of what instruction sequence
        // probably comes next. If correct, there is a fast path for executing
        // that sequence, otherwise we fall back on a slow path with broader
        // expectations. Ultimately, we fall back to `A_ILLEGAL` which reports an
        // illegal instruction (the most unexpected case) or dispatches an extra
        // (implementation-specific) instruction.
        //
        // The calling convention at each A_XXX label is as follows:
        //
        //  - On entry, `res` is 128, `NEXT` is the first byte of the next
        //    instruction, `PC` has been incremented, and `STACK_DEPTH` has been
        //    decremented to pop the arguments.
        //  - When an error occurs, call `RAISE(code)`.
        //    It sets `res` to the return code; then it resets the stack depth
        //    to the depth on entry, and does "goto RET".
        //  - "goto RET" (but do not "return") at any time after completely
        //    executing at least one instruction, or never.
        //  - On exit, whether by `RAISE` or otherwise, all SMite
        //    registers must be set according to the SMite spec. In particular,
        //    there must be no side effects before a RAISE, except for the
        //    effects on STACK_DEPTH and PC described above.
''')

for label, (depth, name, if_correct, if_wrong) in enumerate(labels):
    event = EVENT_NAMES[name]
    print('''\
    {}:
        assert(res == 128);
        if ({}) {{
            // {}
{}
            FETCH;
            goto {}; // TODO: spill if necessary
        }}
        goto {}; // TODO: spill if necessary
'''.format(
            label_names[label],
            event.guess_code,
            event.name,
            textwrap.indent(action_gen.gen_case(event, depth), '            '),
            label_names[if_correct],
            label_names[if_wrong],
        )
    )

print('''\
    A_ILLEGAL:
        {
            // Pretend we fetched the instruction the formal way.
            S->PC--;
            const smite_UWORD static_args = 0;
            smite_UWORD itype;
            smite_WORD opcode;
            error = smite_decode_instruction(S, &S->PC, &itype, &opcode);
            if (error != 0)
                RAISE(error);

            assert(itype == INSTRUCTION_ACTION);
            assert(opcode >= O_UNDEFINED);
            // Undefined instruction; try extra instructions.
            error = smite_extra(S, opcode);
            if (error != 0)
                RAISE(error);
            goto RET;
        }

    RET:
        {}
    } while (res == 128);

    return res;
}''')

