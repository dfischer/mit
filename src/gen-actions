#!/usr/bin/env python3

import re
import textwrap

from vm_data import Actions


# Stack picture utilities
stack_specials = {'COUNT': 'count', 'ITEMS': True}

def stack_item_has_var(item):
    return stack_specials.get(item) != True

def stack_item_to_var(item):
    return stack_specials.get(item) or item

# Calculate variable list corresponding to stack picture
def stack2vars(stack):
    return list(map(stack_item_to_var,
                    filter(stack_item_has_var, stack)))

# Calculate (symbolic) depth of stack picture
def stack_depth(stack):
    depth = ['0']
    for item in stack:
        if stack_item_has_var(item):
            depth.append('1')
        elif stack_specials.get(item) == True:
            depth.append('(smite_UWORD)count')
    return '(' + ' + '.join(depth) + ')'

# Variable creator
def make_vars(stack):
    vars = stack2vars(stack)
    return 'smite_WORD {};'.format(", ".join(vars)) if len(vars) != 0 else ''

def check_static_args(args):
    return '''\
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wtype-limits"
if ((S->STACK_DEPTH < {nargs})) {{
    S->BAD_ADDRESS = {nargs};
    const smite_UWORD args = 0;
    RAISE(3);
}}
#pragma GCC diagnostic pop
'''.format(nargs=len(list(filter(stack_item_has_var, args))))

def check_dynamic_args_and_results(args, results):
    return '''\
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wtype-limits"
if ((S->STACK_SIZE - (S->STACK_DEPTH - {nargs}) < {nresults})) {{
    S->BAD_ADDRESS = {nresults} - {nargs};
    RAISE(2);
}}
#pragma GCC diagnostic pop
'''.format(nargs=stack_depth(args), nresults=stack_depth(results))

def load_args(args):
    code = []
    for i in reversed(range(len(args))):
        if stack_item_has_var(args[i]):
            code.append('UNCHECKED_LOAD_STACK({pos}, &{var});'.format(
                pos=len(args) - i - 1,
                var=stack_item_to_var(args[i]))
            )
    code.append('const smite_UWORD args = {};'.format(len(list(filter(stack_item_has_var, args)))))
    code.append('S->STACK_DEPTH -= args;')
    return '\n'.join(code)

def store_results(args, results):
    code = []
    code.append('S->STACK_DEPTH += {nresults} - ({nargs} - {nstatic_args});'.format(nargs=stack_depth(args), nresults=stack_depth(results), nstatic_args=len(list(filter(stack_item_has_var, args)))))
    for i in reversed(range(len(results))):
        if stack_item_has_var(results[i]):
            code.append('UNCHECKED_STORE_STACK({pos}, {var});'.format(
                pos=len(results) - i - 1,
                var=stack_item_to_var(results[i]))
            )
    return '\n'.join(code)

print('''\
// Auto-generated by gen-actions - DO NOT EDIT.
// The interface calls single_step() : integer and run() : integer.

#include "config.h"

#include "smite.h"
#include "aux.h"
#include "opcodes.h"
#include "extra.h"

#include <string.h>

#define RAISE(code)                         \\
    do {                                    \\
        int error = (code);                 \\
        S->STACK_DEPTH += args;             \\
        S->PC = initial_PC;                 \\
        return error;                       \\
    } while(0)

#define RAISE_NON_ZERO(code)                \\
    do {                                    \\
        int maybe_error = (code);           \\
        if ((maybe_error) != 0)             \\
            RAISE(maybe_error);             \\
    } while (0)

#define DIVZERO(x)                          \\
    if (x == 0)                             \\
        RAISE(8);

#define TRACE(type, opcode)                 \\
    if (S->trace_fp)                        \\
        fprintf(S->trace_fp, "%"PRI_UWORD" %"PRI_XWORD"\\n", type, (smite_UWORD)opcode);

smite_WORD smite_single_step(smite_state *S) {
    smite_UWORD initial_PC = S->PC;
    smite_UWORD ITYPE;
    smite_WORD I;
    int res = smite_decode_instruction(S, &S->PC, &ITYPE, &I);
    if (res != 0)
        return res;

    switch (ITYPE) {
    case INSTRUCTION_NUMBER:
        {
            const smite_UWORD args = 0;
            RAISE_NON_ZERO(smite_push_stack(S, I));
            break;
        }
    case INSTRUCTION_ACTION:
        switch (I) {''')
for (instruction, action) in Actions.__members__.items():
    # Concatenate the pieces.
    code = '\n'.join([
        make_vars(action.value.args),
        make_vars(action.value.results),
        check_static_args(action.value.args),
        load_args(action.value.args),
        check_dynamic_args_and_results(action.value.args, action.value.results),
        textwrap.dedent(action.value.code.rstrip()),
        store_results(action.value.args, action.value.results),
    ])
    # Remove newlines resulting from empty strings in the above.
    code = re.sub('\n+', '\n', code, flags=re.MULTILINE).strip('\n')
    print('''\
        case O_{instruction}:
            {{
{code}
            }}
            break;'''.format(
                instruction=instruction,
                code=textwrap.indent(code, '                '),
            ))
print('''\
        default: /* Undefined instruction; try extra instructions */
            {
                const smite_UWORD args = 0;
                RAISE_NON_ZERO(smite_extra(S, I));
                break;
            }
        }
        break;
    default: /* Error during instruction fetch */
        return ITYPE;
    }

    TRACE(ITYPE, I);

    return 128;
}


smite_WORD smite_run(smite_state *S)
{
    smite_WORD ret;
    while ((ret = smite_single_step(S)) == 128)
        ;
    return ret;
}''')
