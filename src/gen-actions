#!/usr/bin/env python3

import re
import textwrap

from vm_data import Actions


# Variable creator
def make_vars(vars):
    return 'smite_WORD {};'.format(", ".join(vars)) if len(vars) != 0 else ''

def check_stack_pointer(nargs, nresults):
    return '''\
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wtype-limits"
if ((S->STACK_DEPTH < {nargs})) {{
    S->BAD_ADDRESS = {nargs};
    const smite_UWORD args = 0;
    RAISE(3);
}}
if ((S->STACK_SIZE - (S->STACK_DEPTH - {nargs}) < {nresults})) {{
    S->BAD_ADDRESS = {nresults} - {nargs};
    const smite_UWORD args = 0;
    RAISE(2);
}}
#pragma GCC diagnostic pop
'''.format(nargs=nargs, nresults=nresults)

def load_args(args):
    code = []
    for i in range(len(args)):
        code.append('UNCHECKED_LOAD_STACK({pos}, &{var});'.format(
            pos=len(args) - i - 1,
            var=args[i])
        )
    code.append('const smite_UWORD args = {};'.format(len(args)))
    code.append('S->STACK_DEPTH -= args;')
    return '\n'.join(code)

def store_results(results):
    code = []
    code.append('S->STACK_DEPTH += {};'.format(len(results)))
    for i in range(len(results)):
        code.append('UNCHECKED_STORE_STACK({pos}, {var});'.format(
            pos=len(results) - i - 1,
            var=results[i])
        )
    return '\n'.join(code)

print('''\
// Auto-generated by gen-actions - DO NOT EDIT.
// The interface calls single_step() : integer and run() : integer.

#include "config.h"

#include "smite.h"
#include "aux.h"
#include "opcodes.h"
#include "extra.h"

#include <string.h>

#define RAISE(code)                         \\
    do {                                    \\
        int error = (code);                 \\
        S->STACK_DEPTH += args;             \\
        S->PC = initial_PC;                 \\
        return error;                       \\
    } while(0)

#define RAISE_NON_ZERO(code)                \\
    do {                                    \\
        int maybe_error = (code);           \\
        if ((maybe_error) != 0)             \\
            RAISE(maybe_error);             \\
    } while (0)

#define DIVZERO(x)                          \\
    if (x == 0)                             \\
        RAISE(8);

#define TRACE(type, opcode)                 \\
    if (S->trace_fp)                        \\
        fprintf(S->trace_fp, "%"PRI_UWORD" %"PRI_XWORD"\\n", type, (smite_UWORD)opcode);

smite_WORD smite_single_step(smite_state *S) {
    smite_UWORD initial_PC = S->PC;
    smite_UWORD ITYPE;
    smite_WORD I;
    int res = smite_decode_instruction(S, &S->PC, &ITYPE, &I);
    if (res != 0)
        return res;

    switch (ITYPE) {
    case INSTRUCTION_NUMBER:
        {
            const smite_UWORD args = 0;
            RAISE_NON_ZERO(smite_push_stack(S, I));
            break;
        }
    case INSTRUCTION_ACTION:
        switch (I) {''')
for (instruction, action) in Actions.__members__.items():
    # Concatenate the pieces.
    code = '\n'.join([
        check_stack_pointer(
            len(action.value.args),
            len(action.value.results)
        ),
        make_vars(action.value.args),
        make_vars(action.value.results),
        load_args(action.value.args),
        textwrap.dedent(action.value.code.rstrip()),
        store_results(action.value.results),
    ])
    # Remove newlines resulting from empty strings in the above.
    code = re.sub('\n+', '\n', code, flags=re.MULTILINE).strip('\n')
    print('''\
        case O_{instruction}:
            {{
{code}
            }}
            break;'''.format(
                instruction=instruction,
                args=len(action.value.args),
                results=len(action.value.results),
                code=textwrap.indent(code, '                '),
            ))
print('''\
        default: /* Undefined instruction; try extra instructions */
            {
                const smite_UWORD args = 0;
                RAISE_NON_ZERO(smite_extra(S, I));
                break;
            }
        }
        break;
    default: /* Error during instruction fetch */
        return ITYPE;
    }

    TRACE(ITYPE, I);

    return 128;
}


smite_WORD smite_run(smite_state *S)
{
    smite_WORD ret;
    while ((ret = smite_single_step(S)) == 128)
        ;
    return ret;
}''')
