#!/usr/bin/env python3

import sys, pickle, re, textwrap

from events import Event, ALL_EVENTS, EVENT_NAMES
import vm_data

# Variable creator
def make_vars(vars):
    return 'smite_WORD {};'.format(", ".join(vars)) if len(vars) != 0 else ''

def check_stack_pointer(nargs, nresults):
    return '''\
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wtype-limits"
if ((S->STACK_DEPTH < {nargs})) {{
    S->BAD_ADDRESS = {nargs};
    const smite_UWORD args = 0;
    RAISE(-3);
}}
if ((S->STACK_SIZE - (S->STACK_DEPTH - {nargs}) < {nresults})) {{
    S->BAD_ADDRESS = {nresults} - {nargs};
    const smite_UWORD args = 0;
    RAISE(-2);
}}
#pragma GCC diagnostic pop
'''.format(nargs=nargs, nresults=nresults)

def load_args(args):
    code = []
    for i in range(len(args)):
        code.append('UNCHECKED_LOAD_STACK({pos}, &{var});'.format(
            pos=len(args) - i - 1,
            var=args[i])
        )
    code.append('const smite_UWORD args = {};'.format(len(args)))
    code.append('S->STACK_DEPTH -= args;')
    return '\n'.join(code)

def store_results(results):
    code = []
    code.append('S->STACK_DEPTH += {};'.format(len(results)))
    for i in range(len(results)):
        code.append('UNCHECKED_STORE_STACK({pos}, {var});'.format(
            pos=len(results) - i - 1,
            var=results[i])
        )
    return '\n'.join(code)

# Load language.
if len(sys.argv) != 2:
    print("Usage: gen-actions LABELS-FILE", file=sys.stderr)
    sys.exit(1)
with open(sys.argv[1], "rb") as h:
    # [str, int?, int?]
    labels = pickle.load(h)

label_names = {
    label: 'A_{}'.format(label)
    for label in range(len(labels))
}
label_names[None] = 'A_ILLEGAL'

# Output actions code.
print('''\
// Auto-generated by gen-actions - DO NOT EDIT.

#include <assert.h>
#include <string.h>

#include "aux.h"
#include "opcodes.h"
#include "extra.h"
#include "actions-common.h"

#define RAISE(code)                         \\
    do {                                    \\
        error = (code);                     \\
        if (error != 0) {                   \\
            S->STACK_DEPTH += args;         \\
            S->BAD_PC = initial_PC;         \\
            goto RET;                       \\
        }                                   \\
    } while(0)

#define FETCH                               \\
    do {                                    \\
        initial_PC = S->PC;                 \\
        RAISE(smite_load_byte(S, S->PC++, &NEXT)); \\
    } while (0)
''')

print('''\
static int do_actions(smite_state *S) {
    smite_UWORD initial_PC;
    int error = 0; // In a local so the compiler knows it's zero.
    smite_WORD ITYPE; // In a local so the compiler knows it's dead.
    smite_BYTE NEXT;
    {
        smite_UWORD args = 0;
        FETCH;
    }
    goto A_0;

    // Each A_XXX label has an expectation of what instruction sequence
    // probably comes next. If correct, there is a fast path for executing
    // that sequence, otherwise we fall back on a slow path with broader
    // expectations. Ultimately, we fall back to `A_ILLEGAL` which reports an
    // illegal instruction (the most unexpected case) or dispatches an extra
    // (implementation-specific) instruction.
    //
    // The calling convention at each A_XXX label is as follows:
    //
    //  - On entry, `error` is zero, `NEXT` is the first byte of the next
    //    instruction, `PC` has been incremented, `STACK_DEPTH` has been
    //    decremented to pop the arguments, and `ITYPE` and `I` are undefined.
    //  - Wrap `RAISE(code)` around any `code` that might error.
    //    It sets `error` to the return code; then, if the return code is
    //    non-zero, it resets the stack depth to the depth on entry, and
    //    does "goto RET".
    //  - "goto RET" (but do not "return") at any time after completely
    //    executing at least one instruction, or never.
    //  - On exit, whether by `RAISE` or otherwise, `ITYPE` and all SMite
    //    registers must be set according to the SMite spec. In particular,
    //    there must be no side effects before a RAISE, except for the
    //    effects on STACK_DEPTH and PC described above.
''')

for label, (name, if_correct, if_wrong) in enumerate(labels):
    event = EVENT_NAMES[name]
    # Concatenate the pieces.
    code = '\n'.join([
        'ITYPE = {};'.format(event.itype),
        check_stack_pointer(len(event.args), len(event.results)),
        make_vars(event.args),
        make_vars(event.results),
        load_args(event.args),
        textwrap.dedent(event.exec_code.rstrip()),
        store_results(event.results),
    ])
    # Remove newlines resulting from empty strings in the above.
    code = re.sub('\n+', '\n', code, flags=re.MULTILINE).strip('\n')
    code = textwrap.indent(code, '        ')
    print('''\
{}:
    error = 0;
    if ({}) {{
        // {}
{}
#ifdef SINGLE_STEPPING
        goto RET;
#endif
        FETCH;
        goto {};
    }}
    goto {};
'''.format(
            label_names[label],
            event.guess_code,
            event.name,
            textwrap.indent(code, '        '),
            label_names[if_correct],
            label_names[if_wrong],
        )
    )

print('''\
A_ILLEGAL:
    {
        // Pretend we fetched the instruction the formal way.
        S->PC--;
        ITYPE = smite_decode_instruction(S, &S->PC, &S->I);
        assert(ITYPE == INSTRUCTION_ACTION);
        assert(S->I >= O_UNDEFINED);
        smite_UWORD args = 0;
        RAISE(smite_extra(S));
        goto RET;
    }

RET:
    S->ITYPE = ITYPE;
    return error;
}''')
