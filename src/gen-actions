#!/usr/bin/env python3

import sys, pickle

from events import Event, ALL_EVENTS, EVENT_NAMES
import vm_data

# Load language.
if len(sys.argv) != 2:
    print("Usage: gen-actions LABELS-FILE", file=sys.stderr)
    sys.exit(1)
with open(sys.argv[1], "rb") as h:
    # [str, int?, int?]
    labels = pickle.load(h)

label_names = {
    label: 'A_{}'.format(label)
    for label in range(len(labels))
}
label_names[None] = 'A_ILLEGAL;'

# Output actions code.
print('// Auto-generated by gen-actions - DO NOT EDIT.\n')

print('''\
#define RAISE(code)                             \\
    do {                                        \\
        if (exception != 0 || (exception = (code)) != 0) \\
            goto RET;                           \\
    } while (0);

#define FETCH                                   \\
    do {                                        \\
        RAISE(smite_load_byte(S, S->PC++, &NEXT)); \\
    } while (0);
''')

print('''\
static int STEP(smite_state *S) {
    int exception = 0; // In a local so the compiler knows it's zero.
    smite_WORD ITYPE; // In a local so the compiler knows it's dead.
    smite_BYTE NEXT;
    FETCH
    goto A_0;

    // Each A_XXX label has an expectation of what instruction sequence
    // probably comes next. If correct, there is a fast path for executing
    // that sequence, otherwise we fall back on a slow path with broader
    // expectations. Ultimately, we fall back to `A_ILLEGAL` which reports an
    // illegal instruction (the most unexpected case).
    //
    // The calling convention at each A_XXX label is as follows:
    //  - On entry, `exception` is 0, `NEXT` is the first byte of the next
    //    instruction, `S->PC` has been incremented, and `ITYPE` and `S->I`
    //    are undefined.
    //  - Wrap `RAISE(code)` around any `code` that might throw an exception.
    //    If exception is zero, it evaluates `code` and sets `exception` to
    //    the result. Then, if `exception` is non-zero, it does "goto RET".
    //  - "goto RET" (but do not "return") at any time after executing at
    //    least one instruction, or never.
    //  - On exit, whether by `RAISE` or otherwise, `ITYPE` and all SMite
    //    registers must be set according to the SMite spec.
''')

for label, (name, if_correct, if_wrong) in enumerate(labels):
    event = EVENT_NAMES[name]
    print('''\
{}:
    exception = 0;
    if ({}) {{
        // {}
{}
//        return; // Implement single-stepping then delete this.
        FETCH
        goto {};
    }}
    goto {};
'''.format(
            label_names[label],
            event.guess_code,
            event.name,
            event.exec_code,
            label_names[if_correct],
            label_names[if_wrong],
        )
    )

print('''\
A_ILLEGAL:
    {
        // Pretend we fetched the instruction the formal way.
        S->PC--;
        ITYPE = smite_decode_instruction(S, &S->PC, &S->I);
        assert(ITYPE == INSTRUCTION_ACTION);
        assert(S->I >= O_UNDEFINED);
        RAISE(-256);
    }

RET:
    S->ITYPE = ITYPE;
    return exception;
}''')
