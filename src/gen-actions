#!/usr/bin/env python3

import re
import textwrap

from vm_data import Actions


# Variable creator
def make_vars(vars):
    return 'smite_WORD {};'.format(", ".join(vars)) if len(vars) != 0 else ''

def check_stack_pointer(nargs, nresults):
    return '''\
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wtype-limits"
if ((S->STACK_DEPTH < {nargs})) {{
    S->BAD_ADDRESS = {nargs};
    const smite_UWORD args = 0;
    RAISE(3);
}}
if ((S->STACK_SIZE - (S->STACK_DEPTH - {nargs}) < {nresults})) {{
    S->BAD_ADDRESS = {nresults} - {nargs};
    const smite_UWORD args = 0;
    RAISE(2);
}}
#pragma GCC diagnostic pop
'''.format(nargs=nargs, nresults=nresults)

def load_args(args):
    code = []
    for i in range(len(args)):
        code.append('UNCHECKED_LOAD_STACK({pos}, &{var});'.format(
            pos=len(args) - i - 1,
            var=args[i])
        )
    code.append('const smite_UWORD args = {};'.format(len(args)))
    code.append('S->STACK_DEPTH -= args;')
    return '\n'.join(code)

def store_results(results):
    code = []
    code.append('S->STACK_DEPTH += {};'.format(len(results)))
    for i in range(len(results)):
        code.append('UNCHECKED_STORE_STACK({pos}, {var});'.format(
            pos=len(results) - i - 1,
            var=results[i])
        )
    return '\n'.join(code)

print('''\
// Auto-generated by gen-actions - DO NOT EDIT.

#include "aux.h"
#include "opcodes.h"
#include "extra.h"

#include <string.h>

#define RAISE(code)                         \\
    do {                                    \\
        int error = (code);                 \\
        S->STACK_DEPTH += args;             \\
        S->PC = initial_PC;                 \\
        return error;                       \\
    } while(0)

#define RAISE_NON_ZERO(code)                \\
    do {                                    \\
        int maybe_error = (code);           \\
        if ((maybe_error) != 0)             \\
            RAISE(maybe_error);             \\
    } while (0)

#define DIVZERO(x)                          \\
    if (x == 0)                             \\
        RAISE(8);

smite_WORD smite_single_step(smite_state *S) {
    smite_UWORD initial_PC = S->PC;
    int res = smite_decode_instruction(S, &S->PC, &S->ITYPE, &S->I);
    if (res != 0)
        return res;

    switch (S->ITYPE) {
    case INSTRUCTION_NUMBER:
        {
            const smite_UWORD args = 0;
            RAISE_NON_ZERO(smite_push_stack(S, S->I));
            break;
        }
    case INSTRUCTION_ACTION:
        switch (S->I) {''')
for (instruction, action) in Actions.__members__.items():
    # Concatenate the pieces.
    code = '\n'.join([
        check_stack_pointer(
            len(action.value.args),
            len(action.value.results)
        ),
        make_vars(action.value.args),
        make_vars(action.value.results),
        load_args(action.value.args),
        textwrap.dedent(action.value.code.rstrip()),
        store_results(action.value.results),
    ])
    # Remove newlines resulting from empty strings in the above.
    code = re.sub('\n+', '\n', code, flags=re.MULTILINE).strip('\n')
    print('''\
        case O_{instruction}:
            {{
{code}
            }}
            break;'''.format(
                instruction=instruction,
                args=len(action.value.args),
                results=len(action.value.results),
                code=textwrap.indent(code, '                '),
            ))
print('''\
        default: /* Undefined instruction; try extra instructions */
            {
                const smite_UWORD args = 0;
                RAISE_NON_ZERO(smite_extra(S));
                break;
            }
        }
        break;
    default: /* Error during instruction fetch */
        return S->ITYPE;
    }

    trace(S->ITYPE, S->I);

    return 128;
}''')
