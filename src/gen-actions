#!/usr/bin/env python3

import re
import textwrap

from vm_data import Actions


# Variable creator
def make_vars(vars):
    return 'smite_WORD {};'.format(", ".join(vars)) if len(vars) != 0 else ''

def check_stack_pointer(nargs, nresults):
    return '''\
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wtype-limits"
if ((S->STACK_DEPTH < {nargs})) {{
    S->BAD_ADDRESS = {nargs};
    const smite_UWORD args = 0;
    RAISE(-3);
}}
if ((S->STACK_SIZE - (S->STACK_DEPTH - {nargs}) < {nresults})) {{
    S->BAD_ADDRESS = {nresults} - {nargs};
    const smite_UWORD args = 0;
    RAISE(-2);
}}
#pragma GCC diagnostic pop
'''.format(nargs=nargs, nresults=nresults)

def load_args(args):
    code = []
    for i in range(len(args)):
        code.append('UNCHECKED_LOAD_STACK({pos}, &{var});'.format(
            pos=len(args) - i - 1,
            var=args[i])
        )
    code.append('const smite_UWORD args = {};'.format(len(args)))
    code.append('S->STACK_DEPTH -= args;')
    return '\n'.join(code)

def store_results(results):
    code = []
    code.append('S->STACK_DEPTH += {};'.format(len(results)))
    for i in range(len(results)):
        code.append('UNCHECKED_STORE_STACK({pos}, {var});'.format(
            pos=len(results) - i - 1,
            var=results[i])
        )
    return '\n'.join(code)

print('''\
// Auto-generated by gen-actions - DO NOT EDIT.

#include <string.h>

#define RAISE(code)                         \\
    do {                                    \\
        int error = (code);                 \\
        if (error != 0) {                   \\
            S->STACK_DEPTH += args;         \\
            S->BAD_PC = initial_PC;         \\
            return error;                   \\
        }                                   \\
    } while(0)

static int STEP(smite_state *S) {
    smite_UWORD initial_PC = S->PC;
    S->ITYPE = smite_decode_instruction(S, &S->PC, &S->I);

    switch (S->ITYPE) {
    case INSTRUCTION_NUMBER:
        {
            const smite_UWORD args = 0;
            RAISE(smite_push_stack(S, S->I));
            break;
        }
    case INSTRUCTION_ACTION:
        switch (S->I) {''')
for (instruction, action) in Actions.__members__.items():
    # Concatenate the pieces.
    code = '\n'.join([
        check_stack_pointer(
            len(action.value.args),
            len(action.value.results)
        ),
        make_vars(action.value.args),
        make_vars(action.value.results),
        load_args(action.value.args),
        textwrap.dedent(action.value.code.rstrip()),
        store_results(action.value.results),
    ])
    # Remove newlines resulting from empty strings in the above.
    code = re.sub('\n+', '\n', code, flags=re.MULTILINE).strip('\n')
    print('''\
        case O_{instruction}:
            {{
{code}
            }}
            break;'''.format(
                instruction=instruction,
                args=len(action.value.args),
                results=len(action.value.results),
                code=textwrap.indent(code, '                '),
            ))
print('''\
        default: /* Undefined instruction; try extra instructions */
            {
                const smite_UWORD args = 0;
                RAISE(smite_extra(S));
                break;
            }
        }
        break;
    default: /* Error during instruction fetch */
        return S->ITYPE;
    }

    trace(S->ITYPE, S->I);

    return 0;
}''')
