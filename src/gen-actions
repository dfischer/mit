#!/usr/bin/env python3

import sys, pickle

from vm_data import Actions


# Load language.
if len(sys.argv) != 2:
    print("Usage: gen-actions LANGUAGE-FILE")
    sys.exit(1)
with open(sys.argv[1], "rb") as h:
    language = pickle.load(h)

# TODO: Assert that language is prefix- and suffix-closed.
# TODO: Assert that the singletons == the list of Actions + non-Action instruction types.

# Output actions code.
print('// Auto-generated by gen-actions - DO NOT EDIT.\n')

print('''
// Execute some instructions. On entry, exception is 0.
// If there is an exception, exit using RAISE(exception).
// Otherwise, leave exception set to 0. If we can cheaply guess the next action,
// return it; else return NULL.
typedef struct action {
    struct action (*call)(smite_state *S);
} action;
''')

print('''\
#define RAISE(code)                             \\
    do {                                        \\
        exception = (code);                     \\
        return (action){NULL};                  \\
    } while (0);
''')

# TODO. Generate state space of (window Ã— reject_set) with flood fill.
work_queue = []
work_done = {}
def enqueue(trace, reject_set):
    state = (trace, tuple(sorted(reject_set)))
    if state not in work_done:
        work_queue.append(state)
        work_done[state] = len(work_done)
    return work_done[state]

ALL_EVENTS = [trace[0] for trace in language.keys() if len(trace) == 1]
for event in ALL_EVENTS:
    enqueue((event,), set())
    
while work_queue:
    (trace, rejects) = work_queue.pop()
    reject_set = set(rejects)
    name = work_done[(trace, rejects)]
    guess = None
    guess_count = 0.
    for event in ALL_EVENTS:
        if event not in reject_set:
            new_trace = trace + (event,)
            count = language.get(new_trace, None)
            if count and count > guess_count:
                guess = event
                guess_count = count
            
    print('''\
static action F_{}(smite_state *S)
{{
    assert(exception == 0);'''.format(name))

    if guess:
        print('''\
    if (S->I == guess_I) {{
        // TODO: Execute guess_I
        return F_{};
    }} else
        return F_{};'''.format(
            enqueue(trace + (guess,), set()),          # Correct state
            enqueue(trace, reject_set.union({guess})), # Wrong state
        ))
    else:
        new_trace = trace[1:]
        if new_trace:
            print('''\
    return F_{};'''.format(enqueue(new_trace, reject_set)))
        else:
            print('''\
    return (action){{NULL}};''')
    print('''\
}}
''')

print('action instruction_table[] = {')
for name in Actions.__members__.keys():
    print("    {{F_{}}},".format(name))
print('};\n')

print('''\
#define STEP(S)                                 \\
    action next_action = {NULL};                \\
    switch (S->ITYPE) {                         \\
    case INSTRUCTION_NUMBER:                    \\
        PUSH(S->I);                             \\
        break;                                  \\
    case INSTRUCTION_ACTION:                    \\
        if (S->I < O_UNDEFINED)                 \\
            next_action = instruction_table[S->I]; \\
        else { /* Undefined instruction */      \\
            exception = -256;                   \\
            next_action = (action){NULL};       \\
        }                                       \\
        break;                                  \\
    default: /* Exception during instruction fetch */ \\
        exception = S->ITYPE;                   \\
        break;                                  \\
    }                                           \\
                                                \\
    while (next_action.call != NULL) {          \\
        assert(exception == 0);                 \\
        next_action = next_action.call(S);      \\
    }                                           \\
''')
