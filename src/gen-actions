#!/usr/bin/env python3

from vm_data import Actions

print('// Auto-generated by gen-actions - DO NOT EDIT.\n')

print('''
// Execute some instructions. On entry, exception is 0.
// If there is an exception, exit using RAISE(exception).
// Otherwise, leave exception set to 0. If we can cheaply guess the next action,
// return it; else return NULL.
typedef struct action {
    struct action (*call)(smite_state *S);
} action;
''')

print('''\
#define RAISE(code)                             \\
    do {                                        \\
        S->exception = (code);                  \\
        return (action){NULL};                  \\
    } while (0);
''')

for (instruction, action) in Actions.__members__.items():
    print('''\
static action F_{}(smite_state *S)
{{
    assert(S->exception == 0);
    do {{
{}
    }} while (0);
    return (action){{NULL}};
}}
'''.format(instruction, action.value.code[:-1].replace('\n', '\\\n     ')[1:-9]))

print('action instruction_table[] = {')
for name in Actions.__members__.keys():
    print("    {{F_{}}},".format(name))
print('};\n')

print('''\
static void STEP(smite_state *S) {{
    S->ITYPE = smite_decode_instruction(S, &S->PC, &S->I);
    trace(S->ITYPE, S->I);
    action next_action = {NULL};
    switch (S->ITYPE) {{
    case INSTRUCTION_NUMBER:
        PUSH(S->I);
        break;
    case INSTRUCTION_ACTION:
        if (S->I < O_UNDEFINED)
            next_action = instruction_table[S->I];
        else {{ // Undefined instruction
            S->exception = -256;
            next_action = (action){NULL};
        }}
        break;
    default: // Exception during instruction fetch
        S->exception = S->ITYPE;
        break;
    }}

    while (next_action.call != NULL) {{
        assert(S->exception == 0);
        next_action = next_action.call(S);
    }}
}}
''')
