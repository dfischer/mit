#!/usr/bin/env python3

import sys, pickle

from events import Event, ALL_EVENTS, EVENT_NAMES
import vm_data

# Load language.
if len(sys.argv) != 2:
    print("Usage: gen-actions LABELS-FILE", file=sys.stderr)
    sys.exit(1)
with open(sys.argv[1], "rb") as h:
    # [str, int?, int?]
    labels = pickle.load(h)

label_names = ['F_{}'.format(label) for label in range(len(labels))]

label_gotos = {
    label: 'return (action){{{}}};'.format(label_names[label])
    for label in range(len(labels))
 }
label_gotos[None] = 'return EXIT(S);'

# Output actions code.
print('// Auto-generated by gen-actions - DO NOT EDIT.\n')

print('''
// Execute some instructions. On entry, exception is 0.
// If there is an exception, exit using RAISE(exception).
// Otherwise, leave exception set to 0. If we can cheaply guess the next action,
// return it; else return NULL.
typedef struct action {
    struct action (*call)(smite_state *S);
} action;
''')

print('''\
#define RAISE(code)                             \\
    do {                                        \\
        if (exception != 0 || (exception = (code)) != 0) \\
            return (action){NULL};              \\
    } while (0);

#define FETCH                                   \\
    do {                                        \\
        smite_BYTE z;                           \\
        RAISE(smite_load_byte(S, S->PC++, &z)); \\
        S->I = z;                               \\
    } while (0);

static action ENTER(smite_state *S);

static action EXIT(smite_state *S);
''')

for name in label_names:
    print('''\
static action {}(smite_state *S);
'''.format(name))

print('''\
static action ENTER(smite_state *S)
{
    FETCH
    return (action){F_0};
}

static action EXIT(smite_state *S)
{
    // Pretend we fetched the instruction the formal way.
    S->PC--;
    S->ITYPE = smite_decode_instruction(S, &S->PC, &S->I);
    assert(S->ITYPE == INSTRUCTION_ACTION);
    assert(S->I >= O_UNDEFINED);
    RAISE(-256);
}
''')

for label, (name, if_correct, if_wrong) in enumerate(labels):
    event = EVENT_NAMES[name]
    print('''\
static action {}(smite_state *S) {{
    if ({}) {{
        // {}
{}
//        return (action){{NULL}}; // Implement single-stepping then delete this.
        FETCH
        {}
    }}
    {}
}}'''.format(
            label_names[label],
            event.guess_code,
            event.name,
            event.exec_code,
            label_gotos[if_correct],
            label_gotos[if_wrong],
        )
    )


print('''\
static void STEP(smite_state *S) {
    action next_action = ENTER(S);
    while (next_action.call != NULL) {
        assert(exception == 0);
        next_action = next_action.call(S);
    }
}''')
