#!/usr/bin/env python3

from vm_data import Actions

print('// Auto-generated by gen-actions - DO NOT EDIT.\n')

print('''
// Execute some instructions. On entry, exception is 0.
// If there is an exception, exit using RAISE(exception).
// Otherwise, leave exception set to 0. If we can cheaply guess the next action,
// return it; else return NULL.
typedef struct action {
    struct action (*call)(smite_state *S);
} action;
''')

print('''\
#define RAISE(code)                             \\
    do {                                        \\
        if (S->exception != 0 || (S->exception = (code)) != 0) \\
            return (action){NULL};              \\
    } while (0);
''')

for (instruction, action) in Actions.__members__.items():
    print('''\
static action F_{}(smite_state *S)
{{
    assert(S->exception == 0);
    do {{
{}
    }} while (0);
    return (action){{NULL}};
}}
'''.format(instruction, action.value.code))

print('action instruction_table[] = {')
for name in Actions.__members__.keys():
    print("    {{F_{}}},".format(name))
print('};\n')

print('''\
static void STEP(smite_state *S) {
    S->ITYPE = smite_decode_instruction(S, &S->PC, &S->I);
    trace(S->ITYPE, S->I);

    switch (S->ITYPE) {
    case INSTRUCTION_NUMBER:
        PUSH(S->I);
        return;
    case INSTRUCTION_ACTION:
        if (S->I >= O_UNDEFINED) {
            S->exception = -256;
            return;
        }
        action next_action = instruction_table[S->I];
        while (next_action.call != NULL) {
            assert(S->exception == 0);
            next_action = next_action.call(S);
        }
        return;
    default: /* Exception during instruction fetch */
        S->exception = S->ITYPE;
        return;
    }
}''')
