#!/usr/bin/env python3

import sys, pickle

from events import Event, ALL_EVENTS, EVENT_NAMES
import vm_data

# Load language.
if len(sys.argv) != 2:
    print("Usage: gen-actions LABELS-FILE", file=sys.stderr)
    sys.exit(1)
with open(sys.argv[1], "rb") as h:
    # [str, int?, int?]
    labels = pickle.load(h)

label_names = {
    label: 'A_{}'.format(label)
    for label in range(len(labels))
}
label_names[None] = 'A_ILLEGAL;'

# Output actions code.
print('// Auto-generated by gen-actions - DO NOT EDIT.\n')

print('''\
#define RAISE(code)                             \\
    do {                                        \\
        if (exception != 0 || (exception = (code)) != 0) \\
            return exception;                             \\
    } while (0);

#define FETCH                                   \\
    do {                                        \\
        RAISE(smite_load_byte(S, S->PC++, &NEXT)); \\
    } while (0);
''')

print('''\
static int STEP(smite_state *S) {
    int exception = 0;
    smite_BYTE NEXT;
    FETCH
    goto A_0;

    // Each A_XXX label has an expectation of what instruction sequence
    // probably comes next. If correct, there is a fast path for executing
    // that sequence, otherwise we fall back on a slow path with broader
    // expectations. Ultimately, we fall back to `A_ILLEGAL` which reports an
    // illegal instruction (the most unexpected case).
    //
    // The convention at each A_XXX label is as follows:
    //  - On entry, exception is 0, NEXT is the first byte of the next
    //    instruction, S->PC has been incremented, and S->ITYPE and S->I are
    //    undefined.
    //  - Wrap `RAISE(code)` around any `code` that might throw an exception.
    //    If exception is zero, it evaluates `code` and sets `exception` to
    //    the result. Then, if `exception` is non-zero, it returns.
    //  - Return at any time after executing at least one instruction, or
    //    never.
    //  - On exit, whether by RAISE or otherwise, S->ITYPE, S->I, S->PC and
    //    all other registers must be set according to the SMite spec.

''')

for label, (name, if_correct, if_wrong) in enumerate(labels):
    event = EVENT_NAMES[name]
    print('''\
{}:
    exception = 0;
    if ({}) {{
        // {}
{}
//        return; // Implement single-stepping then delete this.
        FETCH
        goto {};
    }}
    goto {};
'''.format(
            label_names[label],
            event.guess_code,
            event.name,
            event.exec_code,
            label_names[if_correct],
            label_names[if_wrong],
        )
    )

print('''\
A_ILLEGAL:
    // Pretend we fetched the instruction the formal way.
    S->PC--;
    S->ITYPE = smite_decode_instruction(S, &S->PC, &S->I);
    assert(S->ITYPE == INSTRUCTION_ACTION);
    assert(S->I >= O_UNDEFINED);
    RAISE(-256);
}''')
