#!/usr/bin/env python3
# Generate code for instructions.
#
# (c) Reuben Thomas 1994-2019
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

import sys, pickle, textwrap

from smite_core.events import Event, ALL_EVENTS, EVENT_NAMES
from smite_core import vm_data, action_gen

# Load language.
if len(sys.argv) != 2:
    print("Usage: gen-actions LABELS-FILE", file=sys.stderr)
    sys.exit(1)
with open(sys.argv[1], "rb") as h:
    # [int, str, int?, int?]
    labels = pickle.load(h)

label_names = {
    label: 'A_{}'.format(label)
    for label, _ in enumerate(labels)
}
label_names[None] = 'A_ILLEGAL'

label_depths = {
    label: depth
    for label, (depth, _, _, _) in enumerate(labels)
}
label_depths[None] = 0

# Write the output file.
print('''\
// Auto-generated by gen-actions - DO NOT EDIT.
// The interface calls single_step() : integer and run() : integer.

#include "config.h"

#include <assert.h>

#include "smite.h"
#include "aux.h"
#include "opcodes.h"
#include "extra.h"

#define RAISE(code)                         \\
    do {                                    \\
        res = (code);                       \\
        S->STACK_DEPTH = initial_STACK_DEPTH; \\
        S->PC = initial_PC;                 \\
        goto RET;                           \\
    } while(0)

#define DIVZERO(x)                          \\
    if (x == 0)                             \\
        RAISE(8);

#define TRACE(type, opcode)                 \\
    if (S->trace_fp)                        \\
        fprintf(S->trace_fp, "%"PRI_UWORD" %"PRI_XWORD"\\n", (smite_UWORD)type, (smite_UWORD)opcode);
''')

print('''\
smite_WORD smite_single_step(smite_state *S) {
    smite_UWORD initial_PC = S->PC;
    smite_UWORD initial_STACK_DEPTH = S->STACK_DEPTH;
    smite_UWORD cached_depth = 0; // Always zero.
    int res = 128, error;
    smite_UWORD ITYPE;
    smite_WORD I;
    error = smite_decode_instruction(S, &S->PC, &ITYPE, &I);
    if (error != 0) {
        RAISE(error);
    }

    switch (ITYPE) {
    case INSTRUCTION_NUMBER:
        {
            error = smite_push_stack(S, I);
            if (error != 0)
                RAISE(error);
            break;
        }
    case INSTRUCTION_ACTION:''')

print(action_gen.dispatch(vm_data.Actions, 'O_', '''\
            // Undefined instruction; try extra instructions.
            {
                error = smite_extra(S, I);
                if (error != 0)
                    RAISE(error);
            }'''))

print('''
        break;

    default: // Bug in smite_decode_instruction!
        return 1;
    }

    TRACE(ITYPE, I);

RET:
    assert(cached_depth == 0);
    return res;
}
''')

print('''\
#define FETCH                                       \\
    do {                                            \\
        initial_PC = S->PC;                         \\
        initial_STACK_DEPTH = S->STACK_DEPTH;       \\
        error = smite_load_byte(S, S->PC++, &NEXT); \\
        if (error != 0)                             \\
            RAISE(error);                           \\
    } while (0)

smite_WORD smite_run(smite_state *S) {
    int res = 128, error;''')

# Declare stack cache variables.
max_cached_depth = max(d for d, _, _, _ in labels)
if max_cached_depth > 0:
    print('''\
    smite_WORD {};'''.format(
        ', '.join(
            action_gen.stack_cache_var(pos, max_cached_depth) 
            for pos in reversed(range(max_cached_depth))
        )
    ))

print('''\
    do {
        smite_UWORD initial_PC, initial_STACK_DEPTH;
        smite_UWORD cached_depth = 0;
        smite_BYTE NEXT;

        FETCH;
        goto A_0;

        // Each A_XXX label has an expectation of what instruction sequence
        // probably comes next. If correct, there is a fast path for executing
        // that sequence, otherwise we fall back on a slow path with broader
        // expectations. Ultimately, we fall back to `A_ILLEGAL` which reports
        // an illegal instruction (the most unexpected case) or dispatches an
        // extra (implementation-specific) instruction.
        //
        // The calling convention at each A_XXX label is as follows:
        //
        //  - On entry, `res` is 128, `NEXT` is the first byte of the next
        //    instruction, `PC` has been incremented, and `STACK_DEPTH` has
        //    been decremented to pop the arguments.
        //  - When an error occurs, call `RAISE(code)`.
        //    It sets `res` to the return code; then it resets the stack depth
        //    to the depth on entry, and does "goto RET".
        //  - "goto RET" (but do not "return") at any time after completely
        //    executing at least one instruction, or never.
        //  - On exit, whether by `RAISE` or otherwise, all SMite
        //    registers must be set according to the SMite spec. In particular,
        //    there must be no side effects before a RAISE, except for the
        //    effects on STACK_DEPTH and PC described above.
''')

for label, (depth, name, if_correct, if_wrong) in enumerate(labels):
    event = EVENT_NAMES[name]
    print('''\
    {label}:
        assert(res == 128);
        cached_depth = {depth};
        if ({guess_code}) {{
            // {name}
{action_code}
            FETCH;
            goto {label_if_correct};
        }}
{balance_code}
        goto {label_if_wrong};
'''.format(
            label=label_names[label],
            depth=depth,
            guess_code=event.guess_code,
            name=event.name,
            action_code=textwrap.indent(
                action_gen.gen_case(
                    event,
                    cached_depth_entry=depth,
                    cached_depth_exit=label_depths[if_correct],
                ),
                '            ',
            ),
            label_if_correct=label_names[if_correct],
            balance_code=textwrap.indent(
                action_gen.balance_cache(depth, label_depths[if_wrong]),
                '        ',
            ),
            label_if_wrong=label_names[if_wrong],
        )
    )

print('''\
    A_ILLEGAL:
        {{
            assert(res == 128);
            cached_depth = {};
            // Pretend we fetched the instruction the formal way.
            S->PC--;
            smite_UWORD itype;
            smite_WORD opcode;
            error = smite_decode_instruction(S, &S->PC, &itype, &opcode);
            if (error != 0)
                RAISE(error);

            assert(itype == INSTRUCTION_ACTION);
            assert(opcode >= O_UNDEFINED);
            // Undefined instruction; try extra instructions.
            error = smite_extra(S, opcode);
            if (error != 0)
                RAISE(error);
            goto RET;
        }}
'''.format(label_depths[None]))

print('''\
    RET:
        {
            switch (cached_depth) {''')
for depth in range(max_cached_depth, 0, -1):
    print('''\
            case {depth}:
                UNCHECKED_STORE_STACK(cached_depth - {depth}, {var});
                // Falls through.'''.format(
        depth=depth,
        var=action_gen.stack_cache_var(0, depth),
    ))
print('''\
            case 0:
                break;
            default:
                assert(0); // Unreachable.
            }
        }
    } while (res == 128);
    return res;
}''')

