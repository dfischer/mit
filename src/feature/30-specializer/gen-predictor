#!/usr/bin/python3

import sys, pickle, hashlib

from mit_core.vm_data import Instruction

if len(sys.argv) != 3:
    print("Usage: gen-predictor TRACE-FILE PREDICTOR-FILE", file=sys.stderr)
    sys.exit(1)
trace_filename = sys.argv[1]
predictor_filename = sys.argv[2]

# Index the instruction set.

# bytes -> Instruction
TRACE_NAMES = {
    str(i.opcode).encode(): i
    for i in Instruction
}

class StepFunction:
    '''
    A callable that updates the history to record that an instruction was
    executed.
    '''
    def __init__(self, name):
        '''
         - name - bytes - the information about the instruction that will
           affect the history.
        '''
        h = hashlib.md5()
        h.update(name)
        h = int.from_bytes(h.digest(), byteorder='little')
        hash0 = h & 0x7FFFFFFFFFFFFFFF; h >>= 63
        hash1 = h & 0x7FFFFFFFFFFFFFFF; h >>= 63
        self._or_mask = hash0 & hash1
        self._and_mask = hash0 | hash1

    def __call__(self, history):
        return (history | self._or_mask) & self._and_mask

# Instruction -> HistoryStep
STEP_FUNCTIONS = {
    i: StepFunction(name)
    for name, i in TRACE_NAMES.items()
}

# Predictor.

class Predictor:
    '''
    Public fields:
     - predictions - a dict from history value (int) to a dict from
       Instruction to count (int).
    '''

    def __init__(self):
        self.predictions = {} # history (int) -> Instruction -> count (int).

    def record_instruction(self, history, instruction):
        '''
        Records that `instruction` occurred at `history`.
         - history - 63-bit hash of history.
         - instruction - An Instruction.
        '''
        if history not in self.predictions:
            self.predictions[history] = {}
        counts = self.predictions[history]
        if instruction not in counts:
            counts[instruction] = 0
        counts[instruction] += 1

    def instruction_count(self, history, instruction):
        if history not in self.predictions:
            return 0
        return self.predictions[history][instruction.name]

# Build a Predictor.

print("Building a predictor")

def open_trace(trace_filename):
    '''Yields Instructions.'''
    with open(trace_filename, 'rb') as trace:
        for line in trace:
            line = line.strip()
            if line in TRACE_NAMES:
                yield TRACE_NAMES[line]
            else:
                raise ValueError("Undefined instruction")

predictor = Predictor()
history = 0
progress = 0
for instruction in open_trace(trace_filename):
    predictor.record_instruction(history, instruction)
    history = STEP_FUNCTIONS[instruction](history)
    progress += 1
    if progress >= 1000000:
        progress = 0
        print('.', end='', flush=True)
print()

# Dump to a file, abstracting history, and removing rare states.

all_histories = [
    history
    for history, counts in predictor.predictions.items()
    if sum(counts.values()) >= 100
]

history_index = {
    history: state
    for state, history in enumerate(all_histories)
}

state_table = [
    {
        instruction.name: (
            history_index[STEP_FUNCTIONS[instruction](history)],
            count,
        )
        for (instruction, count) in predictor.predictions[history].items()
        if STEP_FUNCTIONS[instruction](history) in history_index
        if count > 0
    }
    for history in all_histories
]

with open(predictor_filename, 'wb') as f:
    # [{instruction_name: (new_state, count)]
    pickle.dump(state_table, f)
print('Wrote {}'.format(predictor_filename))
