#!/usr/bin/env python3
#
# (c) Mit authors 2019
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USER’S
# RISK.

import sys, json, pickle, functools, heapq, argparse

from mit_core.vm_data import Instruction
from path import State, Path
import profile
from futures import Future


# Command-line arguments.
parser = argparse.ArgumentParser(
    prog='gen-labels',
    description="Generate the specializer's labels file.",
)
parser.add_argument(
    'predictor_filename',
    metavar='PREDICTOR-FILENAME',
    help='predictor file to read',
)
parser.add_argument(
    'labels_filename',
    metavar='LABELS-FILENAME',
    help='labels file to write',
)
args = parser.parse_args()


# Load profile file.

profile.load(args.profile_filename)


# Elaborate the tree of most probable Paths.

print("Finding paths")


@functools.total_ordering
class QueueItem:
    '''
    A potentially interesting Path and its resulting Distribution.
    Compares by `distribution.total` (reversed).
    '''
    def __init__(self, path, distribution):
        self.path = path
        self.distribution = distribution

    def __le__(self, other):
        return self.distribution.total.__ge__(other.distribution.total)

    def __eq__(self, other):
        return self.distribution.total.__eq__(other.distribution.total)

    def __hash__(self):
        return self.distribution.total.__hash__()

    def successors(self):
        '''Yields slightly longer paths.'''
        # Check for repetition.
        if self.path.remove_repeating_part() != self.path:
            # This path won't become a state, because we'll loop instead.
            return
        # Add one instruction to the Path in all useful ways.
        predictions = self.distribution.predict()
        for instruction, new_distribution in predictions.items():
            if self.path.state.is_worthwhile(instruction):
                yield QueueItem(
                    self.path + (instruction,),
                    new_distribution,
                )


NUM_PATHS = 1100

# The `NUM_PATHS` most common instruction sequences.
# Path -> frequency
language = {}

heap = [QueueItem(Path(()), profile.ROOT_NODE)]
for _ in range(NUM_PATHS):
    try:
        item = heapq.heappop(heap)
    except IndexError:
        break
    language[item.path] = item.distribution
    least_freq = item.distribution.total
    for new_item in item.successors():
        heapq.heappush(heap, new_item)

# Sanity check.
for path in language:
    assert path[:-1] in language


# Delete paths that usually follow a particular prefix.

# Find paths that are suffixes of a longer path that is almost as frequent.
proposed_deletions = set()
for path in language:
    for suffix in path.suffixes():
        if suffix in language:
            if language[suffix].total - language[path].total < least_freq:
                proposed_deletions.add(suffix)

# Keep all paths that we don't propose to delete, and their prefixes.
to_keep = set()
for path in language:
    if path not in proposed_deletions:
        to_keep.update(path[:l] for l in range(len(path) + 1))

language = {path: language[path] for path in to_keep}


# For each path, find strings of instructions that might come next.

print("Choosing multi-guesses")

# The set of Instructions that might modify the ir register.
# We cannot guess beyond such an instruction.
GUESS_LIMITING = frozenset([
    Instruction.NEXT,
    Instruction.JUMP,
    Instruction.JUMPZ,
    Instruction.CALL,
])

def elaborate_future(distribution, state, total):
    '''
    Returns a Future representing the Instructions predicted by
    `distribution`.
     - distribution - Distribution.
     - state - State.
     - total - the frequency of the root of the decision tree. This is used
       to decide how deeply to elaborate the tree.
    '''
    children = {}
    for instruction, new_distribution in distribution.predict().items():
        if not state.is_worthwhile(instruction):
            # Useless guess: we cannot optimize it.
            pass
        elif distribution.total + new_distribution.total < total:
            # Useless guess: insufficiently probable.
            pass
        elif instruction in GUESS_LIMITING:
            # Do not guess beyond this one.
            children[instruction] = Future(new_distribution.total, {})
        else:
            # Recurse.
            children[instruction] = elaborate_future(
                new_distribution,
                state.step(state.specialize_instruction(instruction)),
                total,
            )
    return Future(distribution.total, children)

# Path -> list of non-empty tuple of Instruction
path_guesses = {path: [] for path in language}

for path, distribution in language.items():
    future = elaborate_future(distribution, path.state, distribution.total)
    while True:
        guess = tuple(future.guess())
        if len(guess) == 0:
            break
        if path + guess not in language:
            break
        path_guesses[path].append(guess)
        future.eliminate(guess)

# Generate state space of (path × rejects) with flood fill.

print("Generating control flow graph")

states = [] # List of (Path, rejects)
state_index = {} # Inverse of `states`.

# For each state in `states`, there is a transition in `transitions`.
# It can be:
#  - None - goto fallback;
#  - int g - goto g;
#  - (tuple(Instruction) guess, int c, int w) -
#    if (next==guess) { execute guess; goto c; } else goto w;
transitions = []

def enqueue(path, rejects):
    '''
    Adds a state if it has not been seen before.
     - path - Path.
     - rejects - frozenset of tuples of Instructions.
    '''
    assert isinstance(path, Path)
    assert isinstance(rejects, frozenset)
    state = (path, rejects)
    if state not in state_index:
        state_index[state] = len(state_index)
        states.append(state)
    return state_index[state]

assert enqueue(Path(()), frozenset()) == 0 # Root state.

# The work queue is the suffix of `states` that does not yet have transitions.
while len(transitions) < len(states):
    path, rejects = states[len(transitions)]
    for guess in path_guesses[path]:
        if all(guess[:l+1] not in rejects for l in range(len(guess))):
            # We have a guess.
            successor = (path + guess).remove_repeating_part()
            transitions.append((
                guess,
                enqueue(successor, frozenset()),
                enqueue(path, rejects.union([guess])),
            ))
            break
    else:
        # There is no good guess. Try again with a suffix of `path`.
        for path in path.suffixes():
            if path in language:
                transitions.append(enqueue(path, rejects))
                break
        else:
            # No more suffixes. Use the fallback executor.
            transitions.append(None)

assert len(states) == len(state_index) == len(transitions)

# Tension branches.

print("Tensioning branches")

# We only need labels for the states in which we make a guess.
label_map = {} # state -> label
for state, transition in enumerate(transitions):
    if isinstance(transition, tuple):
        label_map[state] = len(label_map)

def short_circuit(state):
    # Follows gotos, and maps `state` to a label or `None`.
    while isinstance(transitions[state], int):
        state = transitions[state]
    return label_map.get(state)

# List of (path properties... , guess, label or None, label or None).
labels = [
    (
        path.state.tos_constant,
        path.cached_depth(),
        path.checked_depth(),
        ' '.join(instruction.name for instruction in path.instructions),
        ' '.join(instruction.name for instruction in guess),
        short_circuit(c),
        short_circuit(w),
    )
    for (path, _), t in zip(states, transitions)
    if isinstance(t, tuple)
    for (guess, c, w) in [t]
]

assert len(label_map) == len(labels)

# Dump to a file.
with open(args.labels_filename, 'wb') as f:
    # [(
    #     tos_constant (int?),
    #     cached_depth (int),
    #     checked_depth (int),
    #     path_instruction_sequence (str, space-separated),
    #     guess_instruction_sequence (str, space-separated),
    #     if_correct (int?),
    #     if_wrong (int?)
    # )]
    pickle.dump(labels, file=f)
print('Wrote {}'.format(args.labels_filename))
