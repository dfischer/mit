#!/usr/bin/env python3
#
# (c) Mit authors 2019
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USER’S
# RISK.

import sys, json, pickle, functools, heapq, argparse

from mit_core.vm_data import Instruction
from path import State, Path
import profile


# Command-line arguments.
parser = argparse.ArgumentParser(
    prog='gen-labels',
    description="Generate the specializer's labels file.",
)
parser.add_argument(
    'profile_filename',
    metavar='PROFILE-FILENAME',
    help='profile file to read',
)
parser.add_argument(
    'labels_filename',
    metavar='LABELS-FILENAME',
    help='labels file to write',
)
args = parser.parse_args()


# Load profile file.

profile.load(args.profile_filename)


# Elaborate the tree of most probable Paths.

print("Finding paths")


@functools.total_ordering
class QueueItem:
    '''
    A potentially interesting Path and its PathNode.
    Compares by `node.frequency` (reversed).
     - path - Path.
     - node - PathNode.
    '''
    def __init__(self, path, node):
        self.path = path
        self.node = node

    def __le__(self, other):
        return self.node.frequency.__ge__(other.node.frequency)

    def __eq__(self, other):
        return self.node.frequency.__eq__(other.node.frequency)

    def __hash__(self):
        return self.node.frequency.__hash__()

    def successors(self):
        '''Yields slightly longer paths.'''
        # Check for repetition.
        if self.path.remove_repeating_part() != self.path:
            # This path won't become a state, because we'll loop instead.
            return
        for guess, node in self.node.predict():
            assert isinstance(guess, Instruction)
            try:
                yield QueueItem(self.path + (guess,), node)
            except ValueError:
                pass


NUM_PATHS = 1100

# The `NUM_PATHS` most common instruction sequences (roughly).
# Path -> frequency
language = {}

heap = [QueueItem(Path(()), profile.ROOT_NODE)]
for _ in range(NUM_PATHS):
    try:
        item = heapq.heappop(heap)
    except IndexError:
        break
    if item.path not in language:
        language[item.path] = 0.0
    language[item.path] += item.node.frequency
    least_freq = item.node.frequency
    for new_item in item.successors():
        heapq.heappush(heap, new_item)

# Add singleton paths to improve profiling information.
for instruction in Instruction:
    if Path(()).state.is_worthwhile(instruction):
        path = Path((instruction,))
        if path not in language:
            language[path] = 0.0

# Sanity check.
for path in language:
    assert path[:-1] in language


# Delete paths that usually follow a particular prefix.

# Find paths that are suffixes of a longer path that is almost as frequent.
proposed_deletions = set()
for path in language:
    for suffix in path.suffixes():
        if suffix in language:
            if language[suffix] - language[path] < least_freq:
                proposed_deletions.add(suffix)

# Keep all paths that we don't propose to delete, and their prefixes.
to_keep = set()
for path in language:
    if path not in proposed_deletions:
        to_keep.update(path[:l] for l in range(len(path) + 1))

language = {path: language[path] for path in to_keep}


# For each path, find strings of instructions that might come next.

print("Choosing guesses")
# TODO: Reimplement multi-guesses

# Path -> list of non-empty tuple of Instruction
path_guesses = {path: [] for path in language}

for path in language:
    guesses = []
    for instruction in Instruction:
        guess = (instruction,)
        if path.state.is_worthwhile(instruction):
            new_path = path + guess
            if new_path in language:
                new_freq = language[new_path]
                guesses.append((new_freq, guess))
    path_guesses[path] = [
        guess
        for _, guess in sorted(
            guesses,
            key=lambda x: x[0],
            reverse=True,
        )
    ]


# Generate state space of (path × rejects) with flood fill.

print("Generating control flow graph")

states = [] # List of (Path, rejects)
state_index = {} # Inverse of `states`.

# For each state in `states`, there is a transition in `transitions`.
# It can be:
#  - None - goto fallback;
#  - int g - goto g;
#  - (tuple(Instruction) guess, int c, int w) -
#    if (next==guess) { execute guess; goto c; } else goto w;
transitions = []

def enqueue(path, rejects):
    '''
    Adds a state if it has not been seen before.
     - path - Path.
     - rejects - frozenset of tuples of Instructions.
    '''
    assert isinstance(path, Path)
    assert isinstance(rejects, frozenset)
    state = (path, rejects)
    if state not in state_index:
        state_index[state] = len(state_index)
        states.append(state)
    return state_index[state]

assert enqueue(Path(()), frozenset()) == 0 # Root state.

# The work queue is the suffix of `states` that does not yet have transitions.
while len(transitions) < len(states):
    path, rejects = states[len(transitions)]
    for guess in path_guesses[path]:
        if all(guess[:l+1] not in rejects for l in range(len(guess))):
            # We have a guess.
            successor = (path + guess).remove_repeating_part()
            transitions.append((
                guess,
                enqueue(successor, frozenset()),
                enqueue(path, rejects.union([guess])),
            ))
            break
    else:
        # There is no good guess. Try again with a suffix of `path`.
        for path in path.suffixes():
            if path in language:
                transitions.append(enqueue(path, rejects))
                break
        else:
            # No more suffixes. Use the fallback executor.
            transitions.append(None)

assert len(states) == len(state_index) == len(transitions)


# Tension branches.

print("Tensioning branches")

# We only need labels for the states in which we make a guess.
label_map = {} # state -> label
for state, transition in enumerate(transitions):
    if isinstance(transition, tuple):
        label_map[state] = len(label_map)

def short_circuit(state):
    # Follows gotos, and maps `state` to a label or `None`.
    while isinstance(transitions[state], int):
        state = transitions[state]
    return label_map.get(state)

# List of (path properties... , guess, label or None, label or None).
labels = [
    (
        path.state.tos_constant,
        path.cached_depth(),
        path.checked_depth(),
        ' '.join(instruction.name for instruction in path.instructions),
        ' '.join(instruction.name for instruction in guess),
        short_circuit(c),
        short_circuit(w),
    )
    for (path, _), t in zip(states, transitions)
    if isinstance(t, tuple)
    for (guess, c, w) in [t]
]

assert len(label_map) == len(labels)

# Dump to a file.
with open(args.labels_filename, 'wb') as f:
    # [(
    #     tos_constant (int?),
    #     cached_depth (int),
    #     checked_depth (int),
    #     path_instruction_sequence (str, space-separated),
    #     guess_instruction_sequence (str, space-separated),
    #     if_correct (int?),
    #     if_wrong (int?)
    # )]
    pickle.dump(labels, file=f)
print('Wrote {}'.format(args.labels_filename))
