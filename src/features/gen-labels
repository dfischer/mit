#!/usr/bin/python3
# Generate the specializer's labels file.
#
# Copyright (c) 2019 Mit authors
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USER’S
# RISK.

import sys, json, pickle, re

from mit_core.vm_data import Instruction


if len(sys.argv) != 3:
    print("Usage: gen-labels PREDICTOR-FILENAME LABELS-FILENAME", file=sys.stderr)
    sys.exit(1)
predictor_filename = sys.argv[1]
labels_filename = sys.argv[2]

by_opcode = {i.opcode: i for i in Instruction}
with open(predictor_filename, 'rb') as f:
    # [{opcode (str): (new_state, count)]
    predictor = [
        {
            by_opcode[int(opcode, 16)]: (obj['new_state'], obj['count'])
            for opcode, obj in state.items()
        }
        for state in json.loads(f.read().decode())
    ]

# Probabilities.

class Distribution:
    '''
    Represents a frequency distribution over predictor states.
    Typically this represents some hypothetical situation.
    `NULL_HYPOTHESIS` is a Distribution covering all situations.
    The frequency of `state`, written `self[state]`, may be interpreted as
    the estimated number of times the state is visited and the hypothesis is
    true.

     - total - the sum of the frequencies of all the states.
    '''
    def __init__(self, iterable):
        '''
         - iterable - iterable of (state (int), frequency (float)).
           If a `state` is repeated, its `frequency`s will be summed.
        '''
        self.frequencies = {}
        for state, frequency in iterable:
            assert type(state) is int and 0 <= state < len(predictor)
            assert type(frequency) is float and 0 <= frequency
            if state not in self.frequencies:
                self.frequencies[state] = 0.
            self.frequencies[state] += frequency
        self.total = sum(self.frequencies.values())

    def __repr__(self):
        return 'Distribution(total={})'.format(self.total)

    def __getitem__(self, state):
        '''Equivalent to `self.frequencies[state]`.'''
        assert type(state) is int and 0 <= state < len(predictor)
        return self.frequencies.get(state, 0.0)

    def predict(self):
        '''
        Returns a dict from Instruction to Distribution. Each entry gives
        a possible next Instruction and the Distribution that would result.
        The `total`s of the distributions give a frequency distribution over
        the Instructions.
        '''
        successors = {instruction: [] for instruction in Instruction}
        for state, frequency in self.frequencies.items():
            for instruction, (new_state, count) in predictor[state].items():
                probability = count / NULL_HYPOTHESIS[state]
                successors[instruction].append(
                    (new_state, frequency * probability)
                )
        return {
            instruction: Distribution(x)
            for instruction, x in successors.items()
        }

NULL_HYPOTHESIS = Distribution(
    (state, float(sum(count for _, count in transitions.values())))
    for state, transitions in enumerate(predictor)
)

# Find all paths through the predictor.

print("Finding paths")

class Path:
    '''
    Represents a sequence of instructions that has just been executed.

     - instructions - tuple of Instructions.
     - tos_constant - int - the constant value on the top of the stack, or
       `None` if unknown.
     - cached_depth - int - The number of topmost stack items that are cached
       at the end of this Path.
     - checked_depth - int - the number of empty stack slots that are known
       to exist above the topmost item at the end of this Path.
    '''
    def __init__(self, instructions):
        assert type(instructions) is tuple
        self.instructions = instructions
        self.tos_constant = None
        # Compute `tos_constant`, `cached_depth`, `checked_depth`.
        tos_constant = None
        cached_depth = 0
        checked_depth = 0
        for instruction in instructions:
            assert isinstance(instruction, Instruction)
            m = re.match('LIT_(\d+)', instruction.name)
            if m:
                # The last instruction exists and pushes a constant.
                tos_constant = int(m.group(1))
            elif instruction == Instruction.NEXT:
                pass
            else:
                tos_constant = None
            if instruction.args is None and instruction.results is None:
                # We know nothing after this instruction.
                cached_depth = 0
                checked_depth = 0
            else:
                # Simulate popping arguments.
                for item in reversed(instruction.args):
                    if item == 'ITEMS':
                        # Conservatively suppose `COUNT` is zero.
                        # We cannot cache items below 'ITEMS'.
                        cached_depth = 0
                    else:
                        cached_depth -= 1
                        checked_depth += 1
                if cached_depth < 0:
                    cached_depth = 0
                # Simulate pushing results.
                for item in instruction.results:
                    if item == 'ITEMS':
                        # Conservatively suppose `COUNT` is large.
                        checked_depth = 0
                        # We cannot cache items below 'ITEMS'.
                        cached_depth = 0
                    else:
                        cached_depth += 1
                        checked_depth -= 1
                if checked_depth < 0:
                    checked_depth = 0
        self.tos_constant = tos_constant
        self.cached_depth = cached_depth
        self.checked_depth = checked_depth

    def __repr__(self):
        return 'Path(({}))'.format(
            ', '.join(i.name for i in self.instructions)
        )

    def __eq__(self, other):
        return self.instructions == other.instructions

    def __hash__(self):
        return hash(self.instructions)

    def __len__(self):
        return len(self.instructions)

    def __getitem__(self, index_or_slice):
        if isinstance(index_or_slice, slice):
            return Path(self.instructions[index_or_slice])
        elif isinstance(index_or_slice, int):
            return self.instructions[index_or_slice]
        else:
            raise TypeError('Path indices must be integers or slices')

    def __add__(self, sequence):
        return Path(self.instructions + sequence)

    def is_useful_guess(self, instruction):
        '''
        Returns `True` if the implementation of `instruction` is significantly
        more efficient after executing this Path than from a standing start.
        '''
        if instruction.args is None or instruction.results is None:
            # Arbitrary stack effect. No optimizations are possible.
            return False
        elif 'ITEMS' in instruction.args or 'ITEMS' in instruction.results:
            # Variadic instruction. We can optimize only if we know `COUNT`.
            return (
                instruction.args[-1] == 'COUNT' and
                self.tos_constant is not None
            )
        else:
            # Ordinary instruction.
            return True

    def remove_repeating_part(self):
        '''
        If this Path ends with two repeats of some "loop body", and if we know
        at least as much about the stack now as we did before the last repeat,
        returns the Path before the last repeat, otherwise returns `self`.
        '''
        for n in range(2, len(self)//2+1):
            if self.instructions[-n:] == self.instructions[-2*n:-n]:
                shorter = self[:-n]
                if (self.cached_depth >= shorter.cached_depth and
                    self.checked_depth >= shorter.checked_depth
                ):
                    return shorter
        return self
        

# Common instruction sequences.
# Path -> Distribution
language = {}

def walk(path, distribution):
    '''
     - path - a Path.
     - distribution - a Distribution.
    '''
    # Check for statistical irrelevance (but keep the empty path).
    if len(path) > 0 and distribution.total < 40000.: return
    # Okay, it's common enough, we'll keep it.
    language[path] = distribution
    # Check for repetition.
    if path.remove_repeating_part() != path:
        # This path won't become a state, because we'll loop instead.
        return
    # Recurse down the tree.
    for instruction, new_distribution in distribution.predict().items():
        if path.is_useful_guess(instruction):
            new_path = (path + (instruction,))
            walk(new_path, new_distribution)

walk(Path(()), NULL_HYPOTHESIS)

# Sanity checks.

for path in language:
    assert path[:-1] in language

# For each path, sort the possible next instructions by decreasing probability.

print("Choosing guesses")

# Path -> [Instruction]
path_guesses = {
    path: sorted(
        [
            instruction
            for instruction in Instruction
            if (path + (instruction,)) in language
        ],
        key=lambda instruction: language[path + (instruction,)].total,
        reverse=True,
    )
    for path in language
}

# Generate state space of (path × rejects) with flood fill.

print("Generating control flow graph")

states = [] # List of (Path, rejects)
state_index = {} # Inverse of `states`.

# For each state in `states`, there is a transition in `transitions`.
# It can be:
#  - None - goto fallback;
#  - int g - goto g;
#  - (Instruction i, int c, int w) - if (next==i) { e; goto c; } else goto w;
transitions = []

def enqueue(path, rejects):
    '''
    Adds a state if it has not been seen before.
     - path - Path.
     - rejects - frozenset of Instructions.
    '''
    assert isinstance(path, Path)
    assert isinstance(rejects, frozenset)
    state = (path, rejects)
    if state not in state_index:
        state_index[state] = len(state_index)
        states.append(state)
    return state_index[state]

assert enqueue(Path(()), frozenset()) == 0 # Root state.

# The work queue is the suffix of `states` that does not yet have transitions.
while len(transitions) < len(states):
    path, rejects = states[len(transitions)]
    for guess in path_guesses[path]:
        if guess not in rejects:
            # We have a guess.
            successor = (path + (guess,)).remove_repeating_part()
            transitions.append((
                guess,
                enqueue(successor, frozenset()),
                enqueue(path, rejects.union({guess})),
            ))
            break
    else:
        # There is no good guess.
        new_path = path[1:]
        while new_path not in language:
            # Occurs if not Path(()).is_useful_guess(new_path[0])
            new_path = new_path[1:]
        if len(new_path) > 0:
            transitions.append(enqueue(new_path, rejects))
        else:
            # There is no useful history. Use the fallback executor.
            transitions.append(None)

assert len(states) == len(state_index) == len(transitions)

# Tension branches.

print("Tensioning branches")

# We only need labels for the states in which we make a guess.
label_map = {} # state -> label
for state, transition in enumerate(transitions):
    if isinstance(transition, tuple):
        label_map[state] = len(label_map)

def short_circuit(state):
    # Follows gotos, and maps `state` to a label or `None`.
    while isinstance(transitions[state], int):
        state = transitions[state]
    return label_map.get(state)

# List of (guess, label or None, label or None).
labels = [
    (
        path.tos_constant,
        path.cached_depth,
        path.checked_depth,
        guess.name,
        short_circuit(c),
        short_circuit(w)
    )
    for (path, _), t in zip(states, transitions)
    if isinstance(t, tuple)
    for (guess, c, w) in [t]
]

assert len(label_map) == len(labels)

# Dump to a file.

with open(labels_filename, 'wb') as f:
    # [(
    #     tos_constant (int?),
    #     cached_depth (int),
    #     checked_depth (int),
    #     instruction_name (str),
    #     if_correct (int?),
    #     if_wrong (int?)
    # )]
    pickle.dump(labels, file=f)
print('Wrote {}'.format(labels_filename))
