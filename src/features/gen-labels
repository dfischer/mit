#!/usr/bin/python3

import sys, pickle, re

from mit_core.vm_data import Instruction

if len(sys.argv) != 3:
    print("Usage: gen-labels PREDICTOR-FILENAME LABELS-FILENAME", file=sys.stderr)
    sys.exit(1)
predictor_filename = sys.argv[1]
labels_filename = sys.argv[2]

with open(predictor_filename, 'rb') as f:
    # [{instruction_name: (new_state, count)]
    predictor = pickle.load(f)

# Find all paths through the predictor.

print("Finding paths")

# Total visit count of each state.
# [int]
state_counts = [
    sum(count for _, count in transitions.values())
    for transitions in predictor
]

# Estimated probability distribution over instructions for each state.
# [{Instruction: (new_state (int), probability (float))}]
state_probabilities = [
    {
        Instruction[name]: (
            new_state,
            float(count + 1) / float(state_counts[state] + 64),
        )
        for name, (new_state, count) in transitions.items()
    }
    for state, transitions in enumerate(predictor)
]

class Path:
    '''
    Represents a sequence of instructions that has just been executed.

     - instructions - tuple of Instructions.
     - tos_constant - int - the constant value on the top of the stack, or
       `None` if unknown.
     - cached_depth - int - The number of topmost stack items that are cached
       at the end of this Path.
     - checked_depth - int - the number of empty stack slots that are known
       to exist above the topmost item at the end of this Path.
    '''
    def __init__(self, instructions):
        assert type(instructions) is tuple
        self.instructions = instructions
        # Compute `tos_constant`.
        self.tos_constant = None
        if len(instructions) > 0:
            m = re.match('LIT_(\d+)', instructions[-1].name)
            if m:
                # The last instruction exists and pushes a constant.
                self.tos_constant = int(m.group(1))
        # Compute `cached_depth`, `checked_depth`.
        cached_depth = 0
        checked_depth = 0
        for instruction in instructions:
            assert isinstance(instruction, Instruction)
            if instruction.args is None and instruction.results is None:
                # We know nothing after this instruction.
                cached_depth = 0
                checked_depth = 0
            else:
                # Simulate popping arguments.
                for item in reversed(instruction.args):
                    if item == 'ITEMS':
                        # Conservatively suppose `COUNT` is zero.
                        # We cannot cache items below 'ITEMS'.
                        cached_depth = 0
                    else:
                        cached_depth -= 1
                        checked_depth += 1
                if cached_depth < 0:
                    cached_depth = 0
                # Simulate pushing results.
                for item in instruction.results:
                    if item == 'ITEMS':
                        # Conservatively suppose `COUNT` is large.
                        checked_depth = 0
                        # We cannot cache items below 'ITEMS'.
                        cached_depth = 0
                    else:
                        cached_depth += 1
                        checked_depth -= 1
                if checked_depth < 0:
                    checked_depth = 0
        self.cached_depth = cached_depth
        self.checked_depth = checked_depth

    def __repr__(self):
        return 'Path(({}))'.format(
            ', '.join(i.name for i in self.instructions)
        )

    def __eq__(self, other):
        return self.instructions == other.instructions

    def __hash__(self):
        return hash(self.instructions)

    def __len__(self):
        return len(self.instructions)

    def __getitem__(self, index_or_slice):
        if isinstance(index_or_slice, slice):
            return Path(self.instructions[index_or_slice])
        elif isinstance(index_or_slice, int):
            return self.instructions[index_or_slice]
        else:
            raise TypeError('Path indices must be integers or slices')

    def __add__(self, sequence):
        return Path(self.instructions + sequence)

    def is_useful_guess(self, instruction):
        '''
        Returns `True` if the implementation of `instruction` is significantly
        more efficient after executing this Path than from a standing start.
        '''
        if instruction.args is None or instruction.results is None:
            # Arbitrary stack effect. No optmizations are possible.
            return False
        elif 'ITEMS' in instruction.args or 'ITEMS' in instruction.results:
            # Variadic instruction. We can optimize only if we know `COUNT`.
            return (
                instruction.args[-1] == 'COUNT' and
                self.tos_constant is not None
            )
        else:
            # Ordinary instruction.
            return True

    def remove_repeating_part(self):
        '''
        If this Path ends with two repeats of some "loop body", and if we know
        at least as much about the stack now as we did before the last repeat,
        returns the Path before the last repeat, otherwise returns `self`.
        '''
        for n in range(2, len(self)//2+1):
            if self.instructions[-n:] == self.instructions[-2*n:-n]:
                shorter = self[:-n]
                if (self.cached_depth >= shorter.cached_depth and
                    self.checked_depth >= shorter.checked_depth
                ):
                    return shorter
        return self
        

# Common instruction sequences.
# Path -> estimated_count (float)
language = {}

def walk(path, distribution):
    '''
     - path - a Path.
     - distribution - list of float - For each predictor state, the estimated
       number of times we reached that state via `path`.
    '''
    # Check for statistical irrelevance (but keep the empty path).
    estimated_count = sum(distribution)
    if len(path) > 0 and estimated_count < 300000.: return
    # Okay, it's common enough, we'll keep it.
    language[path] = estimated_count
    # Check for repetition.
    if path.remove_repeating_part() != path:
        # This path won't become a state, because we'll loop instead.
        return
    # For all (state, action) pairs, propagate count to the successor state.
    successors = {
        instruction: [0.] * len(predictor)
        for instruction in Instruction
    }
    for state, estimated_count in enumerate(distribution):
        if estimated_count > 1.:
            probabilities = state_probabilities[state]
            for instruction, (new_state, probability) in probabilities.items():
                if path.is_useful_guess(instruction):
                    additional_count = estimated_count * probability
                    if additional_count >= 1.:
                        successors[instruction][new_state] += additional_count
    # Recurse down the tree.
    for instruction, new_distribution in successors.items():
        new_path = (path + (instruction,))
        walk(new_path, new_distribution)

walk(Path(()), [float(x) for x in state_counts])

# Sanity checks.

for path in language:
    assert path[1:] in language or not Path(()).is_useful_guess(path[1])
    assert path[:-1] in language

# For each path, sort the possible next instructions by decreasing probability.

print("Choosing guesses")

# Path -> [Instruction]
path_guesses = {
    path: sorted(
        [
            instruction
            for instruction in Instruction
            if (path + (instruction,)) in language
        ],
        key=lambda instruction: language[path + (instruction,)],
        reverse=True,
    )
    for path in language
}

# Generate state space of (path Ã— rejects) with flood fill.

print("Generating control flow graph")

states = [] # List of (Path, rejects)
state_index = {} # Inverse of `states`.

# For each state in `states`, there is a transition in `transitions`.
# It can be:
#  - None - goto fallback;
#  - int g - goto g;
#  - (Instruction i, int c, int w) - if (next==i) { e; goto c; } else goto w;
transitions = []

def enqueue(path, rejects):
    '''
    Adds a state if it has not been seen before.
     - path - Path.
     - rejects - frozenset of Instructions.
    '''
    assert isinstance(path, Path)
    assert isinstance(rejects, frozenset)
    state = (path, rejects)
    if state not in state_index:
        state_index[state] = len(state_index)
        states.append(state)
    return state_index[state]

assert enqueue(Path(()), frozenset()) == 0 # Root state.

# The work queue is the suffix of `states` that does not yet have transitions.
while len(transitions) < len(states):
    path, rejects = states[len(transitions)]
    for guess in path_guesses[path]:
        if guess not in rejects:
            # We have a guess.
            successor = (path + (guess,)).remove_repeating_part()
            transitions.append((
                guess,
                enqueue(successor, frozenset()),
                enqueue(path, rejects.union({guess})),
            ))
            break
    else:
        # There is no good guess.
        new_path = path[1:]
        while new_path not in language:
            # Occurs if not Path(()).is_useful_guess(new_path[0])
            new_path = new_path[1:]
        if len(new_path) > 0:
            transitions.append(enqueue(new_path, rejects))
        else:
            # There is no useful history. Use the fallback executor.
            transitions.append(None)

assert len(states) == len(state_index) == len(transitions)

# Tension branches.

print("Tensioning branches")

# We only need labels for the states in which we make a guess.
label_map = {} # state -> label
for state, transition in enumerate(transitions):
    if isinstance(transition, tuple):
        label_map[state] = len(label_map)

def short_circuit(state):
    # Follows gotos, and maps `state` to a label or `None`.
    while isinstance(transitions[state], int):
        state = transitions[state]
    return label_map.get(state)

# List of (guess, label or None, label or None).
labels = [
    (
        path.tos_constant,
        path.cached_depth,
        path.checked_depth,
        guess.name,
        short_circuit(c),
        short_circuit(w)
    )
    for (path, _), t in zip(states, transitions)
    if isinstance(t, tuple)
    for (guess, c, w) in [t]
]

assert len(label_map) == len(labels)

# Dump to a file.

with open(labels_filename, 'wb') as f:
    # [(
    #     tos_constant (int?),
    #     cached_depth (int),
    #     checked_depth (int),
    #     instruction_name (str),
    #     if_correct (int?),
    #     if_wrong (int?)
    # )]
    pickle.dump(labels, file=f)
print('Wrote {}'.format(labels_filename))
