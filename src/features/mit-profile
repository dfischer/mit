#!/usr/bin/python3
#
# Copyright (c) 2019 Mit authors
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

import argparse, pickle, json

from mit_core.vm_data import Instruction


# Command-line arguments.
parser = argparse.ArgumentParser(
    prog='mit-profile',
    description='Analyze a profile generated by "mit --profile".',
)
parser.add_argument(
    'profile_file',
    metavar='PROFILE-FILE',
    help='profile file to use',
)
parser.add_argument(
    'labels_file',
    metavar='LABELS-FILE',
    help='labels file to use',
)
args = parser.parse_args()


class Label:
    '''
    Data about one of the labels in specializer.c.

     - index - int - the index of this Label.
     - path - str - the instruction sequence just executed.
     - guess - str - the most probable next instruction sequence.
       (space-separated).
     - if_correct - int - the Label index to jump to if `guess` is correct.
     - if_wrong - int - the Label index to jump to if `guess` is wrong.
     - correct_count - the number of times `guess` was correct.
     - wrong_count - the number of times `guess` was wrong.
    '''
    def __init__(
        self,
        index,
        path,
        guess,
        if_correct,
        if_wrong,
        correct_count,
        wrong_count,
    ):
        self.index = index
        self.path = path
        self.guess = guess
        self.if_correct = if_correct
        self.if_wrong = if_wrong
        self.correct_count = correct_count
        self.wrong_count = wrong_count
        self.total_count = correct_count + wrong_count

    def __repr__(self):
        return 'Label({}, {!r}, {!r}, {}, {}, {}, {})'.format(
            self.index,
            self.path,
            self.guess,
            self.if_correct,
            self.if_wrong,
            self.correct_count,
            self.wrong_count,
        )


# Load the data files.
with open(args.labels_file, 'rb') as h:
    labels = pickle.load(h)
with open(args.profile_file) as h:
    profile = json.load(h)
assert len(labels) == len(profile), (
    "{} does not match {} (wrong number of states)".format(
        args.profile_file,
        args.labels_file,
    )
)
labels = [
    Label(index, path, gu, ic, iw, profile['c'], profile['w'])
    for index, ((tos, ca, ch, path, gu, ic, iw), profile) in enumerate(
        zip(labels, profile)
    )
]


# Compute totals.
total_count = sum(label.total_count for label in labels)
fallback_count = sum(
    label.correct_count
    for label in labels
    if label.if_correct is None
) + sum (
    label.wrong_count
    for label in labels
    if label.if_wrong is None
)
