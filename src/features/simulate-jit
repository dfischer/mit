#!/usr/bin/env python3
#
# (c) Mit authors 2019
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.


import sys, json, functools, heapq, argparse, random

from mit_core.vm_data import Instruction


random.seed(0)

# Command-line arguments.
parser = argparse.ArgumentParser(
    prog='simulate-jit',
    description="Experimental algorithm for incremental compilation.",
)
parser.add_argument(
    'profile_filename',
    metavar='PROFILE-FILENAME',
    help='profile file to read',
)
args = parser.parse_args()


# Load profile file.

class ProfileState:
    '''
    Represents a state of the interpreter that we profiled.
     - index - the index of this ProfileState in `profile`.
     - path - str (space-separated Instruction name) - the canonical path to
       this ProfileState.
     - guess - str (space-separated Instruction name) - the guessed
       continuation.
     - correct_state - int - the index of the ProfileState to jump to if
       `guess` is correct, or `-1` for the fallback state.
     - wrong_state - int - the index of the ProfileState to jump to if
       `guess` is correctwrong, or `-1` for the fallback state.
     - correct_count - the number of times `guess` was correct.
     - wrong_count - the number of times `guess` was wrong.
     - total_count - `correct_count + wrong_count`.
    '''
    def __init__(
        self,
        index,
        path,
        guess,
        correct_state,
        wrong_state,
        correct_count,
        wrong_count,
    ):
        self.index = index
        self.path = path
        self.guess = guess
        self.correct_state = correct_state
        self.wrong_state = wrong_state
        self.correct_count = correct_count
        self.wrong_count = wrong_count
        self.total_count = correct_count + wrong_count

    def __repr__(self):
        return 'ProfileState({}, {!r}, {!r}, {}, {}, {}, {})'.format(
            self.index,
            self.path,
            self.guess,
            self.correct_state,
            self.wrong_state,
            self.correct_count,
            self.wrong_count,
        )

# Load the data file.
with open(args.profile_filename) as h:
    profile = [
        ProfileState(
            index,
            profile['path'],
            profile['guess'],
            profile['correct_state'],
            profile['wrong_state'],
            profile['correct_count'],
            profile['wrong_count'],
        )
        for index, profile in enumerate(json.load(h))
    ]


def get_profile_state(index):
    if index == -1:
        return None
    else:
        return profile[index]


class PathNode:
    '''
    Represents a node of the tree of probable paths.
     - guess - a tuple of Instructions that we've committed to.
     - profile_state - the ProfileState we'll reach after exhausting `guess`, or
       `None`.
     - frequency - an estimate of the relative frequency of this PathNode.
    '''
    def __init__(self, guess, profile_state, frequency):
        assert type(guess) is tuple
        assert profile_state is None or isinstance(profile_state, ProfileState)
        assert type(frequency) is float
        self.guess = guess
        self.profile_state = profile_state
        self.frequency = frequency

    def __repr__(self):
        return 'Node({!r}, {!r}, {})'.format(
            ' '.join(i.name for i in self.guess),
            self.profile_state,
            self.frequency,
        )

    def predict(self):
        '''
        Yields (Instruction, PathNode).
        '''
        if len(self.guess) > 0:
            yield (
                self.guess[0],
                PathNode(
                    self.guess[1:],
                    self.profile_state,
                    self.frequency,
                )
            )
        else:
            for successor in self._successors():
                for instruction, path_node in successor.predict():
                    yield (instruction, path_node)

    def _successors(self):
        '''
        Requires `self.guess` to be empty.
        Yields PathNodes whose union describes the same tree as `self`.
        '''
        assert len(self.guess) == 0
        if self.profile_state is not None and self.frequency > 0.0:
            ps = self.profile_state
            assert ps.total_count != 0
            # The successor if the guess is correct.
            yield PathNode(
                tuple(Instruction[name] for name in ps.guess.split()),
                get_profile_state(ps.correct_state),
                self.frequency * ps.correct_count / ps.total_count,
            )
            # The successor if the guess is wrong.
            yield PathNode(
                (),
                get_profile_state(ps.wrong_state),
                self.frequency * ps.wrong_count / ps.total_count,
            )

ROOT_NODE = PathNode((), get_profile_state(0), 1.0)


def trace():
    current_node = ROOT_NODE
    while True:
        current_node.frequency = 1.0 # Ensure we never stop by underflow.
        predictions = list(current_node.predict())
        frequencies = [node.frequency for _, node in predictions]
        instruction, current_node = random.choices(predictions, frequencies)[0]
        yield instruction


def trace2():
    '''
    Alternate, highly artificial trace, useful for debugging.
    '''
    while True:
        for _ in range(2):
            for instruction in list(Instruction)[:3]:
                yield instruction
        for _ in range(2):
            for instruction in list(Instruction)[8:11]:
                yield instruction


def is_suffix_of(a, b):
    '''Tests whether `a` is a suffix of `b`.'''
    pos = len(b) - len(a)
    return b[pos:] == a

def is_proper_suffix_of(a, b):
    return len(a) < len(b) and is_suffix_of(a, b)

def is_prefix_of(a, b):
    '''Tests whether `a` is a prefix of `b`.'''
    pos = len(a)
    return b[:pos] == a

def is_proper_prefix_of(a, b):
    return len(a) < len(b) and is_prefix_of(a, b)

def _end_of_prefix(short, long):
    assert is_proper_suffix_of(short, long)
    pos = len(long) - len(short)
    return long[pos - 1]


class Label:
    '''
    A simulated code address (as if compiled by the JIT). Each Label has a
    `path`, defined to be the shortest sequence of Instructions that takes the
    interpreter from `ROOT_LABEL` to this Label.

    At each Label, we count how many times each Instruction follows it. This is
    the basis of a policy to decide when to construct a new Label.

    Invariants:
     - UNIQUE - There is at most one Label for each path.
     - RIGHT - If a Label exists for a non-empty path `p`, then a Label exists
       for path `p[:-1]`.
     - LEFT - If Labels exist for paths `p` and `q`, then a Label exists for
       the longest common suffix of `p` and `q`.

    Public fields:
     - path - tuple of Instruction - the canonical name of this Label.
     - right_parent - the Label whose `path` is `self.path[:-1]` (`None` for
       `ROOT_LABEL`).
     - right_children - dict from Instruction to Label - the Labels of which
       `self` is the `right_parent`.
     - left_ancestor - the Label whose `path` is `self.path[n:]` for the
       smallest `n>0` (`None` for `ROOT_LABEL`).
     - left_descendants - dict from Instruction to Label - the Labels of which
       `self` is the `left_ancestor`. Note that by "LEFT" the key is a single
       Instruction.
     - counts - dict from Instruction to int - Until `right_children[i]` is
       created, `counts[i]` is the number of times this Label is followed by
       the Instruction `i`. We don't bother to count thereafter.
    '''
    ALL_LABELS = []

    def __init__(self, path, right_parent, left_ancestor):
        self.path = path
        self.right_parent = right_parent
        self.left_ancestor = left_ancestor
        self.right_children = {}
        self.left_descendants = {}
        self.counts = {i: 0 for i in Instruction}
        print('Constructing {!r}'.format(self))
        print('    right_parent = {!r}'.format(right_parent))
        print('    left_ancestor = {!r}'.format(left_ancestor))
        if len(path) == 0:
            # Check the invariants.
            assert right_parent is None
            assert left_ancestor is None
        else:
            # Check the invariants.
            # `right_parent` is the immediate prefix. Implies RIGHT.
            assert path[:-1] == right_parent.path
            # UNIQUE.
            right_key = path[-1]
            assert right_parent.right_children.get(right_key) is None
            # `left_ancestor` is a suffix.
            assert is_proper_suffix_of(left_ancestor.path, path)
            # `left_ancestor` is the longest suffix.
            # Also, LEFT.
            left_key = _end_of_prefix(left_ancestor.path, path)
            left_descendant = left_ancestor.left_descendants.get(left_key)
            if left_descendant is not None:
                assert is_proper_suffix_of(path, left_descendant.path)
            # Update the connections.
            right_parent.right_children[right_key] = self
            left_ancestor.left_descendants[left_key] = self
            if left_descendant is not None:
                left_key2 = _end_of_prefix(path, left_descendant.path)
                self.left_descendants[left_key2] = left_descendant
        # Add `self` to `ALL_LABELS`.
        Label.ALL_LABELS.append(self)

    def __repr__(self):
        return 'Label({})'.format(
            ' '.join(instruction.name for instruction in self.path)
        )

    COMPILE_THRESHOLD = 100

    def guess(self, instruction):
        '''
        Tests whether the JIT has compiled specialized code for executing
        `instruction` from `self`. If so, returns the Label otherwise `None`.
        '''
        return self.right_children.get(instruction)

    def default(self):
        '''
        Returns a Label whose `path` is a suffix of `self.path` (`None` for
        `ROOT_LABEL`). The interpreter will jump to this Label if it cannot
        find a more specialized Label.
        '''
        return self.left_ancestor

    def construct(self, instruction):
        '''
        Construct and return a new right child of `self`.
        '''
        new_path = self.path + (instruction,)
        left_ancestor = self.left_ancestor
        while left_ancestor is not None:
            right_child_of_left_ancestor = \
                left_ancestor.right_children.get(instruction)
            if right_child_of_left_ancestor is not None:
                break
            left_ancestor = left_ancestor.left_ancestor
        else:
            right_child_of_left_ancestor = ROOT_LABEL
        return Label(new_path, self, right_child_of_left_ancestor)

    @staticmethod
    def run(label, instruction):
        '''
        Executes one instruction.
        Returns the next Label.
        '''
        threshold = Label.COMPILE_THRESHOLD
        while True:
            # Is there a right edge? Follow it if so.
            next_label = label.guess(instruction)
            if next_label is not None:
                # Execute a compiled instruction.
                print(instruction.name, end=' ')
                return next_label
            # Should we make the right edge that we didn't follow?
            label.counts[instruction] += 1
            if label.counts[instruction] >= threshold:
                # It is time to create a Label for `new_path`.
                # This is rare and can be slow.
                print()
                print("Compiling {!r} + {}".format(label, instruction.name))
                label.construct(instruction)
            # Follow a left edge.
            old_length = len(label.path)
            threshold = Label.COMPILE_THRESHOLD + label.counts[instruction]
            label = label.default()
            if label is None:
                # Fall back to the interpreter.
                print("FALLBACK({})".format(instruction.name))
                return ROOT_LABEL
            num_shrinks = old_length - len(label.path)
            print(">" * num_shrinks, end=' ')


# The unique Label with an empty `path`.
ROOT_LABEL = Label((), None, None)


current_label = ROOT_LABEL
for instruction in trace():
    if len(Label.ALL_LABELS) >= 200:
        break
    current_label = Label.run(current_label, instruction)

print()
from pprint import pprint
import sys
print()
label_strs = sorted(repr(l) for l in Label.ALL_LABELS)
pprint(label_strs, width=499)
print()
label_reversed_strs = sorted(
    ' '.join(i.name for i in reversed(l.path))
    for l in Label.ALL_LABELS
)
pprint(label_reversed_strs, width=499)


def write_svg(filename):
    print("Generating '{}'...".format(filename))
    import pydot
    g = pydot.Dot(
        'labels',
        rankdir='LR',
        root=repr(ROOT_LABEL),
        overlap='false',
        K='10',
        splines='curved', # Don't combine with prog='dot'; see below.
    )
    nodes = {} # Label -> Node
    for i, l in enumerate(Label.ALL_LABELS):
        n = pydot.Node(
            # EITHER: number the states
            #str(i),
            # OR: name the states.
            '('+' '.join(instruction.name for instruction in l.path)+')',
            shape='star' if l is ROOT_LABEL else 'ellipse',
        )
        nodes[l] = n
        g.add_node(nodes[l])
    for l in Label.ALL_LABELS:
        for i, l2 in l.right_children.items():
            g.add_edge(pydot.Edge(
                nodes[l],
                nodes[l2],
                color='green',
                #label=i.name,
            ))
        if l is not ROOT_LABEL:
            l2 = l.default()
            num_shrinks = len(l.path) - len(l2.path)
            g.add_edge(pydot.Edge(
                nodes[l],
                nodes[l2],
                color='red',
                style=('solid' if num_shrinks==1 else 'bold'),
            ))
    # With "prog='dot'" and non-default "splines" some of the arrows are
    # inverted.
    # We think it's https://gitlab.com/graphviz/graphviz/issues/763
    # i.e. not our fault. Works with other engines.
    g.write_svg(filename, prog='dot')
    print("Wrote '{}'".format(filename))

write_svg('/tmp/labels.svg')
