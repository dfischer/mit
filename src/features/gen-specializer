#!/usr/bin/env python3
# Generate code for instructions.
#
# (c) Mit authors 1994-2019
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

import sys, pickle, textwrap

from mit_core.vm_data import Instruction
from specializer import gen_case, CacheState

# Load language.
if len(sys.argv) != 2:
    print("Usage: gen-specializer LABELS-FILE", file=sys.stderr)
    sys.exit(1)

class Label:
    '''
     - name - str - The C identifier of this Label.
     - cached_depth - int - the number of stack items that are cached in C
       variables at this Label.
     - checked_depth - int - the number of empty stack slots that are known to
       exist above the top of the stack at this Label.
     - guess - Instruction - the most probable next instruction.
     - if_correct - int - the Label index to jump to if `guess` is correct.
     - if_wrong - int - the Label index to jump to if `guess` is wrong.
    '''
    def __init__(
        self,
        name,
        cached_depth=0,
        checked_depth=0,
        guess=None,
        if_correct=None,
        if_wrong=None,
    ):
        self.name = name
        self.cached_depth = cached_depth
        self.checked_depth = checked_depth
        self.guess = guess
        self.if_correct = if_correct
        self.if_wrong = if_wrong

with open(sys.argv[1], "rb") as h:
    labels = [
        Label('A_{}'.format(index), ca, ch, Instruction[gu], ic, iw)
        for index, (ca, ch, gu, ic, iw) in enumerate(pickle.load(h))
    ]

def label_by_index(index):
    if index is None:
        return Label('A_FALLBACK')
    return labels[index]


# Write the output file
print('''\
// Auto-generated by gen-specializer - DO NOT EDIT.
// Run the virtual machine.

#include "config.h"

#include <assert.h>
#include <stdio.h>

#include "mit/mit.h"
#include "mit/features.h"

#define RAISE(code)                                           \\
    do {                                                      \\
        res = (code);                                         \\
        S->PC = initial_PC;                                   \\
        S->I = initial_I;                                     \\
        goto RET;                                             \\
    } while (0)

#define NEXT                                                  \\
    do {                                                      \\
        int ret = load(S, S->PC, MIT_SIZE_WORD, (mit_word *)&(S->I)); \\
        if (ret != 0)                                         \\
            RAISE(ret);                                       \\
        S->PC += MIT_WORD_BYTES;                              \\
    } while (0)

#define FETCH                                                 \\
    do {                                                      \\
        initial_PC = S->PC;                                   \\
        initial_I = S->I;                                     \\
        opcode = S->I & MIT_INSTRUCTION_MASK;                 \\
        S->I >>= MIT_INSTRUCTION_BIT;                         \\
    } while (0)

mit_word mit_specializer_run(mit_state * restrict S) {
    int res = MIT_ERROR_OK;''')

# Declare stack cache variables.
max_cached_depth = max(label.cached_depth for label in labels)
if max_cached_depth > 0:
    print('''\
    mit_word {};'''.format(
        ', '.join(
            CacheState.var_for_depth(pos, max_cached_depth)
            for pos in reversed(range(max_cached_depth))
        )
    ))

print('''\
    do {
        mit_uword initial_PC, initial_I;
        // The number of stack items cached in C variables.
        mit_uword cached_depth = 0;
        mit_byte opcode;

        FETCH;
        goto A_0;

        // Each A_XXX label has an expectation of what instruction sequence
        // probably comes next. If correct, there is a fast path for executing
        // that sequence, otherwise we fall back on a slow path with broader
        // expectations. Ultimately, we fall back to `A_FALLBACK` which calls
        // `smite_single_step()` to handle corner cases.
        //
        // The calling convention at each A_XXX label is as follows:
        //
        //  - On entry, `res` is `MIT_ERROR_OK`, `opcode` is the next opcode,
        //    and `I` has been right-shifted.
        //  - When an error occurs, call `RAISE(code)`.
        //    It sets `res` to the return code; then it resets PC and
        //    I to their initial values, and does "goto RET".
        //  - "goto RET" (but do not "return") at any time after completely
        //    executing at least one instruction, or never.
        //  - On exit, whether by `RAISE` or otherwise, all Mit
        //    registers must be set according to the Mit spec. In particular,
        //    there must be no side effects before a RAISE, except for the
        //    effects on STACK_DEPTH and PC described above.
        //    In addition, `cached_depth` must be set correctly.
''')

for label in labels:
    print('''\
    {label_name}:
        assert(res == MIT_ERROR_OK);
        assert(cached_depth == {cached_depth});
        if (opcode == O_{guess_name}) {{'''.format(
        label_name=label.name,
        cached_depth=label.cached_depth,
        guess_name=label.guess.name,
    ))
    # For a terminal instruction, check `I` is 0.
    if label.guess.terminal:
        print('    if (S->I != 0) goto A_FALLBACK;')
    # If correct.
    label_c = label_by_index(label.if_correct)
    print(textwrap.indent(
        gen_case(
            label.guess,
            CacheState(label.cached_depth),
            label_c.cached_depth,
        ),
        '            ',
    ))
    print('''\
            FETCH;
            goto {};
        }}'''.format(label_c.name)
    )
    # If wrong.
    label_w = label_by_index(label.if_wrong)
    print(textwrap.indent(
        CacheState(label.cached_depth).flush(label_w.cached_depth),
        '        ',
    ))
    print('''\
        goto {};'''.format(label_w.name)
    )
    print()

print('''\
    A_FALLBACK:
        assert(res == MIT_ERROR_OK);
        assert(cached_depth == 0);
        S->PC = initial_PC;
        S->I = initial_I;
        res = mit_single_step(S);
        continue;

    RET:
        switch (cached_depth) {'''
)
cache_state = CacheState(max_cached_depth)
while cache_state.depth > 0:
    print('''\
        case {}:'''.format(cache_state.depth)
    )
    print(textwrap.indent(
        cache_state.flush(cache_state.depth - 1),
        '            ',
    ))
    print('''\
            // Falls through.'''
    )
print('''\
        case 0:
            break;
        default:
            assert(0); // Unreachable.
        }
    } while (res == MIT_ERROR_OK);
    return res;
}''')
