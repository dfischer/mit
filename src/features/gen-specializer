#!/usr/bin/env python3
# Generate code for instructions.
#
# (c) Mit authors 1994-2019
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

import sys, pickle, textwrap

from mit_core.code_buffer import Code
from mit_core.vm_data import Instruction
from specializer import gen_case, CacheState


# Load language.
if len(sys.argv) != 2:
    print("Usage: gen-specializer LABELS-FILE", file=sys.stderr)
    sys.exit(1)

class Label:
    '''
     - name - str - The C identifier of this Label.
     - tos_constant - int - the constant at the top of the stack at this
       Label, or `None` if the top stack item is not known to be constant.
     - cached_depth - int - the number of stack items that are cached in C
       variables at this Label.
     - checked_depth - int - the number of empty stack slots that are known to
       exist above the top of the stack at this Label.
     - guess - Instruction - the most probable next instruction.
     - if_correct - int - the Label index to jump to if `guess` is correct.
     - if_wrong - int - the Label index to jump to if `guess` is wrong.
    '''
    def __init__(
        self,
        name,
        tos_constant=None,
        cached_depth=0,
        checked_depth=0,
        guess=None,
        if_correct=None,
        if_wrong=None,
    ):
        self.name = name
        self.tos_constant = tos_constant
        self.cached_depth = cached_depth
        self.checked_depth = checked_depth
        self.guess = guess
        self.if_correct = if_correct
        self.if_wrong = if_wrong

    def cache_state(self):
        '''Returns a fresh CacheState describing this Label.'''
        return CacheState(self.cached_depth, self.checked_depth)

    def goto(self, cache_state):
        '''
        Returns a Code to jump to this Label.
         - cache_state - The CacheState before the goto. This method generates
           code to flush the cache to meet the expectations at this Label.
        '''
        code = Code()
        code.extend(cache_state.flush(self.cache_state()))
        code.append('goto {};'.format(self.name))
        return code

    def generate_code(self):
        '''
        Returns a Code to place at this Label.
        Also returns the peak value of `CacheState.cached_depth`.
        '''
        code = Code()
        code.append('assert(res == MIT_ERROR_OK);')
        code.append('assert(cached_depth == {cached_depth});'.format(
            cached_depth=label.cached_depth,
        ))
        if label.tos_constant is not None:
            code.append('assert({tos} == {tos_constant});'.format(
                tos=label.cache_state().var(0),
                tos_constant=label.tos_constant,
            ))
        opcode = 'initial_I'
        if not label.guess.terminal:
            opcode = '({} & MIT_INSTRUCTION_MASK)'.format(opcode)
        code.append('if ({opcode} == O_{guess_name}) {{'.format(
            opcode=opcode,
            guess_name=label.guess.name,
        ))
        # If correct.
        if_code = Code()
        cache_state = label.cache_state()
        if_code.extend(gen_case(label.guess, cache_state))
        cached_depth = cache_state.cached_depth # Returned.
        if_code.append('FETCH;')
        if_code.extend(label_by_index(label.if_correct).goto(cache_state))
        code.append(if_code)
        code.append('}')
        # If wrong.
        cache_state = label.cache_state()
        code.extend(label_by_index(label.if_wrong).goto(cache_state))
        return (code, cached_depth)


with open(sys.argv[1], "rb") as h:
    labels = [
        Label('A_{}'.format(index), tos, ca, ch, Instruction[gu], ic, iw)
        for index, (tos, ca, ch, gu, ic, iw) in enumerate(pickle.load(h))
    ]

def label_by_index(index):
    if index is None:
        return Label('A_FALLBACK')
    return labels[index]


# Generate the code for the labels first, so as to compute `max_cached_depth`.
labels_code = Code()
max_cached_depth = 0
for label in labels:
    labels_code.append('')
    labels_code.append('{label_name}:'.format(label_name=label.name))
    label_code, cached_depth = label.generate_code()
    labels_code.append(label_code)
    max_cached_depth = max(max_cached_depth, cached_depth)
labels_code.append('')
labels_code.append('''\
    A_FALLBACK:
        assert(res == MIT_ERROR_OK);
        assert(cached_depth == 0);
        S->PC = initial_PC;
        S->I = initial_I;
        res = mit_single_step(S);
        continue;

    RET:
        switch (cached_depth) {
''')
switch_code = Code()
cache_state = CacheState(max_cached_depth, 0)
while cache_state.cached_depth > 0:
    switch_code.append('case {}:'.format(cache_state.cached_depth))
    case_code = Code()
    case_code.extend(cache_state.flush(cache_state.cached_depth - 1))
    case_code.append('// Falls through.')
    switch_code.append(case_code)
switch_code.append('''\
    case 0:
        break;
    default:
        assert(0); // Unreachable.
    }
''')
labels_code.append(switch_code)

# Construct a Code for the function body, copying `labels_code`.
body_code = Code()
body_code.append('int res = MIT_ERROR_OK;')
if max_cached_depth > 0:
    body_code.append('mit_word {};'.format(
        ', '.join(
            CacheState.var_for_depth(pos, max_cached_depth)
            for pos in reversed(range(max_cached_depth))
        )
    ))
body_code.append('do {')
body_code.append(Code('''\
    mit_uword initial_PC, initial_I;
    // The number of stack items cached in C variables.
    int cached_depth = 0;

    FETCH;
    goto A_0;

    // Each A_XXX label has an expectation of what instruction sequence
    // probably comes next. If correct, there is a fast path for executing
    // that sequence, otherwise we fall back on a slow path with broader
    // expectations. Ultimately, we fall back to `A_FALLBACK` which calls
    // `smite_single_step()` to handle corner cases.
    //
    // The calling convention at each A_XXX label is as follows:
    //
    //  - On entry, `res` is `MIT_ERROR_OK` and `I` has been right-shifted.
    //    `initial_PC` and `initial_I` record the values of `PC` and `I` to
    //    restore on error. `cached_depth` is a compile-time constant
    //    indicating how many top stack items are in C variables.
    //  - When an error occurs, call `RAISE(code)`.
    //    It sets `res` to the return code; then it resets PC and
    //    I to their initial values, and does "goto RET".
    //  - "goto RET" (but do not "return") at any time after completely
    //    executing at least one instruction, or never. `cached_depth` and
    //    `S->STACK_DEPTH` must be correct at that time.
    //  - On exit, whether by `RAISE` or otherwise, all Mit
    //    registers must be set according to the Mit spec. In particular,
    //    there must be no side effects before a RAISE, except on `I` and
    //    `PC`, which will be reset as described above.
'''))
body_code.extend(labels_code)
body_code.append('''\
    } while (res == MIT_ERROR_OK);
    return res;
''')


# Generate the code for the entire source file, incorporating `body_code`.
code = Code()
code.append('''\
    // Auto-generated by gen-specializer - DO NOT EDIT.
    // Run the virtual machine.

    #include "config.h"

    #include <assert.h>
    #include <stdio.h>

    #include "mit/mit.h"
    #include "mit/features.h"

    #define RAISE(code)                                           \\
        do {                                                      \\
            res = (code);                                         \\
            S->PC = initial_PC;                                   \\
            S->I = initial_I;                                     \\
            goto RET;                                             \\
        } while (0)

    #define NEXT                                                  \\
        do {                                                      \\
            int ret = load(S, S->PC, MIT_SIZE_WORD, (mit_word *)&(S->I)); \\
            if (ret != 0)                                         \\
                RAISE(ret);                                       \\
            S->PC += MIT_WORD_BYTES;                              \\
        } while (0)

    #define FETCH                                                 \\
        do {                                                      \\
            initial_PC = S->PC;                                   \\
            initial_I = S->I;                                     \\
            S->I >>= MIT_INSTRUCTION_BIT;                         \\
        } while (0)

    mit_word mit_specializer_run(mit_state * restrict S) {
''')
code.append(body_code)
code.append('}')

print(code.unindented_str())
