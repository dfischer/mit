#!/usr/bin/env python3
# Generate front-end.
#
# Copyright (c) 1995-2019 SMite authors
#
# The package is distributed under the MIT/X11 License.
#
# THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
# RISK.

import os
import sys
import textwrap


# Command-line options

features = []
class Feature:
    def __init__(self):
        features.append(self)
    
# These are processed in the order given. The files under feature/
# start with a two-digit number to allow them to be ordered.

class Doc(Feature):
    '''
    Free-form documentation.

     - text - str
    '''
    def __init__(self, text):
        super().__init__()
        self.text = text

class Option(Feature):
    '''
    A command-line option/feature.
    
     - long_name - str - long option name
     - short_name - str - short option char
     - arg - str - 'no_argument', 'required_argument' or 'optional_argument'
     - arg_name - str - name for the argument, if any
     - top_level_code - str - additional top-level code for the option
     - init_code - str - code run on program start-up
     - parse_code - str - code run when the option is parsed
     - exception_handler - str - cases added to the exception handler
    '''
    def __init__(self, long_name, docstring, short_name=None,
                 arg=None, arg_name=None,
                 top_level_code=None, init_code=None, parse_code=None,
                 exception_handler=None):
        super().__init__()
        self.long_name = long_name
        self.short_name = short_name
        self.arg = arg or 'no_argument'
        self.arg_name = arg_name
        self.docstring = docstring
        self.top_level_code = top_level_code
        self.init_code = init_code
        self.parse_code = parse_code
        self.exception_handler = exception_handler

class Arg(Feature):
    '''
    A command-line argument.

     - arg - str - argument name
     - docstring - str - argument docstring
    '''
    def __init__(self, arg, docstring):
        self.arg = arg
        self.docstring = docstring


# Build feature list
dir = sys.argv[1]
for file in sorted(os.listdir(sys.argv[1])):
    exec(open(os.path.join(dir, file)).read())


# Generate output

print('''\
// Auto-generated by gen-main - DO NOT EDIT.

// Front-end.

#include "config.h"

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <getopt.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>

#include "progname.h"

#include "smite.h"


static _GL_ATTRIBUTE_FORMAT_PRINTF(1, 0) void verror(const char *format, va_list args)
{
    fprintf(stderr, PACKAGE ": ");
    vfprintf(stderr, format, args);
    fprintf(stderr, "\\n");
}

static _GL_ATTRIBUTE_FORMAT_PRINTF(1, 2) void warn(const char *format, ...)
{
    va_list args;

    va_start(args, format);
    verror(format, args);
}

static _GL_ATTRIBUTE_FORMAT_PRINTF(1, 2) void die(const char *format, ...)
{
    va_list args;

    va_start(args, format);
    verror(format, args);
    exit(1);
}
''')

print('''\
// Options table
struct option longopts[] = {''')
for feature in features:
    if isinstance(feature, Option):
        print('    {{"{long_name}", {arg}, NULL, \'{short_name}\'}},'.format(
            long_name=feature.long_name, arg=feature.arg or '""',
            short_name=feature.short_name or "\\0"))
print('''\
    {0, 0, 0, 0}
};''')

print('''
static void usage(void)
{
    printf("Usage: %s [OPTION...] [OBJECT-FILE ARGUMENT...]\\n"
           "\\n"
           "Run " PACKAGE_NAME ".\\n"
           "\\n",
           program_name);''')

for feature in features:
    if isinstance(feature, Option):
        print('    printf("  %-26s%s\\n", "--{long_name}{short_opt} {arg_name}", "{docstring}");'.format(
            long_name=feature.long_name,
            short_opt=', -{}'.format(feature.short_name) if feature.short_name else '',
            arg_name=feature.arg_name or '',
            docstring=feature.docstring,
        ))
    elif isinstance(feature, Arg):
        print('printf("  %-26s%s\\n", {arg}, {docstring});'.format(
            arg=feature.arg,
            docstring=feature.docstring
        ))
    elif isinstance(feature, Doc):
        print('    printf("{}\\n");'.format(feature.text))

print('''
    exit(EXIT_SUCCESS);
}

static smite_state *S;

static void exit_function(void)
{
    smite_destroy(S);
}''')

for feature in features:
    if isinstance(feature, Option) and feature.top_level_code:
        print(feature.top_level_code)

print('''

int main(int argc, char *argv[])
{
    set_program_name(argv[0]);
    smite_WORD (*run_fn)(smite_state *) = smite_run;
''')

index = 0
for feature in features:
    if isinstance(feature, Option):
        if feature.init_code:
            print(textwrap.indent(feature.init_code, '    '))
        index += 1

shortopts = ''
for feature in features:
    if isinstance(feature, Option) and feature.short_name:
        shortopts += feature.short_name
        if feature.arg == 'required_argument':
            shortopts += ':'
        elif feature.arg == 'optional_argument':
            shortopts += '::'
print('''\
    // Options string starts with '+' to stop option processing at first
    // non-option, then leading ':' so as to return ':' for a missing arg,
    // not '?'
    const char *shortopts = "+:{}";'''.format(shortopts))

print('''
    for (;;) {
        int this_optind = optind ? optind : 1, longindex = -1;
        int c = getopt_long(argc, argv, shortopts, longopts, &longindex);

        if (c == -1)
            break;
        else if (c == ':')
            die("option '%s' requires an argument", argv[this_optind]);
        else if (c == '?')
            die("unrecognised option '%s'\\nTry '%s --help' for more information.", argv[this_optind], program_name);
''')

index = 0
for feature in features:
    if isinstance(feature, Option):
        if feature.short_name:
            print('''\
        if (c == '{short_name}')
            longindex = {index};
'''.format(
    short_name = feature.short_name,
    index = index
))
        index += 1

index = 0
for feature in features:
    if isinstance(feature, Option):
        if feature.parse_code:
            print('        if (longindex == {})\n'.format(index) +
                  textwrap.indent(feature.parse_code, '            '))
        index += 1

print ('    }\n')
        
print('''\
    // If invoked without an object file, give usage message and exit
    argc -= optind;
    if (argc < 1)
        usage();

    // Set up VM
    S = smite_init(memory_size, stack_size);
    if (S == NULL)
        die("could not allocate virtual machine state");
    if (atexit(exit_function) != 0)
        die("could not register atexit handler");
    if (smite_register_args(S, argc, argv + optind) != 0)
        die("could not register command-line arguments");

    // Load object file and report any error
    int fd = open(argv[optind], O_RDONLY);
    if (fd < 0)
        die("cannot not open file %s", argv[optind]);
    int ret = smite_load_object(S, 0, fd);
    close(fd);
    const char *err = NULL;
    if (ret < 0)
        switch (ret) {
        case -1:
            err = "file system error";
            break;
        case -2:
            err = "module invalid";
            break;
        case -3:
            err = "module has wrong ENDISM or WORD_BYTES";
            break;
        case -4:
            err = "address out of range or unaligned, or module too large";
            break;
        default:
            err = "unknown error!";
            break;
        }
    if (err != NULL)
        die("%s: %s", argv[optind], err);
''')

print('''\
    // Run
    for (;;) {
        int res = run_fn(S);
        switch (res) {''')

for feature in features:
    if isinstance(feature, Option) and feature.exception_handler:
        print(textwrap.indent(feature.exception_handler, '        '))

print('''\
        }
        return res == 128 ? 0 : res;
    }
}''')
