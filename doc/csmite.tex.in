%
% Documentation for C @PACKAGE_NAME@
%
% Reuben Thomas
%
% Started 1/12/94-8/5/95
%

\documentclass{article}
\usepackage[british]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{a4,newpxtext,booktabs,hyperref,siunitx,titlesec}


% Add an extra level of sections
\setcounter{secnumdepth}{4}
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}


% Macros

% Lay out an external interface call

\newlength{\ifacewidth}\ifacewidth=\textwidth \advance\ifacewidth by -0.1in
\newlength{\innerwidth}\innerwidth=\ifacewidth \advance\innerwidth by -0.5in
\newcommand{\ifacec}[2]{\item[]\parbox{\ifacewidth}{\hspace*{2.5mm}{\tt #1}\\[0.5ex]\hspace*{0.4in}\parbox{\innerwidth}{#2}}}

% Font for stack pictures; macro \spic includes italic correction

\newfont{\spfont}{cmsltt10 scaled 1000}
\newcommand{\spic}[1]{{\spfont\setlength{\baselineskip}{\normalbaselineskip}#1\/}}

% Common stack items

\newcommand{\U}[1]{\spic{u$_{#1}$}}
\newcommand{\aaddr}[1]{\spic{a-addr$_{#1}$}}
\newcommand{\naddr}[1]{\spic{n-addr$_{#1}$}}


\title{An implementation of the @PACKAGE_NAME@ virtual machine\\for POSIX\\version @VERSION@}
\author{Reuben Thomas}
\date{12th January 2019}

\begin{document}
\maketitle


\section{Introduction}

The @PACKAGE_NAME@ virtual machine~\cite{@PACKAGE@} provides a portable virtual machine environment for study and experiment. To this end, @PACKAGE_NAME@ is itself written in ISO C, since almost all systems have an ISO C compiler available for them.

As well as the virtual machine, C @PACKAGE_NAME@ provides a debugger, which is described in~\cite{@PACKAGE@uiface}.

The @PACKAGE_NAME@ virtual machine is described in~\cite{@PACKAGE@}. This paper only
describes the features specific to this implementation.


\section{Using C @PACKAGE_NAME@}

This section describes how to compile C @PACKAGE_NAME@, and the exact manner in which
the interface calls and @PACKAGE_NAME@'s memory and registers should be accessed.


\subsection{Configuration}
\label{configuration}

@PACKAGE_NAME@ is written in ISO C99 using POSIX-1.2001 APIs.

The @PACKAGE_NAME@ virtual machine is inherently 32-bit, but will run happily on systems with larger (or smaller) addresses.


\subsection{Compilation}

@PACKAGE_NAME@'s build system is written with GNU autotools, and the user
needs only standard POSIX utilities to run it. Installation
instructions are provided in the top-level file {\tt README.md}.


\subsection{Registers and memory}

@PACKAGE_NAME@'s registers are declared in {\tt @PACKAGE@.h}. Their names correspond to
those given in~\cite[section~2.1]{@PACKAGE@}, although some have been changed
to meet the rules for C identifiers. C @PACKAGE_NAME@ does not allocate any
memory for @PACKAGE_NAME@, nor does it initialise any of the registers. C @PACKAGE_NAME@
provides the interface call {\bf @PACKAGE@\_init()} to do this (see
section~\ref{usingcalls}).

The variables {\tt EP}, {\tt I}, {\tt A}, {\tt MEMORY}, {\tt SDEPTH}, {\tt RDEPTH}, {\tt HANDLER}, {\tt BADPC} and {\tt INVALID}
correspond exactly with the @PACKAGE_NAME@ registers they represent, and may be read
and assigned to accordingly, bearing in mind the restrictions on their use
given in~\cite{@PACKAGE@}. {\tt HANDLER}, {\tt BADPC} and {\tt INVALID} are mapped into @PACKAGE_NAME@'s memory, so they are automatically updated when the corresponding memory locations are written to, and vice versa.

C @PACKAGE_NAME@ provides the ability to map native memory blocks into @PACKAGE_NAME@’s address space; see below.

Two additional pseudo-registers are provided by C @PACKAGE_NAME@: they are
called {\tt S0} and {\tt R0}, and are the address of the base of the data and
return stacks respectively.


\subsection{Extra instructions}

C @PACKAGE_NAME@ provides some libraries of {\tt EXTRA} instruction functions, which are called in general as:

\begin{center}
\begin{tabular}{ll} \toprule
\bf Stack effect & \bf Description \\ \midrule
\spic{i*x u1 u2 -- j*x} & Call the \spic{u1}th function of library \spic{u2}, passing arguments {i*x}, with results \spic{j*x}. \\ \bottomrule
\end{tabular}
\end{center}

Exception~$-259$ is raised if an invalid library is accessed, and $-260$ for an invalid function in a known library.


\subsubsection{@PACKAGE_NAME@}

@PACKAGE_NAME@ provides access to its own API as library~$-1$. This allows the current state to be controlled, or fresh states to be created and controlled.

\begin{center}
\begin{tabular}{S[table-format=2.0]lll} \toprule
\bf Code & \bf Name & \bf Stack effect & \bf Description \\ \midrule
0x0 & {\tt CURRENT\_STATE} & \spic{-- n-addr} & a pointer to the current {\tt state} \\
0x1 & {\tt LOAD\_WORD} & \spic{n-addr a-addr -- x n} & \\
0x2 & {\tt STORE\_WORD} & \spic{n-addr a-addr x -- n} & \\
0x3 & {\tt LOAD\_BYTE} & \spic{n-addr addr x n} & \\
0x4 & {\tt STORE\_BYTE} & \spic{n-addr addr x -- n} & \\
0x5 & {\tt MEM\_REALLOC} & \spic{\naddr1 \naddr2 u f -- addr} & \\
0x6 & {\tt NATIVE\_ADDRESS} & \spic{\naddr1 addr f -- \naddr2} & \\
0x7 & {\tt RUN} & \spic{n-addr -- n} & \\
0x8 & {\tt SINGLE\_STEP} & \spic{n-addr -- n} & \\
0x9 & {\tt LOAD\_OBJECT} & \spic{n-addr fid addr -- n} & \\
0xa & {\tt INIT} & \spic{a-addr \U1 \U2 \U3 -- n-addr} & \\
0xb & {\tt DESTROY} & \spic{n-addr} & \\
0xc & {\tt REGISTER\_ARGS} & \spic{n-addr n-addr n -- n} & \\
\bottomrule
\end{tabular}
\end{center}


\subsubsection{Standard library}

Standard C runtime and library functionality is accessed via library~$0$.

\paragraph{Command-line arguments}

Two calls are provided to access command-line arguments passed to C @PACKAGE_NAME@ (excluding any that it interprets itself). They are copied from Gforth (\cite{gforth}).

\begin{center}
\begin{tabular}{S[table-format=2.0]lll} \toprule
\bf Code & \bf Name & \bf Stack effect & \bf Description \\ \midrule
0x0 & {\tt ARGC} & \spic{-- u} & the number of arguments \\
0x1 & {\tt ARG\_LEN} & \spic{u1 -- u2} & the length of the \spic{u1}th argument \\
0x2 & {\tt ARG\_COPY} & \spic{\U1 c-addr \U2 -- \U3} & copy argument \U1 to the buffer of length \U2 at \spic{c-addr}, leaving the number of characters actually copied as \U3 \\
 \bottomrule
\end{tabular}
\end{center}

\paragraph{Standard I/O streams}

These extra instructions provide access to POSIX standard input, output and error. Each call returns a corresponding file identifier.

\begin{center}
\begin{tabular}{S[table-format=2.0]l} \toprule
\bf Opcode & \bf POSIX file descriptor \\ \midrule
0x3 & {\tt STDIN\_FILENO} \\
0x4 & {\tt STDOUT\_FILENO} \\
0x5 & {\tt STDERR\_FILENO} \\ \bottomrule
\end{tabular}
\end{center}

\paragraph{File system}

The file system extra instructions correspond directly to ANS Forth words, as defined in~\cite{ANSIforth}.

\begin{center}
\begin{tabular}{S[table-format=2.0]l} \toprule
\bf Opcode & \bf Forth word \\ \midrule
0x6 & {\tt OPEN-FILE} \\
0x7 & {\tt CLOSE-FILE} \\
0x8 & {\tt READ-FILE} \\
0x9 & {\tt WRITE-FILE} \\
0xa & {\tt FILE-POSITION} \\
0xb & {\tt REPOSITION-FILE} \\
0xc & {\tt FLUSH-FILE} \\
0xd & {\tt RENAME-FILE} \\
0xe & {\tt DELETE-FILE} \\
0xf & {\tt FILE-SIZE} \\
0x10 & {\tt RESIZE-FILE} \\
0x11 & {\tt FILE-STATUS} \\
\bottomrule
\end{tabular}
\end{center}

The implementation-dependent word returned by {\tt FILE-STATUS} contains the POSIX protection bits, given by the {\tt st\_mode} member of the {\tt struct stat} returned for the given file descriptor.

File access methods are bit-masks, composed as follows:

\begin{center}
\begin{tabular}{cc} \toprule
\rule[-2mm]{0mm}{6mm}\bf Bit value & \bf Meaning \\ \midrule
1 & read \\
2 & write \\
4 & binary mode \\ \bottomrule
\end{tabular}
\end{center}

To create a file, set both read and write bits to zero when calling {\tt OPEN-FILE}.


\subsection{Using the interface calls}
\label{usingcalls}

The operation of the specified interface calls is given in~\cite{@PACKAGE@}. Here, the C prototypes corresponding to the idealised prototypes used in~\cite{@PACKAGE@} are given. The names are prefixed with {\bf @PACKAGE@\_}. The first argument to most routines is a {\tt @PACKAGE\_state *}, as returned by {\tt @PACKAGE@\_init}.

\begin{description}
\ifacec{uint8\_t *native\_address\_of\_range(@PACKAGE@\_state *state, @PACKAGE@\_UWORD address, @PACKAGE@\_UWORD length)}{Returns {\tt NULL} when the address range is not entirely valid.}
\ifacec{@PACKAGE@\_state *state, @PACKAGE@\_WORD run(@PACKAGE@\_state *state)}{The reason code returned by {\bf @PACKAGE@\_run()} is a @PACKAGE_NAME@
word.}
\ifacec{@PACKAGE@\_state *state, @PACKAGE@\_WORD @PACKAGE@\_single\_step(@PACKAGE@\_state *state)}{The reason code returned by {\bf @PACKAGE@\_single\_step()}
is a @PACKAGE_NAME@ word.}
\ifacec{int @PACKAGE@\_load\_object(@PACKAGE@\_state *state, int fd, @PACKAGE@\_UWORD address)}{If a file system error
occurs, the return code is $-3$. If the endism of the object file does not match {\tt ENDISM}, the return code is $-4$. If the word size of the object file is not {\tt WORD\_SIZE}, the return code is $-5$. As an extension to the specification, if an object file starts with the bytes $35$, $33$ (\texttt{\#!}), then it is assumed to be the start of a UNIX-style “hash bang” line, and the file contents up to and including the first newline character ($10$) is ignored.}
\end{description}

In addition to the required interface calls C @PACKAGE_NAME@ provides an initialisation routine {\bf @PACKAGE@\_init()} which, given a word array and its size, initialises @PACKAGE_NAME@:

\begin{description}
\ifacec{@PACKAGE@\_state *@PACKAGE@\_init(size\_t memory\_size, size\_t data\_stack\_size, size\_t return\_stack\_size)}{{\tt memory\_size} is
the size of {\tt b\_array} in {\em words} (not bytes); similarly, {\tt data\_stack\_size} and {\tt return\_stack\_size} give the size of the stacks in words; these are allocated by {\tt @PACKAGE@\_init}. The return value is {\tt NULL} if memory cannot be allocated, and a pointer to a new state otherwise.
All the registers are initialised as per~\cite{@PACKAGE@}.}
\ifacec{int @PACKAGE@\_mem\_realloc(@PACKAGE@\_state *state, @PACKAGE@\_UWORD size)}{Resize the memory to the given {\tt size}. Any new memory is zeroed. Returns $0$ on success or $-1$ if the requested size of memory cannot be allocated.}
\end{description}

The following routines give easier access to @PACKAGE_NAME@’s address space at the byte and word level. On success, they return $0$, and on failure, the relevant exception code.

\begin{description}
\ifacec{int @PACKAGE@\_load\_word(@PACKAGE@\_state *state, @PACKAGE@\_UWORD address, @PACKAGE@\_WORD *value)}{Load the word at the given address into the given {\tt @PACKAGE@\_WORD *}.}
\ifacec{int @PACKAGE@\_store\_word(@PACKAGE@\_state *state, @PACKAGE@\_UWORD address, @PACKAGE@\_WORD value)}{Store the given {\tt WORD} value at the given address.}
\ifacec{int @PACKAGE@\_load\_byte(@PACKAGE@\_state *state, @PACKAGE@\_UWORD address, @PACKAGE@\_BYTE *value)}{Load the byte at the given address into the given {\tt @PACKAGE@\_BYTE *}.}
\ifacec{int @PACKAGE@\_store\_byte(@PACKAGE@\_state *state, @PACKAGE@\_UWORD address, @PACKAGE@\_BYTE value)}{Store the given {\tt @PACKAGE@\_BYTE} value at the given address.}
\end{description}

The following routines give access to @PACKAGE_NAME@’s stacks. On success, they return $0$, and on failure, the relevant exception code.

\begin{description}
\ifacec{int @PACKAGE@\_load\_stack(@PACKAGE@\_state *state, @PACKAGE@\_UWORD pos, @PACKAGE@\_WORD *value)}{Load the word at the given position of the data stack into the given {\tt @PACKAGE@\_WORD *}.}
\ifacec{int @PACKAGE@\_store\_stack(@PACKAGE@\_state *state, @PACKAGE@\_UWORD pos, @PACKAGE@\_WORD value)}{Store the given {\tt WORD} value at the given position in the data stack.}
\ifacec{int @PACKAGE@\_pop\_stack(@PACKAGE@\_state *state, @PACKAGE@\_WORD *value)}{Pop the top word off the data stack, decrementing its depth, into the given {\tt @PACKAGE@\_WORD *}.}
\ifacec{int @PACKAGE@\_push\_stack(@PACKAGE@\_state *state, @PACKAGE@\_WORD value)}{Push the given {\tt @PACKAGE@\_WORD} value on to the data stack of the given size, incrementing its depth.}
\ifacec{int @PACKAGE@\_load\_return\_stack(@PACKAGE@\_state *state, @PACKAGE@\_UWORD pos, @PACKAGE@\_WORD *value)}{Load the word at the given position of the return stack into the given {\tt @PACKAGE@\_WORD *}.}
\ifacec{int @PACKAGE@\_store\_return\_stack(@PACKAGE@\_state *state, @PACKAGE@\_UWORD pos, @PACKAGE@\_WORD value)}{Store the given {\tt WORD} value at the given position in the return stack.}
\ifacec{int @PACKAGE@\_pop\_return\_stack(@PACKAGE@\_state *state, @PACKAGE@\_WORD *value)}{Pop the top word off the return stack, decrementing its depth, into the given {\tt @PACKAGE@\_WORD *}.}
\ifacec{int @PACKAGE@\_push\_return\_stack(@PACKAGE@\_state *state, @PACKAGE@\_WORD value)}{Push the given {\tt @PACKAGE@\_WORD} value on to the return stack of the given size, incrementing its depth.}
\end{description}

The following routine allows the calling program to register command-line arguments that can be retrieved by the {\tt ARGC} and {\tt ARG\_COPY} extra instructions.

\begin{description}
\ifacec{int @PACKAGE@\_register\_args(@PACKAGE@\_state *state, int argc, char *argv[])}{Maps the given arguments register, which has the same format as that supplied to {\bf main()}, into @PACKAGE_NAME@’s memory. Returns $0$ on success and $-1$ if memory could not be allocated, or $-2$ if an argument could not be mapped to @PACKAGE_NAME@’s address space.}
\end{description}

Programs which use C @PACKAGE_NAME@'s interface must {\tt \#include} the header file
{\tt @PACKAGE@.h} and be linked with the @PACKAGE_NAME@ library. {\tt
@PACKAGE@\_opcodes.h}, which contains an enumeration type of @PACKAGE_NAME@'s instruction set,
and {\tt @PACKAGE@\_debug.h}, which contains useful debugging functions such as
disassembly, may also be useful; they are not documented here.


\subsection{Other extras provided by C @PACKAGE_NAME@}

C @PACKAGE_NAME@ provides various useful extras in {\tt @PACKAGE@\_aux.h}. These are used internally, and are thought to be useful, but may change at any time, so their stability should not be relied on.


\bibliographystyle{plain}
\bibliography{vm,rrt,ertl}


\end{document}
