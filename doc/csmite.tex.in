%
% Documentation for C @PACKAGE_NAME@
%
% Reuben Thomas
%
% Started 1/12/94-8/5/95
%

\documentclass{article}
\usepackage[british]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{a4,newpxtext,booktabs,hyperref,siunitx}


% Macros

% Lay out an external interface call

\newlength{\ifacewidth}\ifacewidth=\textwidth \advance\ifacewidth by -0.1in
\newlength{\innerwidth}\innerwidth=\ifacewidth \advance\innerwidth by -0.5in
\newcommand{\ifacec}[2]{\item[]\parbox{\ifacewidth}{\hspace*{2.5mm}{\tt #1}\\[0.5ex]\hspace*{0.4in}\parbox{\innerwidth}{#2}}}

% Font for stack pictures; macro \spic includes italic correction

\newfont{\spfont}{cmsltt10 scaled 1000}
\newcommand{\spic}[1]{{\spfont\setlength{\baselineskip}{\normalbaselineskip}#1\/}}


\title{An implementation of the @PACKAGE_NAME@ virtual machine\\for POSIX\\version @VERSION@}
\author{Reuben Thomas}
\date{27th May 2018}

\begin{document}
\maketitle


\section{Introduction}

The @PACKAGE_NAME@ virtual machine~\cite{@PACKAGE@} provides a portable virtual machine environment for study and experiment. To this end, @PACKAGE_NAME@ is itself written in ISO C, since almost all systems have an ISO C compiler available for them.

As well as the virtual machine, C @PACKAGE_NAME@ provides a debugger, which is described in~\cite{@PACKAGE@uiface}.

The @PACKAGE_NAME@ virtual machine is described in~\cite{@PACKAGE@}. This paper only
describes the features specific to this implementation.


\section{Using C @PACKAGE_NAME@}

This section describes how to compile C @PACKAGE_NAME@, and the exact manner in which
the interface calls and @PACKAGE_NAME@'s memory and registers should be accessed.


\subsection{Configuration}
\label{configuration}

@PACKAGE_NAME@ is written in ISO C99 using POSIX-1.2001 APIs.

The @PACKAGE_NAME@ virtual machine is inherently 32-bit, but will run happily on systems with larger (or smaller) addresses.


\subsection{Compilation}

@PACKAGE_NAME@'s build system is written with GNU autotools, and the user
needs only standard POSIX utilities to run it. Installation
instructions are provided in the top-level file {\tt README.md}.


\subsection{Registers and memory}

@PACKAGE_NAME@'s registers are declared in {\tt @PACKAGE@.h}. Their names correspond to
those given in~\cite[section~2.1]{@PACKAGE@}, although some have been changed
to meet the rules for C identifiers. C @PACKAGE_NAME@ does not allocate any
memory for @PACKAGE_NAME@, nor does it initialise any of the registers. C @PACKAGE_NAME@
provides the interface call {\bf @PACKAGE@\_init()} to do this (see
section~\ref{usingcalls}).

The variables {\tt EP}, {\tt I}, {\tt A}, {\tt MEMORY}, {\tt SP}, {\tt RP}, {\tt HANDLER}, {\tt BADPC} and {\tt INVALID}
correspond exactly with the @PACKAGE_NAME@ registers they represent, and may be read
and assigned to accordingly, bearing in mind the restrictions on their use
given in~\cite{@PACKAGE@}. {\tt HANDLER}, {\tt BADPC} and {\tt INVALID} are mapped into @PACKAGE_NAME@'s memory, so they are automatically updated when the corresponding memory locations are written to, and vice versa.

C @PACKAGE_NAME@ provides the ability to map native memory blocks into @PACKAGE_NAME@’s address space; see below.


\subsection{Extra instructions}

C @PACKAGE_NAME@ provides the following extra instructions. They are accessed by executing {\tt CALL\_NATIVE} with address $0$, and the given code as the top-most argument (under the address).

\subsubsection{Command-line arguments}

Two calls are provided to access command-line arguments passed to C @PACKAGE_NAME@ (excluding any that it interprets itself). They are copied from Gforth (\cite{gforth}).

\begin{center}
\begin{tabular}{S[table-format=2.0]lll} \toprule
\bf Code & \bf Name & \bf Stack effect & \bf Description \\ \midrule
0x0 & {\tt ARGC} & \spic{-- u} & the number of arguments \\
0x1 & {\tt ARG} & \spic{u1 -- c-addr u2} & the \spic{u1}th argument \\ \bottomrule
\end{tabular}
\end{center}

\subsubsection{Standard I/O streams}

These extra instructions provide access to POSIX standard input, output and error. Each call returns a corresponding file identifier.

\begin{center}
\begin{tabular}{S[table-format=2.0]l} \toprule
\bf Opcode & \bf POSIX file descriptor \\ \midrule
0x2 & {\tt STDIN\_FILENO} \\
0x3 & {\tt STDOUT\_FILENO} \\
0x4 & {\tt STDERR\_FILENO} \\ \bottomrule
\end{tabular}
\end{center}

\subsubsection{File system}

The file system extra instructions correspond directly to ANS Forth words, as defined in~\cite{ANSIforth}.

\begin{center}
\begin{tabular}{S[table-format=2.0]l} \toprule
\bf Opcode & \bf Forth word \\ \midrule
0x5 & {\tt OPEN-FILE} \\
0x6 & {\tt CLOSE-FILE} \\
0x7 & {\tt READ-FILE} \\
0x8 & {\tt WRITE-FILE} \\
0x9 & {\tt FILE-POSITION} \\
0xa & {\tt REPOSITION-FILE} \\
0xb & {\tt FLUSH-FILE} \\
0xc & {\tt RENAME-FILE} \\
0xd & {\tt DELETE-FILE} \\
0xe & {\tt FILE-SIZE} \\
0xf & {\tt RESIZE-FILE} \\
0x10 & {\tt FILE-STATUS} \\
\bottomrule
\end{tabular}
\end{center}

The implementation-dependent word returned by {\tt FILE-STATUS} contains the POSIX protection bits, given by the {\tt st\_mode} member of the {\tt struct stat} returned for the given file descriptor.

File access methods are bit-masks, composed as follows:

\begin{center}
\begin{tabular}{cc} \toprule
\rule[-2mm]{0mm}{6mm}\bf Bit value & \bf Meaning \\ \midrule
1 & read \\
2 & write \\
4 & binary mode \\ \bottomrule
\end{tabular}
\end{center}

To create a file, set both read and write bits to zero when calling {\tt OPEN-FILE}.


\subsection{Using the interface calls}
\label{usingcalls}

The operation of the specified interface calls is given in~\cite{@PACKAGE@}. Here, the C prototypes corresponding to the idealised prototypes used in~\cite{@PACKAGE@} are given. The names are prefixed with {\bf @PACKAGE@\_}. The first argument to most routines is a {\tt @PACKAGE\_state *}, as returned by {\tt @PACKAGE@\_init}.

Files to be loaded and saved are passed as C file descriptors. Thus, the
calling program must itself open and close the files.

\begin{description}
\ifacec{uint8\_t *native\_address(@PACKAGE@\_state *state, @PACKAGE@\_UWORD address, bool writable)}{Returns {\tt NULL} when the address is invalid, or the writable flag is true and the address is read-only.}
\ifacec{@PACKAGE@\_state *state, @PACKAGE@\_WORD run(@PACKAGE@\_state *state)}{The reason code returned by {\bf @PACKAGE@\_run()} is a @PACKAGE_NAME@
word.}
\ifacec{@PACKAGE@\_state *state, @PACKAGE@\_WORD @PACKAGE@\_single\_step(@PACKAGE@\_state *state)}{The reason code returned by {\bf @PACKAGE@\_single\_step()}
is a @PACKAGE_NAME@ word.}
\ifacec{int @PACKAGE@\_load\_object(@PACKAGE@\_state *state, FILE *file, @PACKAGE@\_UWORD address)}{If a file system error
occurs, the return code is $-3$. If the word size of the object file is not {\tt WORD\_SIZE}, the return code is $-4$. As an extension to the specification, if an object file starts with the bytes $35$, $33$ (\texttt{\#!}), then it is assumed to be the start of a UNIX-style “hash bang” line, and the file contents up to and including the first newline character ($10$) is ignored.}
\end{description}

In addition to the required interface calls C @PACKAGE_NAME@ provides an initialisation routine {\bf @PACKAGE@\_init()} which, given a word array and its size, initialises @PACKAGE_NAME@:

\begin{description}
\ifacec{@PACKAGE@\_state @PACKAGE@\_init(@PACKAGE@\_WORD *b\_array, size\_t memory\_size, size\_t data\_stack\_size, size\_t return\_stack\_size)}{{\tt memory\_size} is
the size of {\tt b\_array} in {\em words} (not bytes); similarly, {\tt data\_stack\_size} and {\tt return\_stack\_size} give the size of the stacks in words; these are allocated by {\tt @PACKAGE@\_init}. The return value is {\tt NULL} if {\tt b\_array} is {\tt NULL} or if memory cannot be allocated, and a pointer to a new state otherwise.
All the registers are initialised as per~\cite{@PACKAGE@}.}
\end{description}

The following routines give easier access to @PACKAGE_NAME@’s address space at the byte and word level. On success, they return $0$, and on failure, the relevant exception code.

\begin{description}
\ifacec{int @PACKAGE@\_load\_word(@PACKAGE@\_state *state, @PACKAGE@\_UWORD address, @PACKAGE@\_WORD *value)}{Load the word at the given address into the given {\tt @PACKAGE@\_WORD *}.}
\ifacec{int @PACKAGE@\_store\_word(@PACKAGE@\_state *state, @PACKAGE@\_UWORD address, @PACKAGE@\_WORD value)}{Store the given {\tt WORD} value at the given address.}
\ifacec{int @PACKAGE@\_load\_byte(@PACKAGE@\_state *state, @PACKAGE@\_UWORD address, @PACKAGE@\_BYTE *value)}{Load the byte at the given address into the given {\tt @PACKAGE@\_BYTE *}.}
\ifacec{int @PACKAGE@\_store\_byte(@PACKAGE@\_state *state, @PACKAGE@\_UWORD address, @PACKAGE@\_BYTE value)}{Store the given {\tt @PACKAGE@\_BYTE} value at the given address.}
\end{description}

The following routines give easier access to contiguous areas of @PACKAGE_NAME@’s address space. On success, $0$ is returned; if {\tt to} if not less than {\tt from}, or the addresses are not contained in the same area, or not writable if desired, $-1$ is returned; if either address is unaligned, or some other error occurs, a memory exception code is returned.

\begin{description}
\ifacec{int @PACKAGE@\_pre\_dma(@PACKAGE@\_state *state, @PACKAGE@\_UWORD from, @PACKAGE@\_UWORD to, bool write)}{Convert the given range to native byte order, so that it can be read (or written) directly.}
\ifacec{int @PACKAGE@\_post\_dma(@PACKAGE@\_state *state, @PACKAGE@\_UWORD from, @PACKAGE@\_UWORD to)}{Convert the given range to @PACKAGE_NAME@ byte order, so that it can be used by @PACKAGE_NAME@ after a direct access.}
\end{description}

The following routines are provided to map system memory to @PACKAGE_NAME@’s address space and vice versa:

\begin{description}
\ifacec{@PACKAGE@\_UWORD @PACKAGE@\_mem\_here(@PACKAGE@\_state *state)}{Returns the @PACKAGE_NAME@ address at which the next mapping will be made.}
\ifacec{@PACKAGE@\_UWORD @PACKAGE@\_mem\_allot(@PACKAGE@\_state *state, void *p, size\_t n)}{Map {\tt n} bytes pointed to by {\tt p} into @PACKAGE_NAME@’s address space, and return the address mapped. Addresses are mapped sequentially.}
\ifacec{@PACKAGE@\_UWORD @PACKAGE@\_mem\_align(@PACKAGE@\_state *state)}{Rounds up the address at which the next memory allocation will occur to the next word.}
\end{description}

The following routine allows the calling program to register command-line arguments that can be retrieved by the {\tt ARG} and {\tt ARGC} extra instructions.

\begin{description}
\ifacec{int @PACKAGE@\_register\_args(@PACKAGE@\_state *state, int argc, char *argv[])}{Maps the given arguments register, which has the same format as that supplied to {\bf main()}, into @PACKAGE_NAME@’s memory. Returns $0$ on success and $-1$ if memory could not be allocated, or $-2$ if an argument could not be mapped to @PACKAGE_NAME@’s address space.}
\end{description}

Programs which use C @PACKAGE_NAME@'s interface must {\tt \#include} the header file
{\tt @PACKAGE@.h} and be linked with the @PACKAGE_NAME@ library. {\tt
@PACKAGE@\_opcodes.h}, which contains an enumeration type of @PACKAGE_NAME@'s instruction set,
and {\tt @PACKAGE@\_debug.h}, which contains useful debugging functions such as
disassembly, may also be useful; they are not documented here.


\subsection{Other extras provided by C @PACKAGE_NAME@}

C @PACKAGE_NAME@ provides the following extra type in {\tt @PACKAGE@.h}
which is useful for programming with @PACKAGE_NAME@:

\begin{description}
\item[{\tt @PACKAGE@\_WORD\_pointer}:] a union with members {\tt @PACKAGE@\_WORD words[@PACKAGE@\_NATIVE\_POINTER\_SIZE]} and {\tt void (*pointer)(void)}, which allow a function pointer suitable for the {\tt CALL\_NATIVE} instruction to be easily stored and retrieved. It is assumed that the pointer is pushed on to the stack starting with {\tt words[0]} and ending with {\tt words[@PACKAGE@\_NATIVE\_POINTER\_SIZE~$-$~1]}.
\end{description}


\bibliographystyle{plain}
\bibliography{vm,rrt,ertl}


\end{document}
