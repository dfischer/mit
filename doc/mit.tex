% The definition of Mit (self-contained paper)
%
% (c) Reuben Thomas 1993-2020
% This file is in the public domain.

\documentclass[a4paper]{article}
\usepackage[british]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{newpxtext,booktabs,hyperref,bytefield,pbox}
\frenchspacing


% Macros for this document

% Font for stack pictures; macro \spic includes italic correction

\newcommand{\spic}[1]{\texttt{\textsl{#1\/}}}

% Common stack items

\newcommand{\x}[1]{\spic{x$_{#1}$}}
\newcommand{\n}[1]{\spic{s$_{#1}$}}
\newcommand{\U}[1]{\spic{u$_{#1}$}}
\newcommand{\noru}[1]{\spic{n$_#1$}}
\newcommand{\addr}[1]{\spic{addr$_{#1}$}}
\newcommand{\aaddr}[1]{\spic{a-addr$_{#1}$}}

% Lay out an instruction definition

% Define the widths of the stack effect and description columns
\newlength{\itemwidth}\itemwidth=\textwidth \advance\itemwidth by -0.1in
\newlength{\instname}\instname=0.8in
\newlength{\stackcom}\stackcom=3.7in

\newcommand{\inst}[3]{\item[]\parbox{\itemwidth}%
{\makebox[\instname][l]{\tt #1}%
\makebox[\stackcom][r]{\spic{#2}}\\[0.5ex]#3}}

% Lay out a line of the opcode table

% Tabular hex numerals
% From https://tex.stackexchange.com/questions/543464/tabular-hex-numerals/543466#543466
\usepackage{tokcycle}
\newsavebox\lettwd
\savebox\lettwd{{\ooalign{0\cr a\cr b\cr c\cr d\cr e\cr f}}}
\tokcycleenvironment\tblhex
  {\addcytoks{\makebox[\wd\lettwd]{##1}}}
  {\processtoks{##1}}
  {\addcytoks{##1}}
  {\addcytoks{\makebox[\wd\lettwd]{##1}}}

\newcommand{\opcodetbl}[4]{0x\tblhex#1\endtblhex & {\tt #2} & \tblhex0x#3\endtblhex & {\tt #4} \\}
\newcommand{\opcodetblone}[2]{0x#1 & {\tt #2} \\}

\newcommand{\extraopcodetbl}[2]{0x#1 & {\tt #2} \\}


\title{Mit virtual machine specification}
\author{Reuben Thomas}
\date{27th June 2020}

\begin{document}
\maketitle

\section{Introduction}

Mit is a simple virtual machine, designed to be both easy to implement efficiently on most widely-used hardware, and to compile for. It aims to be formally tractable. This specification is intended for those who wish to implement or program Mit.


\section{Parameters}

The virtual machine has the following parameters:

\begin{center}
\begin{tabular}{cp{3.25in}} \toprule
Endianness & Memory can be either big- or little-endian. \\
{\tt word\_bytes} & The number of bytes in a word, $4$ or $8$. \\
 \bottomrule
\end{tabular}
\end{center}


\section{Memory}

The flat linear address space contains {\tt word\_bytes}-byte words of $8$-bit bytes. Addresses range from $0$ to $2^{8\times{\tt word\_bytes}}-1$ inclusive and identify a byte; the address of a quantity is that of the byte in it with the lowest address. Whether a given word may be read or written can change during execution.


\section{Registers}
\label{registers}

The registers are word quantities:

\begin{center}
\begin{tabular}{cp{3.75in}} \toprule
\bf Register & \bf Function \\
 \midrule
{\tt pc} & The {\tt p}rogram {\tt c}ounter. Points to the next word from which {\tt ir} may be loaded. \\
{\tt ir} & The {\tt i}nstruction {\tt r}egister. Contains instructions to be executed. \\
 \bottomrule
\end{tabular}
\end{center}


\section{Computation stack}

Computation is performed with a last in, first out stack of words. The computation stack is usually referred to simply as “the stack”. To {\bf push} a word on to the stack means to add a new word to the top; to {\bf pop} a word means to discard the top item. Instructions implicitly pop their arguments and push their results.

{\bf Stack effects} are written

\begin{center}
  {\tt \spic{before → after}}
\end{center}

\noindent where \spic{before} and \spic{after} are stack pictures showing the items on top of the stack before and after the instruction is executed. An instruction only affects the items shown in its stack effect. A stack item \spic{[x]} in square brackets is optional.

{\bf Stack pictures}
represent the topmost stack items, and are written

\begin{center}
\spic{i$_n$ i$_{n-1}$\dots i$_2$ i$_1$}
\end{center}

\noindent where the \spic{i$_k$} are stack items, with \spic{i$_1$} being on top of the stack.


\section{Call stack and catch stack}
\label{callstack}

Subroutines are implemented with the call stack, a last in, first out stack of computation stacks. The top-most is the current computation stack, which is used by instructions.

When a subroutine call is performed, a new computation stack is pushed on to the call stack. This is shown in a stack effect as:

\begin{center}
  {\tt \spic{caller ; callee}}
\end{center}

\noindent where \spic{caller} and \spic{callee} are stack pictures for the caller and callee respectively.

Error handling is implemented with the catch stack, a last in, first out stack of call stacks. The top-most is the current call stack. This is shown in a stack effect as:

\begin{center}
  {\tt \spic{handler | handlee}}
\end{center}

\noindent where \spic{handler} and \spic{handlee} are stack pictures for the top-most computation stacks in adjacent call stacks.


\section{Execution}
\label{execution}

The registers (see section~\ref{registers}) are initialised to desired values. Execution proceeds as follows:

\begin{tabbing}
\hspace{0.2in}\=rep\=eat\+\+ \\*
let \textbf{opcode} be the least significant byte of {\tt ir} \\*
shift {\tt ir} arithmetically one byte to the right \\*
execute the instruction given by \textbf{opcode}, \\*
\hspace{1em}or throw error $-1$ if the opcode is invalid \-
\end{tabbing}

\noindent {\bf Instruction fetch} means setting {\tt ir} to the word pointed to by {\tt pc} and making {\tt pc} point to the next word. This is done whenever {\tt ir} is $0$ or $-1$. These are encoded respectively as extra instruction $0$ (see section~\ref{extra}) and trap $-1$ (see section~\ref{trap}).


\subsection{Errors and termination}
\label{errors}

In exceptional situations, such as an invalid memory access, or division by zero, an {\bf error} may be {\bf thrown}; see section~\ref{control}. An {\bf error code} is returned to the handler.

Execution can be terminated explicitly by a {\tt throw} instruction (see section~\ref{control}), which throws an error.

Error codes are signed numbers. $0$ to $-127$ are reserved for the specification. The specified error codes are:

\begin{center}
\begin{tabular}{cp{4in}} \toprule
\bf Code & \bf Meaning \\ \midrule
$0$ & Execution has terminated without error. \\
$-1$ & Invalid opcode (see section~\ref{encoding}). \\
$-2$ & Stack overflow. \\
$-3$ & Invalid stack read. \\
$-4$ & Invalid stack write. \\
$-5$ & Invalid memory read. \\
$-6$ & Invalid memory write. \\
$-7$ & Address is valid but insufficiently aligned. \\
$-8$ & Division by zero attempted (see section~\ref{arithmetic}). \\
$-9$ & Division overflow (see section~\ref{arithmetic}). \\
 \bottomrule
\end{tabular}
\end{center}

\noindent Errors $-2$ to $-9$ inclusive are optional: an implementation may choose to raise them, or not.


\section{Instructions}

The instructions are listed below, grouped according to function, in the following format:

\begin{description}
\inst{NAME}{before → after}{Description.}
\end{description}

The first line consists of the name of the instruction on the left, and the stack effect on the right. Underneath is the description.

The symbols denoting different types of stack item are shown in table~\ref{typetable}.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{cl} \toprule
\bf Symbol & \bf Data type \\ \midrule
\spic{flag} & a Boolean flag, zero for false or non-zero for true \\
\spic{s} & signed number \\
\spic{u} & unsigned number \\
\spic{n} & number (signed or unsigned) \\
\spic{x} & unspecified word \\
\spic{addr} & address \\
\spic{a-addr} & word-aligned address \\
\bottomrule
\end{tabular}
\caption{\label{typetable}Types used in stack effects}
\end{center}
\end{table}

Numbers are represented in two's complement form. \spic{addr} consists of all
valid virtual machine addresses.

Each type may be suffixed by a number in stack pictures; if the same combination
of type and suffix appears more than once in a stack effect, it refers each time to the identical stack item.

Ellipsis is used for indeterminate numbers of specified types of item.


\subsection{Stack manipulation}

These instructions manage the stack:

\nopagebreak
\begin{description}
\inst{pop}{x →}{Remove \spic{x} from the stack.}
\inst{dup}{\x{u}\dots\x0 u → \x{u}\dots\x0 \x{u}}{Remove \spic{u}. Copy \x{u} to the top of the stack.}
\inst{set}{\x{u+1}\dots\x0 u → \x0 \x{u}\dots\x1}{Set the \spic{u+1}th stack word to \spic{\x0}, then pop \x0.}
\inst{swap}{\x{u+1}\dots\x0 u → \x0 \x{u}\dots\x1 \x{u+1}}{Exchange the top stack word with the \spic{u+1}th.}
\end{description}


\subsection{Memory}

These instructions fetch and store quantities to and from memory.

\begin{description}
\inst{load}{a-addr → x}{Load the word \spic{x} stored at \spic{a-addr}.}
\inst{store}{x a-addr →}{Store \spic{x} at \spic{a-addr}.}
\inst{load1}{addr → x}{Load the byte \spic{x} stored at \spic{addr}. Unused high-order bits are set to zero.}
\inst{store1}{x addr →}{Store the least-significant byte of \spic{x} at \spic{addr}.}
\inst{load2}{addr → x}{Load the $2$-byte quantity \spic{x} stored at \spic{addr}, which must be a multiple of $2$. Unused high-order bits are set to zero.}
\inst{store2}{x addr →}{Store the $2$ least-significant bytes of \spic{x} at \spic{addr}, which must be a multiple of $2$.}
\inst{load4}{addr → x}{Load the $4$-byte quantity \spic{x} stored at \spic{addr}, which must be a multiple of $4$. Any unused high-order bits are set to zero.}
\inst{store4}{x addr →}{Store the $4$ least-significant bytes of \spic{x} at \spic{addr}, which must be a multiple of $4$.}
\end{description}


\subsection{Constants}

\begin{description}
\inst{push}{→ n}{Push the word pointed to by {\tt pc} on to the stack, and increment {\tt pc} to point to the following word.}
\inst{pushrel}{→ n}{Like {\tt push} but add {\tt pc} to the value pushed on to the stack.}
\inst{pushi\_\spic{n}}{→ n}{Push \spic{n} on to the stack. \spic{n} ranges from $-32$ to $31$ inclusive.}
\inst{pushreli\_\spic{n}}{→ n}{Push ${\tt pc} + {\tt word\_bytes}\times\spic{n}$ on to the stack. \spic{n} ranges from $-64$ to $63$ inclusive.}
\end{description}

The operand of {\tt pushi} and {\tt pushreli} is encoded in the instruction opcode; see section~\ref{encoding}.


\subsection{Arithmetic}
\label{arithmetic}

All calculations are made modulo $2^{(8\times{\tt word\_bytes})}$, except
as detailed for certain instructions.

\nopagebreak
\begin{description}
\inst{negate}{\n1 → \n2}{Negate \n1, giving \n2.}
\inst{add}{\noru1 \noru2 → \noru3}{Add \noru2 to \noru1, giving the sum \noru3.}
\inst{mul}{\noru1 \noru2 → \noru3}{Multiply \noru1 by \noru2 giving the product \noru3.}
\inst{divmod}{\n1 \n2 → \n3 \n4}{Divide \n1 by \n2, giving the single-word quotient \n3 and the single-word remainder \n4. The quotient is rounded towards zero. If \n2 is zero, throw error $-8$. If \n1 is $-2^{(8\times{\tt word\_bytes} - 1)}$ and \n2 is $-1$, throw error $-9$.}
\inst{udivmod}{\U1 \U2 → \U3 \U4}{Divide \U1 by \U2, giving the single-word quotient \U3 and the single-word remainder \U4. If \U2 is zero, throw error $-8$.}
\end{description}


\subsection{Logic}
\label{logic}

Logic functions:

\nopagebreak
\begin{description}
\inst{not}{\x1 → \x2}{Invert all bits of \x1, giving its logical inverse \x2.}
\inst{and}{\x1 \x2 → \x3}{\x3 is the bit-by-bit logical “and” of \x1 with \x2.}
\inst{or}{\x1 \x2 → \x3}{\x3 is the bit-by-bit inclusive-or of \x1 with \x2.}
\inst{xor}{\x1 \x2 → \x3}{\x3 is the bit-by-bit exclusive-or of \x1 with \x2.}
\end{description}


\subsection{Shifts}

\begin{description}
\inst{lshift}{\x1 u → \x2}{Perform a logical left shift of \spic{u} bit-places on \x1, giving \x2. Put zero into the bits vacated by the shift. If \spic{u} is greater than or equal to the number of bits in a word, \x2 is zero.}
\inst{rshift}{\x1 u → \x2}{Perform a logical right shift of \spic{u} bit-places on \x1, giving \x2. Put zero into the bits vacated by the shift. If \spic{u} is greater than or equal to the number of bits in a word, \x2 is zero.}
\inst{arshift}{\x1 u → \x2}{Perform an arithmetic right shift of \spic{u} bit-places on \x1, giving \x2. Copy the original most-significant bit into the bits vacated by the shift. If \spic{u} is greater than or equal to the number of bits in a word, all the bits of \x2 are the same as the original most-significant bit.}
\end{description}


\subsection{Comparison}

These instructions compare two numbers on the stack, returning a flag; see section~\ref{logic}):

\nopagebreak
\begin{description}
\inst{eq}{\n1 \n2 → flag}{\spic{flag} is $1$ if and only if \n1 is equal to \n2.}
\inst{lt}{\n1 \n2 → flag}{\spic{flag} is $1$ if and only if \n1 is less than \n2.}
\inst{ult}{\U1 \U2 → flag}{\spic{flag} is $1$ if and only if \U1 is less than \U2.}
\end{description}


\subsection{Control}
\label{control}

These instructions implement unconditional and conditional branches, and subroutine call and return, with and without error handling.

\nopagebreak
\begin{description}
\inst{jump}{[a-addr] →}{If {\tt ir} is $0$, the target address is \spic{a-addr}, otherwise it is $\texttt{ir}\times\texttt{word\_bytes} + {\tt pc}$. Set \spic{pc} to the target address, and {\tt ir} to $0$.}

\inst{jumpz}{flag [a-addr] →}{If \spic{flag} is false then perform the action of {\tt jump}; otherwise, set {\tt ir} to $0$.}

\inst{call}{\x{\U1}\dots\x0 \U1 \U2 [\aaddr1] → \U2 \aaddr2 {\tt ;} \x{\U1}\dots\x0}{Let the initial value of {\tt pc} be \aaddr2. Perform the action of {\tt jump}. Move \spic{\x{\U1}\dots\x0} from the caller’s stack to the callee’s.}

\inst{ret}{\pbox[t]{\stackcom}{\qquad\quad u a-addr {\tt ;} \x{u}\dots\x0 → \x{u}\dots\x0 \\{\rm or\quad} u a-addr {\tt |} \x{u}\dots\x0 → \x{u}\dots\x0 $0$}}{Pop the current computation stack from the call stack; if the call stack is now empty, pop the current call stack. Set {\tt pc} to \spic{a-addr}, and move \spic{\x{u}\dots\x0} to the new stack. Set {\tt ir} to $0$. If a call stack was popped, push $0$ on top of the stack.}

\inst{throw}{u a-addr {\tt |} n → n}{Throw error \spic{n}. Pop the current call stack from the catch stack. Pop the return address and number of return items, and push the error code.}

\inst{catch}{\x{u}\dots\x0 \U1 \U2 \aaddr1 → \U2 \aaddr2 {\tt |} \x{u}\dots\x0}{Perform the action of {\tt call} as if {\tt ir} were $0$, then push a new call stack on to the catch stack and move the top-most computation stack from the previous call stack to the new one.}
\end{description}


\subsection{Extra instructions}
\label{extra}

Extra instructions, using the {\tt extra} instruction, offer necessary functionality too rare or slow to deserve a core instruction.

\begin{description}
\inst{extra}{}{Perform extra instruction {\tt ir}; if {\tt ir} is not the code of a valid extra instruction, throw error $-1$. Extra instruction code $0$ is used for instruction fetch (see section~\ref{execution}). The stack effect depends on the extra instruction.}
\end{description}


\subsection{Traps}
\label{trap}

Traps, using the {\tt trap} instruction, are similar to extra instructions, but intended to be implementable as add-ons to an implementation, rather than as an integrated part of it. Traps may modify the memory and stack, but may not directly change the values of registers.

\begin{description}
\inst{trap}{}{Perform trap {\tt ir}; if {\tt ir} is not the code of a valid trap, throw error $-1$. The stack effect depends on the trap. Trap code $-1$ is used for instruction fetch (see section~\ref{execution}).}
\end{description}


\subsection{Instruction encoding}
\label{encoding}

Instructions are encoded as bytes, packed into words, which are executed as described in section~\ref{execution}. The bytes have the following internal structure:

\begin{center}
  \begin{bytefield}[endianness=big,bitwidth=2em]{8}
    \bitheader{0-7}\\
    \bitbox{5}{instruction}\bitboxes*{1}{000}\\[1ex]
    \bitbox{5}{{\tt pushi} $n < 0$}\bitboxes*{1}{100}\\[1ex]
    \bitbox{6}{{\tt pushreli} $n < 0$}\bitboxes*{1}{10}\\[1ex]
    \bitbox{6}{{\tt pushreli} $n\geq 0$}\bitboxes*{1}{01}\\[1ex]
    \bitbox{5}{{\tt pushi} $n\geq 0$}\bitboxes*{1}{011}\\[1ex]
    \bitbox{5}{instruction}\bitboxes*{1}{111}
  \end{bytefield}
\end{center}

Table~\ref{opcodetable} lists the instructions whose least-significant $3$ bits are $000$ or $111$. Other instruction opcodes with those endings are invalid. Table~\ref{extraopcodetable} lists the extra instruction opcodes.

% FIXME: use “Tabular hex numerals”
\begin{table}[htb]
\begin{center}
\begin{tabular}{*{2}{cc}} \toprule
\bf Opcode & \bf Instruction & \bf Opcode & \bf Instruction \\ \midrule
\opcodetbl{00}{extra}			{80}{load}
\opcodetbl{08}{not}			{88}{store}
\opcodetbl{10}{and}			{90}{load1}
\opcodetbl{18}{or}			{98}{store1}
\opcodetbl{20}{xor}			{a0}{load2}
\opcodetbl{28}{lshift}			{a8}{store2}
\opcodetbl{30}{rshift}			{b0}{load4}
\smallskip% For some reason needs to be here rather than after the next line
\opcodetbl{38}{arshift}			{b8}{store4}
\opcodetbl{40}{pop}			{c0}{push}
\opcodetbl{48}{dup}			{c8}{pushrel}
\opcodetbl{50}{set}			{d0}{negate}
\opcodetbl{58}{swap}			{d8}{add}
\opcodetbl{60}{jump}			{e0}{mul}
\opcodetbl{68}{jumpz}			{e8}{eq}
\opcodetbl{70}{call}			{f0}{lt}
\opcodetbl{78}{ret}			{f8}{ult}
 \bottomrule
\end{tabular}
\caption{\label{opcodetable}Instruction opcodes}
\end{center}
\end{table}

\begin{table}[htb]
\begin{center}
\begin{tabular}{{cc}} \toprule
\bf Opcode & \bf Instruction \\ \midrule
\extraopcodetbl{1}{divmod}
\extraopcodetbl{2}{udivmod}
\extraopcodetbl{3}{catch}
\extraopcodetbl{4}{throw}
 \bottomrule
\end{tabular}
\caption{\label{extraopcodetable}Extra instruction opcodes}
\end{center}
\end{table}

\section{External interface}

\begin{itemize}
\item Implementations should provide an API to create and run virtual machine code, and to add traps.
\item Implementations can add extra instructions to provide extra computational primitives and other deeply-integrated facilities, and traps to offer access to system facilities, native libraries and so on; see section~\ref{extra}.
\end{itemize}


\section*{Acknowledgements}

Martin Richards introduced me to Cintcode~\cite{cintweb}, which
kindled my interest in virtual machines, and led to
Beetle~\cite{beetledis} and Mite~\cite{mite0},
of which Mit is a sort of synthesis.
GNU~\emph{lightning}~\cite{lightning} helped inspire me to greater
simplicity, while still aiming for speed. Alistair Turnbull
has for many years been a fount of ideas and criticism for all my work in computation, and lately a staunch collaborator on Mit.

\bibliographystyle{plain}
\bibliography{vm,rrt}


\end{document}

% LocalWords:  Richards's addr Mit handlee
