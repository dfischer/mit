% The definition of Mit (self-contained paper)
%
% (c) Reuben Thomas 1993-2020
% This file is in the public domain.

\documentclass[a4paper]{article}
\usepackage[british]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{newpxtext,booktabs,hyperref}


% Macros for this document

% Font for stack pictures; macro \spic includes italic correction

\newcommand{\spic}[1]{\texttt{\textsl{#1\/}}}

% Common stack items

\newcommand{\x}[1]{\spic{x$_{#1}$}}
\newcommand{\n}[1]{\spic{n$_{#1}$}}
\newcommand{\U}[1]{\spic{u$_{#1}$}}
\newcommand{\noru}[1]{\spic{n$_#1${\tt |}u$_{#1}$}}
\newcommand{\addr}[1]{\spic{addr$_{#1}$}}
\newcommand{\aaddr}[1]{\spic{a-addr$_{#1}$}}

% Lay out an instruction definition

% Define the widths of the stack effect and description columns
\newlength{\itemwidth}\itemwidth=\textwidth \advance\itemwidth by -0.1in
\newlength{\instname}\instname=1.5in
\newlength{\stackcom}\stackcom=3.0in
\newlength{\beforestackcom} \advance\beforestackcom by \instname

\newcommand{\inst}[3]{\item[]\parbox{\itemwidth}%
{\makebox[\instname][l]{\tt #1}%
\makebox[\stackcom][r]{\tt ( \spic{#2} )}\\[0.5ex]#3}}

% Lay out a line of the opcode table

\newcommand{\opcodetbl}[4]{0x#1 & {\tt #2} & 0x#3 & {\tt #4} \\}
\newcommand{\opcodetblone}[2]{0x#1 & {\tt #2} \\}


\title{The Mit Virtual Machine}
\author{Reuben Thomas}
\date{28th March 2020}

\begin{document}
\maketitle

\subsection*{Typographical conventions}

Instructions and registers are shown in {\tt typewriter} font;
interface calls are shown in {\bf bold} type.

Addresses are given in bytes and refer to the VM address space except where
stated. Addresses are written in hexadecimal; hex numbers are prefixed with
“0x”.


\section{Introduction}

Mit is a simple virtual machine for study and experiment. It is a stack machine, based on the more complex register machine Mite~\cite{mite0}.
This paper gives a full description of Mit.

Mit is conceptually (and usually in fact) a library, embedded in other programs.


\section{Architecture}

The address unit is the byte, which is eight bits.
Most of the quantities on which Mit operates are fixed-size words, which are stored in memory in either big- or little-endian order.
The choice of byte and word size enable efficient implementation on the vast majority of machine architectures.


\subsection{Parameters}

Some parameters may take a range of values, but are fixed for a particular virtual machine instance. They are listed in table~\ref{paramtable}.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{cp{3.75in}} \toprule
\bf Parameter & \bf Meaning \\
 \midrule
{\tt endism} & The endianness of the virtual machine instance: $0$ for little-endian, or $1$ for big-endian. \\
{\tt word\_bytes} & The number of bytes in a word. Must be in the range $2$ to $32$ inclusive, and a power of $2$. \\
{\tt instruction\_bits} & The number of bits in an instruction. Must be in the range $5$ to $8$ inclusive. \\
 \bottomrule
\end{tabular}
\caption{\label{paramtable}Parameters}
\end{center}
\end{table}


\subsection{Registers}
\label{registers}

The registers are word quantities; they are listed, with their functions, in table~\ref{regtable}. The registers are initialised to~$0$.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{cp{3.75in}} \toprule
\bf Register & \bf Function \\
 \midrule
{\tt pc} & The {\tt p}rogram {\tt c}ounter. Points to the next word from which {\tt i} may be loaded. \\
{\tt ir} & The {\tt i}nstruction {\tt r}egister. Contains instructions to be executed. \\
{\tt stack\_depth} & The number of words on the stack. \\
 \bottomrule
\end{tabular}
\caption{\label{regtable}Registers}
\end{center}
\end{table}


\subsection{Memory}

Mit's memory consists of discontiguous words in a single flat address space. The address of a word is that of the byte in it with the lowest address.


\subsection{Stack}

The stack is a LIFO stack of words used for passing values to instructions and routines and for holding subroutine return addresses. To {\bf push} a word on to the stack means to add a new word to the top of the stack, increasing the stack depth by $1$; to {\bf pop} a word means to reduce the stack depth by $1$. Instructions that change the number of words on the stack implicitly pop their arguments and push their results.


\subsection{Execution}
\label{execution}

Execution proceeds as follows:

\begin{tabbing}
\hspace{0.5in}\=begin\=\+\+ \\*
let \textbf{opcode} be the least significant {\tt instruction\_bits} bits of {\tt ir} \\*
shift {\tt ir} logically {\tt instruction\_bits} bits to the right \\*
execute the instruction given by \textbf{opcode} \- \\*
repeat
\end{tabbing}

If an error occurs during execution (see section~\ref{errors}), the state of the virtual machine is reset to its state at the start of the loop before the error is raised. This allows instructions to be restarted after handling the error, where desired.

\subsection{Errors and termination}
\label{errors}

When Mit encounters certain abnormal situations, such as an attempt to access an invalid address, or divide by zero, an {\bf error} is {\bf raised}, and execution terminates. The effect of the current instruction is undone (see section~\ref{execution}). An {\bf error code} is returned to the caller.

Execution can be terminated explicitly by performing a {\tt halt} instruction (see section~\ref{halt}).

Error codes are unsigned numbers. $0$ to $127$ are reserved for the specification; other error codes may be used by implementations. The meanings of those that may be raised by Mit are shown in table~\ref{errortable}.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{cp{4in}} \toprule
\bf Code & \bf Meaning \\ \midrule
$0$ & {\bf single\_step()} has terminated without error. \\
$1$ & Invalid opcode (see section~\ref{opcodes}). \\
$2$ & Stack overflow. \\
$3$ & Invalid stack read. \\
$4$ & Invalid stack write. \\
$5$ & Invalid memory read. \\
$6$ & Invalid memory write. \\
$7$ & Address alignment error: raised when an instruction is given a valid address, but insufficiently aligned. \\
$8$ & Invalid size (greater than $\log_2{\tt word\_bytes}$). \\
$9$ & Division by zero attempted (see section~\ref{arithmetic}). \\
$127$ & A {\tt halt} instruction was executed. \\
 \bottomrule
\end{tabular}
\caption{\label{errortable}Errors raised by Mit}
\end{center}
\end{table}


\section{Instruction set}
\label{instset}

The instruction set is listed below,
with the instructions grouped according to function. The
instructions are given in the following format:

\begin{description}
\inst{NAME}{before — after}{Description.}
\end{description}

The first line consists of the name of the instruction. On the right is the
stack effect, which shows the effect of the instruction on the stack.
Underneath is the description.

{\bf Stack effects} are written

\centerline{\tt ( \spic{before — after} )}

\noindent where \spic{before} and \spic{after} are stack pictures showing the items on top
of a stack before and after the instruction is executed.
An instruction only affects the items shown in its
stack effects. The brackets and dashes serve merely to delimit the stack
effect and to separate \spic{before} from \spic{after}. {\bf Stack pictures}
are a representation of the top-most items on the stack, and are written

\centerline{\spic{i$_1$ i$_2$\dots i$_{n-1}$ i$_n$}}

\noindent where the \spic{i$_k$} are stack items, each of which occupies a whole number of words,\footnote{In this specification, each stack item occupies \emph{precisely} one word.} with \spic{i$_n$} being on top of the stack. The symbols denoting different types of stack item are shown in table~\ref{typetable}.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{cl} \toprule
\bf Symbol & \bf Data type \\ \midrule
\spic{flag} & a Boolean flag, $0$ for false or non-zero for true \\
\spic{size} & an integer in the range $0$ to $\log_2{\tt word\_bytes}$ inclusive \\
\spic{n} & signed number \\
\spic{u} & unsigned number \\
\spic{n{\tt |}u} & number (signed or unsigned) \\
\spic{x} & unspecified word \\
\spic{addr} & address \\
\spic{a-addr} & word-aligned address \\
\bottomrule
\end{tabular}
\caption{\label{typetable}Types used in stack effects}
\end{center}
\end{table}

Types are only used to indicate how instructions treat their arguments and
results; Mit does not distinguish between stack items of different types. In
stack pictures the most general argument types with which each instruction can
be supplied are given; subtypes may be substituted. Using the phrase ``$i
\Rightarrow j$'' to denote ``$i$\/ is a subtype of $j$\/'', table~\ref{reltable}
shows the subtype relationships. The subtype relation is transitive.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{c} \toprule
\spic{u} $\Rightarrow$ \spic{x} \\
\spic{n} $\Rightarrow$ \spic{x} \\
\spic{flag} $\Rightarrow$ \spic{u} \\
\spic{size} $\Rightarrow$ \spic{u} \\
\spic{a-addr} $\Rightarrow$ \spic{addr} $\Rightarrow$ \spic{u} \\
 \bottomrule
\end{tabular}
\caption{\label{reltable}The subtype relation}
\end{center}
\end{table}

Numbers are represented in two's complement form. \spic{addr} consists of all
valid virtual machine addresses.

Each type may be suffixed by a number in stack pictures; if the same combination
of type and suffix appears more than once in a stack effect, it refers each time to the identical stack item.

Ellipsis is used for indeterminate numbers of specified types of item.


\subsection{Instruction fetch}

If an invalid or unaligned address is accessed when loading {\tt ir}, the appropriate error is raised (see section~\ref{errors}).

\begin{description}
\inst{next}{—}{Load the word pointed to by {\tt pc} into {\tt ir} then add {\tt word\_bytes} to {\tt pc}.}
\end{description}


\subsection{Control}
\label{control}

These instructions implement unconditional and conditional branches, and subroutine
call and return (subroutine return is {\tt jump}):

\nopagebreak
\begin{description}
\inst{jump}{a-addr —}{If {\tt ir} is not $0$, raise error $1$. Set {\tt pc} to \spic{a-addr}. Perform the action of {\tt next}.}
\inst{jumpz}{flag a-addr —}{If \spic{flag} is false then set {\tt pc} to \spic{a-addr} and perform the action of {\tt next}.}
\inst{call}{\aaddr1 — \aaddr2}{If {\tt ir} is not $0$, raise error $1$. Exchange {\tt pc} with the top stack value. Perform the action of {\tt next}.}
\end{description}


\subsection{Extra instructions}
\label{extra}

Since {\tt ir} must be $0$ when {\tt next} is performed, the rest of an instruction word following {\tt next}, {\tt jump} and {\tt call} must normally be all zero bits.

Non-zero values following {\tt next} and {\tt call} are reserved for the Mit specification; non-zero values following {\tt jump} may be used by implementations to implement extra functionality.

When an extra instruction is performed, the original instruction is considered to have completed executing.

\subsubsection{Termination}
\label{halt}

This instruction terminates execution (see section~\ref{errors}):

\nopagebreak
\begin{description}
\inst{halt}{—}{Raise error $127$.}
\end{description}


\subsection{Stack manipulation}

These instructions manage the stack:

\nopagebreak
\begin{description}
\inst{pop}{x —}{Remove \spic{x} from the stack.}
\inst{dup}{\x{u}\dots\x0 u — \x{u}\dots\x0 \x{u}}{Remove \spic{u}. Copy \x{u} to the top of the stack.}
\inst{swap}{\x{u+1}\dots\x0 u — \x0 \x{u}\dots\x1 \x{u+1}}{Exchange the top stack word with the \spic{u+1}th.}
\end{description}


\subsection{Literals}

\begin{description}
\inst{lit}{— n}{The word pointed to by {\tt pc} is pushed on to the stack, and {\tt pc} is incremented to point to the following word.}
\inst{lit\_pc\_rel}{— n}{Like {\tt lit}, except that the initial value of {\tt pc} is added to the value pushed on to the stack.}
\inst{lit\_0}{— $0$}{Push $0$ on to the stack.}
\inst{lit\_1}{— $1$}{Push $1$ on to the stack.}
\inst{lit\_2}{— $2$}{Push $2$ on to the stack.}
\inst{lit\_3}{— $3$}{Push $3$ on to the stack.}
\end{description}


\subsection{Logic and shifts}
\label{logicshifts}

Logic functions:

\nopagebreak
\begin{description}
\inst{not}{\x1 — \x2}{Invert all bits of \x1, giving its logical inverse \x2.}
\inst{and}{\x1 \x2 — \x3}{\x3 is the bit-by-bit logical ``and'' of \x1 with \x2.}
\inst{or}{\x1 \x2 — \x3}{\x3 is the bit-by-bit inclusive-or of \x1 with \x2.}
\inst{xor}{\x1 \x2 — \x3}{\x3 is the bit-by-bit exclusive-or of \x1 with \x2.}
\end{description}

Shifts:

\nopagebreak
\begin{description}
\inst{lshift}{\x1 u — \x2}{Perform a logical left shift of \spic{u} bit-places on \x1, giving \x2. Put zero into the least significant bits vacated by the shift. If \spic{u} is greater than or equal to the number of bits in a word, \x2 is zero.}
\inst{rshift}{\x1 u — \x2}{Perform a logical right shift of \spic{u} bit-places on \x1, giving \x2. Put zero into the most significant bits vacated by the shift. If \spic{u} is greater than or equal to the number of bits in a word, \x2 is zero.}
\inst{arshift}{\x1 u — \x2}{Perform an arithmetic right shift of \spic{u} bit-places on \x1, giving \x2. Copy the original most-significant bits into the most significant bits vacated by the shift. If \spic{u} is greater than or equal to the number of bits in a word, all the bits of \x2 are the same as the original most-significant bit.}
\inst{sign\_extend}{u size — n}{Sign extend the $2^{\spic{size}}$-byte quantity \spic{u} to \spic{n}.}
\end{description}


\subsection{Comparison}

These words compare two numbers on the stack, returning a flag (for equality, use {\tt xor}; see section~\ref{logicshifts}):

\nopagebreak
\begin{description}
\inst{lt}{\n1 \n2 — flag}{\spic{flag} is $1$ if and only if \n1 is less than \n2.}
\inst{ult}{\U1 \U2 — flag}{\spic{flag} is $1$ if and only if \U1 is less than \U2.}
\end{description}


\subsection{Arithmetic}
\label{arithmetic}

These instructions consist of monadic and dyadic operators.
All calculations are made without bounds or overflow checking, except
as detailed for certain instructions.

Negation and addition:

\nopagebreak
\begin{description}
\inst{negate}{\n1 — \n2}{Negate \n1, giving its arithmetic inverse \n2.}
\inst{add}{\noru1 \noru2 — \noru3}{Add \noru2 to \noru1, giving the sum \noru3.}
\end{description}

Multiplication and division (note that all division instructions raise error
$9$ if division by zero is attempted):

\nopagebreak
\begin{description}
\inst{mul}{\noru1 \noru2 — \noru3}{Multiply \noru1 by \noru2 giving the product \noru3.}
\inst{divmod}{\n1 \n2 — \n3 \n4}{Divide \n1 by \n2 using symmetric division, giving the single-word quotient \n3 and the single-word remainder \n4. The quotient is rounded towards zero.}
\inst{udivmod}{\U1 \U2 — \U3 \U4}{Divide \U1 by \U2, giving the single-word quotient \U3 and the single-word remainder \U4.}
\end{description}


\subsection{Memory}

These instructions fetch and store quantities to and from memory. If an invalid or unaligned address is accessed, the appropriate error is raised (see section~\ref{errors}).

\nopagebreak
\begin{description}
\inst{load}{addr size — x}{Load the $2^{\spic{size}}$-byte quantity \spic{x} stored at \spic{addr}, which must be a multiple of $2^{\spic{size}}$. Any unused high-order bits are set to zero.}
\inst{store}{x addr size —}{Store the $2^{\spic{size}}$ least-significant bytes of \spic{x} at \spic{addr}, which must be a multiple of $2^{\spic{size}}$.}
\end{description}


\subsection{Instruction encoding}
\label{encoding}

Instructions are encoded as {\tt instruction\_bits}-bit opcodes; opcodes are packed into words, which are executed starting at the least-significant bits.


\subsection{Instruction opcodes}
\label{opcodes}

Table~\ref{opcodetable} lists the instruction opcodes in numerical order. Table~\ref{extraopcodetable} lists the extra instruction opcodes (following {\tt call}; see section~\ref{extra}). Other instruction opcodes are undefined.

\begin{table}[htb]
\begin{center}
\begin{tabular}{*{2}{cc}} \toprule
\bf Opcode & \bf Instruction & \bf Opcode & \bf Instruction \\ \midrule
\opcodetbl{0}{next}			{10}{\rm (undefined)}
\opcodetbl{1}{jump}			{11}{lt}
\opcodetbl{2}{jumpz}			{12}{ult}
\opcodetbl{3}{call}			{13}{negate}
\opcodetbl{4}{pop}			{14}{add}
\opcodetbl{5}{dup}			{15}{mul}
\opcodetbl{6}{swap}			{16}{divmod}
\smallskip% For some reason needs to be here rather than after the next line
\opcodetbl{7}{\rm (undefined)}	{17}{udivmod}
\opcodetbl{8}{load}			{18}{not}
\opcodetbl{9}{store}			{19}{and}
\opcodetbl{a}{lit}			{1a}{or}
\opcodetbl{b}{lit\_pc\_rel}		{1b}{xor}
\opcodetbl{c}{lit\_0}			{1c}{lshift}
\opcodetbl{d}{lit\_1}			{1d}{rshift}
\opcodetbl{e}{lit\_2}			{1e}{arshift}
\opcodetbl{f}{lit\_3}			{1f}{sign\_extend}
 \bottomrule
\end{tabular}
\caption{\label{opcodetable}Instruction opcodes}
\end{center}
\end{table}

\begin{table}[htb]
\begin{center}
\begin{tabular}{*{1}{cc}} \toprule
\bf Opcode & \bf Instruction \\ \midrule
\opcodetblone{1}{halt}
 \bottomrule
\end{tabular}
\caption{\label{extraopcodetable}Extra instruction opcodes}
\end{center}
\end{table}

\section{External interface}

\begin{itemize}
\item Implementations should provide an \textbf{API} to create and run virtual machine instances, and provide access to its registers, stack and memory.
\item Implementations can add \textbf{extra instructions} to provide extra computational primitives, and to offer access to system facilities, previously written code, native libraries and so on.
\end{itemize}


\section*{Acknowledgements}

Martin Richards's demonstration of his BCPL-oriented Cintcode virtual machine~\cite{cintweb}
convinced me it was going to be fun working on virtual machines. He also supervised my BA dissertation project, Beetle~\cite{beetledis}, and my PhD project, Mite~\cite{mite0}, on which Mit is based.

\bibliographystyle{plain}
\bibliography{vm,rrt}


\end{document}

% LocalWords:  Richards's addr Mit
