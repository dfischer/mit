%
% Documentation for @PACKAGE_NAME@ shell
%
% Reuben Thomas
%
% Started 27/2-8/5/95
%

\documentclass{article}
\usepackage[british]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{a4,newpxtext,booktabs,url,xr}


% Allow external cross-references
\externaldocument{@PACKAGE@}
\externaldocument{c@PACKAGE@}

% Macros

% Put an object in angle brackets for syntax descriptions

\newcommand{\angb}[1]{$\langle #1\rangle$}


\title{A simple shell for the\\@PACKAGE_NAME@ virtual machine\\version @VERSION@}
\author{Reuben Thomas}
\date{30th July 2018}

\begin{document}
\maketitle


\section{Introduction}

This is the manual for the shell for C @PACKAGE_NAME@~\cite{c@PACKAGE@}, which provides access to @PACKAGE_NAME@'s registers, allows the stacks to be displayed, and provides assembly, disassembly and single-stepping.

There are two main ways to access the shell: either start {\tt @PACKAGE@} with no arguments, or, when passing an object file on the command line, give the {\tt -\/-debug} option, which causes the shell to be entered on exception (interpreted as a negative value being passed to {\tt HALT}). The shell can also be used in batch mode, by supplying commands on standard input. Refer to the man page \textbf{@PACKAGE@}(1) or {\tt @PACKAGE@ -\/-help} for more details and options.


\section{Initialisation}
\label{uifaceinit}

When the virtual machine is started, an embedded @PACKAGE_NAME@ is created. The registers are initialised as described in~\cite[section~\ref{usingcalls}]{c@PACKAGE@}; additionally, {\tt HANDLER} is set to~0, and {\tt I} is uninitialised. The main memory is zeroed.


\section{Commands}
\label{commands}

The shell is command-driven. All commands and register names may be
abbreviated to their first few letters; where ambiguities are resolved with a set order of precedence, aimed at giving the most
commonly used commands the shortest minimum abbreviations, and commands
take precedence over registers.
Alternatively, if you have {\tt @PACKAGE@i} (which uses {\tt rlwrap}), you can use Tab-completion (press the Tab key to show possible commands and instructions starting with the letters you have typed so far).
All commands are case-insensitive.

If an unrecognised command is given, or the command has too few arguments, or
they are badly formed, an error message is displayed. Command lines
containing extraneous characters after a valid command are generally
accepted, and the extra characters ignored.

Numbers are all integral, and may be given in either decimal or hexadecimal
(which must be preceded by ``0x''), with an optional minus
sign.

For some arguments an action may also be used, preceded by ``{\tt
O}'', for opcode. The value of an action is its opcode.

The syntax of the commands is shown below; literal text such as command names
and other characters are shown in {\tt Typewriter font}; meta-parameters such
as numbers are shown in angle brackets, thus: \angb{number}. Square brackets enclose optional tokens.

There are three types of numeric meta-parameter: \angb{number}, which is any
number; \angb{address}, which is a valid address (see~\cite[section~\ref{exceptions}]{@PACKAGE@});
and \angb{value}, which is a number or an action opcode.

\subsection{Comments}

The string {\tt //} starts a comment, which runs to the end of the input line, and is ignored.

\subsection{Registers}

@PACKAGE_NAME@'s registers may be displayed by typing their name. The
registers may also (where appropriate) be assigned to using the syntax

\begin{center}\angb{register} $=$ \angb{value}\end{center}

\noindent where \angb{value} is in the form given in section~\ref{commands}. An error
message is displayed if an attempt is made to assign to a register such as
{\tt ENDISM}, which cannot be assigned to, or to assign an unaligned or out
of range address to a register which must hold an aligned address, such as
{\tt SP}.

Two additional pseudo-registers are provided by the shell: they are
called {\tt S0} and {\tt R0}, and are the address of the base of the data and
return stacks respectively. They are set to the initial values of {\tt RP}
and {\tt SP}, and are provided so that they can be changed if the stacks are
moved, so the stack display commands will still work correctly.

The command {\tt REGISTERS} displays the contents of {\tt PC} and {\tt I}, useful when following the execution of a program.

\subsection{Stacks}

The stacks may be manipulated crudely using the registers {\tt SP} and {\tt
RP} but it is usually more convenient to use the commands

\begin{center}
{\tt TOD} \angb{number}\\
{\tt DFROM}
\end{center}

\noindent which respectively push a number on to the data stack and pop one, displaying
it, and

\begin{center}
{\tt TOR} \angb{number}\\
{\tt RFROM}
\end{center}

\noindent which do the same for the return stack.

The command {\tt DATA} displays the contents of the data stack, and {\tt
RETURN} the contents of the return stack. {\tt STACKS} displays both stacks.

If a stack underflows, or the base pointer or top of stack pointer is out of
range or unaligned, an appropriate error message is displayed.

\subsection{Code and data}
\label{codeanddata}

\begin{center}
\angb{opcode}
{\tt NUMBER} \angb{number}
{\tt BYTE} \angb{number}
{\tt POINTER} \angb{number}
\end{center}

Code and literal data values may be directly assembled into memory. Assembly starts at the last value explicitly assigned to {\tt PC} in the shell, defaulting to~0 whenever @PACKAGE_NAME@ is initialised (see section~\ref{uifaceinit}). A byte literal ({\tt BYTE}) takes one byte (a one-byte instruction may be used), and a word literal ({\tt NUMBER}) as many bytes as required. {\tt POINTER} assembles the literals required to push the given native pointer on to the stack in the form required for the {\tt CALL\_NATIVE} instruction.

\subsection{Memory}

The contents of an address may be displayed by giving the address as a
command. If the address is word-aligned the whole word is displayed,
otherwise the byte at that address is shown.

A larger section of memory may be displayed with the command {\tt DUMP},
which may be used in the two forms

\begin{center}
{\tt DUMP} [\angb{address} [{\tt +} \angb{number}]]\\
{\tt DUMP} \angb{address_1} [\angb{address_2}]
\end{center}

\noindent where the first displays \angb{number} bytes (or $256$ if the number is omitted) starting at address
\angb{address} (or $64$ bytes before {\tt PC} if the address is omitted, or $0$ if that would be negative), and the second displays memory from address \angb{address_1}
up to, but not including, address \angb{address_2}. An error message is
displayed if the start address is less than or equal to the end address or if
either address is out of range.

A command of the form

\begin{center}\angb{address} $=$ \angb{value}\end{center}

\noindent assigns the value \angb{value} to the address \angb{address}. If the address
is not word-aligned, the value must fit in a byte, and only that byte is
assigned to. When assigning to an aligned memory location, a whole word is
assigned unless the number given fits in a byte, and is given using the
minimum number of digits required. This should be noted the other way around:
to assign a byte-sized significand to a word, it should be padded with a
leading zero.

\subsection{Execution}

The command {\tt INITIALISE} initialises @PACKAGE_NAME@ as in section
\ref{uifaceinit}.

The command {\tt STEP} may be used to single-step through a program. It has
three forms:

\begin{center}
{\tt STEP} [\angb{number}]\\
{\tt STEP TO} \angb{address}
\end{center}

With no argument, {\tt STEP} executes one instruction. Given a number, {\tt
STEP} executes \angb{number} instructions. {\tt STEP TO} executes
instructions until {\tt PC} is equal to \angb{address}.

The command {\tt TRACE}, has the same syntax as {\tt STEP}, and performs the
same function; in addition, it performs the action of the {\tt REGISTERS}
command after each instruction is executed.

The command {\tt RUN} allows @PACKAGE_NAME@ to execute until it reaches a {\tt HALT}
instruction, if ever. The code passed to {\tt HALT} is then displayed. The
code is also displayed if a {\tt HALT} instruction is ever executed during a
{\tt STEP} command.

The command {\tt DISASSEMBLE} disassembles @PACKAGE@ code. It may be used in the
two forms

\begin{center}
{\tt DISASSEMBLE} [\angb{address} [{\tt +} \angb{number}]]\\
{\tt DISASSEMBLE} \angb{address_1} \angb{address_2}
\end{center}

\noindent where the first disassembles \angb{number} bytes (or $64$ if the number is omitted) starting at address
\angb{address} (or $16$ bytes before {\tt PC}, or $0$ if that would be negative, if the address is omitted), and the second from address \angb{address_1} up to, but not
including, address \angb{address_2}.  An error message is displayed
if the start address is less than or equal to the end address, or if either
the address or number of bytes is out of range.

\subsection{Object modules}

The command

\label{uifaceload}
\begin{center}{\tt LOAD} \angb{file} [\angb{address}]\end{center}

\noindent initialises @PACKAGE_NAME@ as in section~\ref{uifaceinit}, then loads the object
module in file \angb{file} into memory at address \angb{address} (or address~0 if the argument is omitted). If the module would not fit in memory
at the address given, or there is an I/O error, an error message is
displayed.

The command {\tt SAVE} saves an object module. It has the two forms

\begin{center}
{\tt SAVE} \angb{file} \angb{address} {\tt +} \angb{number}\\
{\tt SAVE} \angb{file} [\angb{address_1} \angb{address_2}]
\end{center}

\noindent where the first saves \angb{number} bytes starting at address \angb{address},
and the second saves from address \angb{address_1} up to, but not including,
address \angb{address_2} (defaulting to $0$ and the address at which the next instruction would be assembled). An error message is displayed if the
start address is less than or equal to the end address, or if either the
address or number of bytes is out of range.

The module is saved to the file \angb{file}. An error message is displayed if
there is some filing error, but no warning is given if a file of that name
already exists; it is overwritten.

\subsection{Exiting}

The command {\tt QUIT} exits @PACKAGE_NAME@. No warning is given.


\bibliographystyle{plain}
\bibliography{rrt}


\end{document}