%
% The definition of @PACKAGE_NAME@ (self-contained paper)
%
% Reuben Thomas
%
% Started 1/6-29/10/93
%

\documentclass{article}
\usepackage[british]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{a4wide,newpxtext,booktabs,hyperref}

% Alter some default parameters for general typesetting

\parindent=0pt
\parskip=1.5ex plus 0.5ex
\topskip=0pt

\frenchspacing


% Macros for this document

% Font for stack pictures; macro \spic includes italic correction

\newfont{\spfont}{cmsltt10 scaled 1000}
\newcommand{\spic}[1]{{\spfont\setlength{\baselineskip}{\normalbaselineskip}#1\/}}

% Common stack items

\newcommand{\x}[1]{\spic{x$_{#1}$}}
\newcommand{\n}[1]{\spic{n$_{#1}$}}
\newcommand{\U}[1]{\spic{u$_{#1}$}}
\newcommand{\noru}[1]{\spic{n$_#1${\tt |}u$_{#1}$}}
\newcommand{\aaddr}[1]{\spic{a-addr$_{#1}$}}

% Lay out an instruction definition

% Define the widths of the stack comment and description columns
\newlength{\itemwidth}\itemwidth=\textwidth \advance\itemwidth by -0.1in
\newlength{\instname}\instname=0.5in
\newlength{\pronunc}\pronunc=1.7in
\newlength{\stackcom}\stackcom=3.0in
\newlength{\beforestackcom} \advance\beforestackcom by \instname
    \advance\beforestackcom by \pronunc

% With no pronunciation or return stack
\newcommand{\inst}[3]{\item[]\parbox{\itemwidth}%
{\makebox[\instname][l]{\tt #1}\makebox[\pronunc][r]{}%
\makebox[\stackcom][r]{\tt ( \spic{#2} )}\\[0.5ex]#3}}

% With pronunciation only
\newcommand{\instp}[4]{\item[]\parbox{\itemwidth}%
{\makebox[\instname][l]{\tt #1}\makebox[\pronunc][r]{``#2''}%
\makebox[\stackcom][r]{\tt ( \spic{#3} )}\\[0.5ex]%
#4}}

% With return stack only
\newcommand{\instr}[4]{\item[]\parbox{\itemwidth}%
{\makebox[\instname][l]{\tt #1}\makebox[\pronunc][r]{}%
\makebox[\stackcom][r]{\tt ( \spic{#2} )}\\\makebox[\beforestackcom]{}%
\makebox[\stackcom][r]{\tt R: ( \spic{#3} )}\\[0.5ex]#4}}

% With pronunciation and return stack
\newcommand{\instpr}[5]{\item[]\parbox{\itemwidth}%
{\makebox[\instname][l]{\tt #1}\makebox[\pronunc][r]{``#2''}%
\makebox[\stackcom][r]{\tt ( \spic{#3} )}\\%
\makebox[\beforestackcom]{}\makebox[\stackcom][r]{\tt R: ( \spic{#4} )}%
\\[0.5ex]#5}}

% Lay out an external interface call

\newlength{\innerwidth}\innerwidth=\itemwidth \advance\innerwidth by -0.5in
\newcommand{\iface}[4]{\item[]\parbox{\itemwidth}{{\bf #1} ({\it #2}\/) :
#3\\[0.5ex]\hspace*{0.4in}\parbox{\innerwidth}{#4}}}

% Lay out a line of the opcode table

\newcommand{\opcodetbl}[6]{\$#1 & {\tt #2} & \$#3 & {\tt #4} & \$#5 & {\tt #6}
\\}
\newcommand{\opcodetbltwo}[4]{\$#1 & {\tt #2} & \$#3 & {\tt #4} \\}


\title{The @PACKAGE_NAME@ Virtual Machine}
\author{Reuben Thomas}
\date{13th September 2018}

\begin{document}
\maketitle

\begin{abstract}
\noindent The design of the @PACKAGE_NAME@ virtual machine is described.
@PACKAGE_NAME@'s is a deliberately simple and highly portable low-level VM intended for study and experiment. @PACKAGE_NAME@ is able to call machine code and access the operating system.
\end{abstract}


\subsection*{Typographical notes}

Instructions and @PACKAGE_NAME@'s registers are shown in {\tt Typewriter} font;
interface calls are shown in {\bf Bold} type, and followed by empty parentheses.
Quoted pronunciations of instructions and registers are given with components
separated by dashes; single letters should be pronounced as the name of the
letter.

Addresses are given in bytes and refer to @PACKAGE_NAME@'s address space except where
stated. Addresses are written in hexadecimal; hex numbers are prefixed with
“\$”.


\section{Introduction}

@PACKAGE_NAME@ is a simple virtual machine for study and experiment. It is a stack machine, based on the more complex register machine~\cite{mite}.
This paper gives a full description of @PACKAGE_NAME@, but
certain implementation-dependent features, such as the size of the stacks, are
purposely left unspecified, and the exact method of implementation is left to
the implementor in many particulars.

@PACKAGE_NAME@ is self-contained. I/O can be implemented via extra instructions (see~\ref{extrainstructions}). Machine
code routines on the host computer may be accessed using the {\tt LINK}
instruction. @PACKAGE_NAME@ supports a simple object module format.

@PACKAGE_NAME@ is conceptually (and usually in fact) a library, embedded in other programs.
A small interface is provided for other programs to control @PACKAGE_NAME@.


\section{Architecture}

@PACKAGE_NAME@'s address unit is the byte, which is eight bits wide. Characters are one
byte wide, and cells are four bytes wide. The cell is the size of the numbers
and addresses on which @PACKAGE_NAME@ operates, and of the items placed on the stacks.
The cell size is fixed to ensure compatibility of object code between
implementations on different machines; the size of the address unit, character
and cell has been chosen with a view to making efficient implementation of
@PACKAGE_NAME@ possible on the vast majority of current machine architectures.

Cells may have the bytes stored in big-endian or little-endian order. The
address of a cell is that of the byte in it with the lowest address.


\subsection{Registers}
\label{registers}

The registers, each with its function and pronunciation, are set out in table~\ref{regtable}.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{ccp{3.75in}} \toprule
\bf Register & \bf Pronunciation & \bf Function \\
    \midrule
{\tt EP} & ``e-p'' & The {\tt E}xecution {\tt P}ointer. Points to the next
    cell from which an instruction word may be loaded. \\
{\tt I} & ``i'' & The {\tt I}nstruction. Holds the opcode of an instruction
    to be executed. \\
{\tt A} & ``a'' & The instruction {\tt A}ccumulator. Holds the opcodes of
    instructions to be executed. \\
{\tt MEMORY} & ``memory'' & The size in bytes of @PACKAGE_NAME@'s main memory,
    which must be a multiple of four. \\
{\tt SP} & ``s-p'' & The data {\tt S}tack {\tt P}ointer. \\
{\tt RP} & ``r-p'' & The {\tt R}eturn stack {\tt P}ointer. \\
{\tt S0} & ``s-nought'' & The data {\tt S}tack base. \\
{\tt R0} & ``r-nought'' & The {\tt R}eturn stack base. \\
{\tt \#S} & ``hash-s'' & The number of cells allocated for the data stack. \\
{\tt \#R} & ``hash-r'' & The number of cells allocated for the return stack. \\
{\tt 'THROW} & ``tick-throw'' & The address placed in {\tt EP} by a {\tt THROW}
    instruction. \\
{\tt ENDISM} & ``endism'' & The endianness of @PACKAGE_NAME@: 0 = Little-endian,
    1 = Big-endian. \\
{\tt CHECKED} & ``checked'' & 0 = address checking off, 1 = address checking
    on. \\
{\tt 'BAD} & ``tick-bad'' & The contents of {\tt EP} when the last exception
    was raised. \\
{\tt -ADDRESS} & ``not-address'' & The last address which caused an address
    exception. \\ \bottomrule
\end{tabular}
\caption{\label{regtable}@PACKAGE_NAME@'s registers}
\end{center}
\end{table}

All of the registers are cell-wide quantities except for {\tt I}, {\tt ENDISM} and {\tt
CHECKED}, which are one byte wide.

To ease efficient implementation, the registers may only be accessed
by instructions (see section~\ref{registerinst}); not all registers are accessible, and only a few are writable.


\subsection{Memory}

@PACKAGE_NAME@'s memory is a discontiguous sequence of bytes with addresses in the range $0$ to $2^{32}-1$. Some locations may be read-only. The memory is contiguous in the range $0$ to {\tt MEMORY}~$-$~1; this part is referred to as ``main memory''.

\subsection{Stacks}

The data and return stacks are cell-aligned LIFO stacks of cells. The stack
pointers point to the top stack item on each stack. To {\bf push} an item on to
a stack means to store the item in the cell beyond the stack pointer and then
adjust the pointer to point to it; to {\bf pop} an item means to make the
pointer point to the second item on the stack. Instructions that change the number of items on a
stack implicitly pop their arguments and push their results.

The data stack is used for passing values to instructions and routines and the
return stack for holding subroutine return addresses. The return stack may be used for other
operations subject to the restrictions placed on it by its normal usage: it must
be returned before an {\tt EXIT} instruction to the state it was in directly
after the corresponding {\tt CALL}.

In what follows, for ``the stack'' read ``the data stack''; the return stack is
always mentioned explicitly.


\subsection{Operation}
\label{operation}

Before @PACKAGE_NAME@ is started, {\tt ENDISM} should be set to $0$ or $1$ according to the implementation. {\tt CHECKED} should be set to $0$ or $1$ as desired. The other registers should be initialised as shown in table~\ref{inittable}, except for {\tt I}, which need not be initialised.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{cc} \toprule
\bf Register & \bf Initial value \\ \midrule
{\tt EP} & \$0 \\
{\tt A} & \$0 \\
{\tt THROW} & \$0 \\
{\tt 'BAD} & {\$FFFFFFFF} \\
{\tt -ADDRESS} & {\$FFFFFFFF} \\ \bottomrule
\end{tabular}
\caption{\label{inittable}Registers with prescribed initial values}
\end{center}
\end{table}

{\tt MEMORY}, {\tt ENDISM} and {\tt CHECKED} must not change while @PACKAGE_NAME@ is executing.

@PACKAGE_NAME@ is started by a call to the interface calls {\bf run()} or {\bf
single\_step()} (see section~\ref{calls}). In the former case, the execution
cycle is entered:

\begin{tabbing}
\hspace{0.5in}\=begin\=\+\+ \\*
copy the least-significant byte of {\tt A} to {\tt I} \\*
shift {\tt A} arithmetically 8 bits to the right \\*
execute the instruction in {\tt I} \- \\*
repeat
\end{tabbing}

In the latter case, the contents of the execution loop is executed once, and
control returns to the calling program.

The execution loop need not be implemented as a single loop; it  is designed to
be short enough that the contents of the loop can be appended  to the code
implementing each instruction.

Note that the calls {\bf run()} and {\bf single\_step()} do not perform the
initialisation specified above; that must be performed before calling them.


\subsection{Termination}

When @PACKAGE_NAME@ encounters a {\tt HALT} instruction (see section~\ref{exceptinst}),
it returns the top data stack item as the reason code, unless {\tt SP} does not
point to a valid cell, in which case reason code $-257$ is returned (see section~\ref{exceptions}).

Reason codes which are also valid exception codes (either reserved (see section~\ref{exceptions})
or user exception codes) should not normally be used. This
allows exception codes to be passed back by an exception handler to the calling
program, so that the calling program can handle certain exceptions without
confusing exception codes and reason codes.


\subsection{Exceptions}
\label{exceptions}

When a {\tt THROW} instruction (see section~\ref{exceptinst}) is executed, an
{\bf exception} is said to have been {\bf raised}. The exception code is the number on top of the
stack at the time the exception is raised. Some exceptions are raised by
other instructions, for example by {\tt /} when division by zero is attempted;
these push the exception code on to the stack and then execute a {\tt THROW}.

Exception codes are signed numbers. $-1$ to $-511$ are reserved for @PACKAGE_NAME@'s own exception codes; the meanings
of those that may be raised by @PACKAGE_NAME@ are shown in table~\ref{excepttable}.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{cl} \toprule
\bf Code & \bf Meaning \\ \midrule
$-9$ & Invalid address (see below). \\
$-10$ & Division by zero attempted (see section~\ref{arithmetic}). \\
$-20$ & Attempt to write to a read-only memory location. \\
$-23$ & Address alignment exception (see below). \\
$-256$ & Illegal opcode (see section~\ref{opcodes}). \\ \bottomrule
\end{tabular}
\caption{\label{excepttable}Exceptions raised by @PACKAGE_NAME@}
\end{center}
\end{table}

Exception $-9$ is raised whenever an attempt is made to access an invalid
address, either by an
instruction, or during an instruction fetch (because {\tt EP} contains an
invalid address). Exception $-23$ is raised when an instruction expecting
an address of type \spic{a-addr} (cell-aligned) is given a non-aligned address.
When @PACKAGE_NAME@ raises an address exception ($-9$ or $-23$), the offending address
is placed in {\tt -ADDRESS}.

The initial values of {\tt 'BAD} and {\tt -ADDRESS} are unlikely to be generated
by an exception, so it may be assumed that if the initial values still hold no
exception has yet occurred.

Address and alignment exceptions are only raised if {\tt CHECKED} is 1. When
{\tt CHECKED} is 0, a faster implementation of @PACKAGE_NAME@ may be used.

If {\tt SP} is unaligned when an exception is raised, or putting the code on the
stack would cause {\tt SP} to be out of range, the effect of a {\tt HALT} with
code $-257$ is performed (although the actual mechanics are not, as that too
would involve putting a number on the stack). Similarly, if {\tt 'THROW}
contains an invalid address, the effect of {\tt HALT} with code $-258$ is
performed.


\section{Instruction set}
\label{instset}

The instruction set is listed in sections~\ref{stackinst} to~\ref{accessinst},
with the instructions grouped according to function. The
instructions are given in the following format:

\begin{description}
\instpr{NAME}{pronunciation}{before -- after}{before -- after}{Description.}
\end{description}

The first line consists of the name of the instruction followed by the
pronunciation in quotes. On the right are the
stack comment or comments. Underneath is the description. The two stack comments
show the effect of the instruction on the data and return (R) stacks.

{\bf Stack comments} are written

\centerline{\tt ( \spic{before -- after} )}

where \spic{before} and \spic{after} are stack pictures showing the items on top
of a stack before and after the instruction is executed (the change is called
the {\bf stack effect}). An instruction only affects the items shown in its
stack comments. The brackets and dashes serve merely to delimit the stack
comment and to separate \spic{before} from \spic{after}. {\bf Stack pictures}
are a representation of the top-most items on the stack, and are written

\centerline{\spic{i$_1$ i$_2$\dots i$_{n-1}$ i$_n$}}

where the \spic{i$_k$} are stack items, each of which occupies a whole number of
cells, with \spic{i$_n$} being on top of the stack. The symbols denoting
different types of stack item are shown in table~\ref{typetable}.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{cl} \toprule
\bf Symbol & \bf Data type \\ \midrule
\spic{flag} & flag \\
\spic{true} & true flag \\
\spic{false} & false flag \\
\spic{char} & character \\
\spic{n} & signed number \\
\spic{u} & unsigned number \\
\spic{n{\tt |}u} & number (signed or unsigned) \\
\spic{x} & unspecified cell \\
\spic{a-addr} & cell-aligned address \\
\spic{c-addr} & character-aligned address \\ \bottomrule
\end{tabular}
\caption{\label{typetable}Types used in stack comments}
\end{center}
\end{table}

Types are only used to indicate how instructions treat their arguments and
results; @PACKAGE_NAME@ does not distinguish between stack items of different types. In
stack pictures the most general argument types with which each instruction can
be supplied are given; subtypes may be substituted. Using the phrase ``$i
\Rightarrow j$'' to denote ``$i$\/ is a subtype of $j$\/'', table~\ref{reltable}
shows the subtype relationships. The subtype relation is transitive.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{c} \toprule
\spic{u} $\Rightarrow$ \spic{x} \\
\spic{n} $\Rightarrow$ \spic{x} \\
\spic{char} $\Rightarrow$ \spic{u} \\
\spic{a-addr} $\Rightarrow$ \spic{c-addr} $\Rightarrow$ \spic{u} \\
\spic{flag} $\Rightarrow$ \spic{x} \\ \bottomrule
\end{tabular}
\caption{\label{reltable}The subtype relation}
\end{center}
\end{table}

Numbers are represented in twos complement form. \spic{c-addr} consists of all
valid addresses. Numeric constants can be included in
stack pictures, and are of type \spic{n{\tt |}u}.

Each type may be suffixed by a number in stack pictures; if the same combination
of type and suffix appears more than once in a stack comment, it refers to
identical stack items. Alternative \spic{after} pictures are separated by ``{\tt
|}'', and the circumstances under which each occurs are detailed in the
instruction description.

The symbols \spic{i*x}, \spic{j*x} and \spic{k*x} are used to denote different
collections of zero or more cells of any data type. Ellipsis is used for
indeterminate numbers of specified types of cell.

If an instruction does not modify the return stack, the corresponding stack
picture is omitted. Some instructions have two forms, the latter ending in
``{\tt I}''. This denotes {\tt I}mmediate addressing: the instruction's argument
is included in the instruction cell (see section~\ref{conventions}), rather than
being placed separately in the next available cell.


\subsection{Programming conventions}
\label{conventions}

Since branch destinations must be cell-aligned, some instruction sequences may
contain gaps. These must be padded with {\tt NEXT} (opcode \$00).

Literals and branch addresses should be placed in the cell after the
instruction. Further instructions may still be stored in the current cell. If
more than one literal or branch instruction is encoded in one instruction cell,
the literal values follow each other in successive cells.


\subsection{Execution cycle}
\label{execinst}

{\tt NEXT} performs an instruction fetch when @PACKAGE_NAME@ runs out of
instructions in the {\tt A} register.

\begin{description}
\inst{NEXT}{--}{Load the cell pointed to by {\tt EP} into {\tt A} then add four to {\tt EP}.}
\end{description}


\subsection{Stack manipulation}
\label{stackinst}

These instructions manage the data stack and move values between stacks.

\begin{description}
\inst{DROP}{x --}{Remove \spic{x} from the stack.}
\inst{SWAP}{\x{u}\dots\x0 u -- \x0\x{u-1}\dots\x1 \x{u}}{Exchange the top stack item with the \spic{u}th.}
\inst{DUP}{\x{u}\dots\x0 u -- \x{u}\dots\x0 \x{u}}{Remove \spic{u}. Copy \x{u} to the top of the stack. If there are fewer than \spic{u}~$+$~2 items on the stack before {\tt DUP} is executed, the memory cell which would have been \x{u} were there \spic{u}~$+$~2 items is copied to the top of the stack.}
\instpr{>R}{to-r}{x --}{-- x}{Move \spic{x} to the return stack.}
\instpr{R>}{r-from}{-- x}{x --}{Move \spic{x} from the return stack to the data stack.}
\instpr{RDUP}{r-pick}{u -- x}{\x{u} \x{u-1}\dots\x{0} -- \x{u} \x{u-1}\dots\x{0}}{Remove \spic{u}. Copy \x{u} to the top of the data stack. If there are fewer than \spic{u}~$+$~2 items on the stack before {\tt RDUP} is executed, the memory cell which would have been \x{u} were there \spic{u}~$+$~2 items is copied to the top of the data stack.}
\end{description}

\subsection{Comparison}

These words compare two numbers (or, for equality tests, any two cells) on the
stack, returning a flag, true with all bits set if the test succeeds and false
otherwise.

\begin{description}
\instp{<}{less-than}{\n1 \n2 -- flag}{\spic{flag} is true if and only if \n1 is less than \n2.}
\instp{=}{equals}{\x1 \x2 -- flag}{\spic{flag} is true if and only if \x1 is bit-for-bit the same as \x2.}
\instp{U<}{u-less-than}{\U1 \U2 -- flag}{\spic{flag} is true if and only if \U1 is less than \U2.}
\end{description}


\subsection{Arithmetic}
\label{arithmetic}

These instructions consist of monadic and dyadic operators.
All calculations are made without bounds or overflow checking, except
as detailed for certain instructions.

Addition:

\nopagebreak

\begin{description}
\instp{+}{plus}{\noru1 \noru2 -- \noru3}{Add \noru2 to \noru1, giving the sum \noru3.}
\end{description}

Multiplication and division (note that all division instructions raise exception
$-10$ if division by zero is attempted, and round the quotient towards minus
infinity, except for {\tt S/REM}, which rounds the quotient towards zero):

\nopagebreak

\begin{description}
\instp{*}{star}{\noru1 \noru2 -- \noru3}{Multiply \noru1 by \noru2 giving the product \noru3.}
\instp{UMOD/}{u-mod-slash}{\U1 \U2 -- \U3 \U4}{Divide \U1 by \U2, giving the single-cell quotient \U3 and the single-cell remainder \U4.}
\instp{SREM/}{s-rem-slash}{\n1 \n2 -- \n3 \n4}{Divide \n1 by \n2 using symmetric division, giving the single-cell quotient \n3 and the single-cell remainder \n4.}
\end{description}

Sign function:

\nopagebreak

\begin{description}
\inst{NEGATE}{\n1 -- \n2}{Negate \n1, giving its arithmetic inverse \n2.}
\end{description}


\subsection{Logic and shifts}

These instructions consist of bitwise logical operators and bitwise shifts. The
result of performing the specified operation on the argument or arguments is
left on the stack.

Logic functions:

\nopagebreak

\begin{description}
\inst{INVERT}{\x1 -- \x2}{Invert all bits of \x1, giving its logical inverse \x2.}
\inst{AND}{\x1 \x2 -- \x3}{\x3 is the bit-by-bit logical ``and'' of \x1 with \x2.}
\inst{OR}{\x1 \x2 -- \x3}{\x3 is the bit-by-bit inclusive-or of \x1 with \x2.}
\instp{XOR}{x-or}{\x1 \x2 -- \x3}{\x3 is the bit-by-bit exclusive-or of \x1 with \x2.}
\end{description}

Shifts:

\nopagebreak

\begin{description}
\instp{LSHIFT}{l-shift}{\x1 u -- \x2}{Perform a logical left shift of \spic{u} bit-places on \x1, giving \x2. Put zero into the least significant bits vacated by the shift. If \spic{u} is greater than or equal to 32, \x2 is zero.}
\instp{RSHIFT}{r-shift}{\x1 u -- \x2}{Perform a logical right shift of \spic{u} bit-places on \x1, giving \x2. Put zero into the most significant bits vacated by the shift. If \spic{u} is greater than or equal to 32, \x2 is zero.}
\end{description}


\subsection{Memory}
\label{memoryinst}

These instructions fetch and store cells and bytes to and from memory; there is
also an instruction to add a number to another stored in memory.

\begin{description}
\instp{@}{fetch}{a-addr -- x}{\spic{x} is the value stored at \spic{a-addr}.}
\instp{!}{store}{x a-addr --}{Store \spic{x} at \spic{a-addr}.}
\instp{C@}{c-fetch}{c-addr -- char}{If {\tt ENDISM} is 1, exclusive-or \spic{c-addr} with 3. Fetch the character stored at \spic{c-addr}. The unused high-order bits are all zeroes.}
\instp{C!}{c-store}{char c-addr --}{If {\tt ENDISM} is 1, exclusive-or \spic{c-addr} with 3. Store \spic{char} at \spic{c-addr}. Only one byte is transferred.}
\end{description}


\subsection{Registers}
\label{registerinst}

As mentioned in section~\ref{registers}, the stack pointers {\tt SP} and {\tt
RP} may only be accessed through special instructions:

\begin{description}
\instp{SP@}{s-p-fetch}{-- a-addr}{\spic{a-addr} is the value of {\tt SP}.}
\instp{SP!}{s-p-store}{a-addr --}{Set {\tt SP} to \spic{a-addr}.}
\instp{RP@}{r-p-fetch}{-- a-addr}{\spic{a-addr} is the value of {\tt RP}.}
\instp{RP!}{r-p-store}{a-addr --}{Set {\tt RP} to \spic{a-addr}.}
\instp{EP@}{bracket-create}{-- a-addr}{Push {\tt EP} on to the stack.}
\instp{S0@}{s-nought-fetch}{-- a-addr}{Push {\tt S0} on to the stack.}
\instp{\#S@}{hash-s-fetch}{-- u}{Push {\tt \#S} on to the stack.}
\instp{R0@}{r-nought-fetch}{-- a-addr}{Push {\tt R0} on to the stack.}
\instp{\#R@}{hash-r-fetch}{-- u}{Push {\tt \#R} on to the stack.}
\instp{'THROW@}{tick-throw-fetch}{-- a-addr}{Push {\tt 'THROW} on to the stack.}
\instp{'THROW!}{tick-throw-store}{a-addr --}{Set {\tt 'THROW} to \spic{a-addr}.}
\instp{MEMORY@}{memory-fetch}{-- a-addr}{Push {\tt MEMORY} on to the stack.}
\instp{'BAD@}{tick-bad-fetch}{-- a-addr}{Push {\tt 'BAD} on to the stack.}
\instp{-ADDRESS@}{not-address-fetch}{-- a-addr}{Push {\tt -ADDRESS} on to the stack.}
\end{description}


\subsection{Control structures}
\label{control}

These instructions implement unconditional and conditional branches, and subroutine
call and return.

Branches:

\nopagebreak

\begin{description}
\inst{EP!}{a-addr --}{Set {\tt EP} to \spic{a-addr}, then perform the action of {\tt NEXT}.}
\inst{?EP!}{flag a-addr --}{If \spic{flag} is false then set {\tt EP} to \spic{a-addr} and perform the action of {\tt NEXT}.}
\end{description}

Subroutine call and return:

\nopagebreak

\begin{description}
\instr{EXECUTE}{\aaddr1 --}{ -- \aaddr2}{Push {\tt EP} on to the return stack, put \spic{\aaddr1} into {\tt EP}, then perform the action of {\tt NEXT}.}
\instr{EXIT}{--}{a-addr --}{Put \spic{a-addr} into {\tt EP}, then perform the action of {\tt NEXT}.}
\end{description}

\subsection{Literals}
\label{literals}

This instructions encodes literal values which are placed on the stack.

\begin{description}
\instp{(LITERAL)}{bracket-literal}{-- x}{Push the cell pointed to by {\tt EP} on to the stack, then add four to {\tt EP}.}
\end{description}


\subsection{Exceptions}
\label{exceptinst}

These instructions give access to @PACKAGE_NAME@'s exception mechanisms.

\begin{description}
\instp{THROW}{throw}{--}{Put the contents of {\tt EP} into {\tt 'BAD}, then load {\tt EP} from {\tt 'THROW}. Perform the action of {\tt NEXT}. If {\tt 'THROW} contains an out of range or unaligned address stop @PACKAGE_NAME@, returning reason code $-258$ to the calling program (see section~\ref{calls}).}
\inst{HALT}{x --}{Stop @PACKAGE_NAME@, returning reason code \spic{x} to the calling program (see section~\ref{calls}). If {\tt SP} is out of range or unaligned, $-257$ is returned as the reason code.}
\end{description}


\subsection{External access}
\label{accessinst}

These instructions allow access to @PACKAGE_NAME@'s libraries, the operating system and
native machine code.

\begin{description}
\inst{LINK}{i*x --}{Make a subroutine call to the routine at the address given (in the host machine's format, padded out to a number of cells) on the data stack. The size and format of this address are machine-dependent.}
\end{description}


\subsection{Extra instructions}
\label{extrainstructions}

Instructions with opcodes from \$80 to \$FE inclusive may be implemented to provide system-dependent functionality, such as I/O.


\subsection{Opcodes}
\label{opcodes}

In table~\ref{opcodetable} are listed the opcodes in numerical order. All
undefined opcodes (\$61–\$FE) raise exception $-256$.

\begin{table}[htb]
\begin{center}
\begin{tabular}{*{3}{cc}} \toprule
\bf Opcode & \bf Instruction & \bf Opcode & \bf
    Instruction & \bf Opcode & \bf Instruction \\ \midrule
\opcodetbl{00}{NEXT}	{21}{undefined}	{42}{EP@}
\opcodetbl{01}{undefined}	{22}{undefined}	{43}{S0@}
\opcodetbl{02}{DROP}	{23}{undefined}	{44}{\#S}
\opcodetbl{03}{SWAP}	{24}{undefined}	{45}{R0@}
\opcodetbl{04}{undefined}	{25}{*}		{46}{\#R}
\opcodetbl{05}{undefined}	{26}{undefined}		{47}{'THROW@}
\opcodetbl{06}{undefined}	{27}{undefined}	{48}{'THROW!}
\opcodetbl{07}{undefined}	{28}{undefined}	{49}{MEMORY@}
\opcodetbl{08}{undefined}	{29}{UMOD/}	{4A}{'BAD@}
\opcodetbl{09}{DUP}	{2A}{SREM/}	{4B}{-ADDRESS@}
\opcodetbl{0A}{undefined}	{2B}{undefined}	{4C}{undefined}
\opcodetbl{0B}{RDUP}	{2C}{undefined}	{4D}{EP!}
\opcodetbl{0C}{>R}	{2D}{undefined}	{4E}{undefined}
\opcodetbl{0D}{R>}	{2E}{NEGATE}	{4F}{?EP!}
\opcodetbl{0E}{undefined}	{2F}{undefined}	{50}{EXECUTE}
\opcodetbl{0F}{<}	{30}{undefined}	{51}{undefined}
\opcodetbl{10}{undefined}	{31}{INVERT}	{52}{undefined}
\opcodetbl{11}{=}	{32}{AND}	{53}{undefined}
\opcodetbl{12}{undefined}	{33}{OR}	{54}{EXIT}
\opcodetbl{13}{undefined}	{34}{XOR}	{55}{undefined}
\opcodetbl{14}{undefined}	{35}{LSHIFT}	{56}{undefined}
\opcodetbl{15}{undefined}	{36}{RSHIFT}	{57}{undefined}
\opcodetbl{16}{undefined}	{37}{undefined}	{58}{undefined}
\opcodetbl{17}{U<}	{38}{undefined}	{59}{undefined}
\opcodetbl{18}{undefined}	{39}{@}		{5A}{undefined}
\opcodetbl{19}{undefined}	{3A}{!}		{5B}{undefined}
\opcodetbl{1A}{undefined}	{3B}{C@}	{5C}{(LITERAL)}
\opcodetbl{1B}{undefined}	{3C}{C!}        {5D}{undefined}
\opcodetbl{1C}{undefined}	{3D}{undefined}        {5E}{THROW}
\opcodetbl{1D}{undefined}	{3E}{SP@}	{5F}{HALT}
\opcodetbl{1E}{+}	{3F}{SP!}       {60}{LINK}
\opcodetbl{1F}{undefined}	{40}{RP@}	{80–\$FE}{\textrm{extra instructions}}
\opcodetbl{20}{undefined}	{41}{RP!}       {FF}{NEXT}
 \bottomrule
\end{tabular}
\caption{\label{opcodetable}@PACKAGE_NAME@'s opcodes}
\end{center}
\end{table}


\section{External interface}

@PACKAGE_NAME@'s external interface comes in three parts. The calling interface allows
@PACKAGE_NAME@ to be controlled by other programs. The {\tt LINK} instruction and extra instructions mechanism allow implementations to provide access to system facilities, previously written code,
code written in other languages, and the speed of machine code in time-critical
situations. The object module format allows compiled code to be saved, reloaded
and shared between systems.


\subsection{Object module format}
\label{object}

The first seven bytes of an object module should be the ASCII codes of the letters
``@PACKAGE@'' padded with ASCII NULs (\$00), then the one-byte contents of
the {\tt ENDISM} register of the system which saved the module. The next four
bytes should contain the number of cells the code occupies. The number must have
the same endianness as that indicated in the previous byte. Then follows the
code, which must fill a whole number of cells.

Object modules have a simple structure, as they are only intended for loading an
initial memory image into @PACKAGE_NAME@.


\subsection{Calling interface}
\label{calls}

The calling interface is difficult to specify with the same precision as the
rest of @PACKAGE_NAME@, as it may be implemented in any language. However, since only
basic types are used, and the semantics are simple, it is expected that
implementations in different language producing the same result will be easy to
program. A Modula-like syntax is used to give the definitions here.
Implementation-defined error codes must be documented, but are optional. All
addresses passed as parameters must be cell-aligned. A @PACKAGE_NAME@ must provide the
following calls:

\begin{description}
\iface{native\_address}{integer, boolean}{pointer}{Return a native pointer corresponding
    to the given @PACKAGE_NAME@ address. If the @PACKAGE_NAME@ address is invalid, or the Boolean flag is true and the address is read-only, then a distinguished invalid pointer is returned.}
\iface{run}{}{integer}{Start @PACKAGE_NAME@ by entering the execution cycle as
    described in section~\ref{operation}. If @PACKAGE_NAME@ ever executes a {\tt
    HALT} instruction (see section~\ref{exceptinst}), the reason code is
    returned as the result.}
\iface{single\_step}{}{integer}{Execute a single pass of the execution
    cycle, and return reason code $-259$, unless a {\tt HALT} instruction was
    obeyed (see section~\ref{exceptinst}), in which case the reason code
    passed to it is returned.}
\iface{load\_object}{file, address}{integer}{Load the object module
    specified by \textit{file}, which may be a filename or some other
    specifier, to the @PACKAGE_NAME@ address \textit{address}. First the module's
    header is checked; if the first seven bytes are not as specified above
    in section~\ref{object}, or the endianness value is not 0 or 1, then
    return $-2$. If the code will not fit into memory at the address given, or
    the address is out of range or unaligned, return $-1$. Otherwise load the code into
    memory, converting it if the endianness value is different from the current
    value of {\tt ENDISM}. The result is 0 if successful, and some other
    implementation-defined value if there is a filing system or other error.}
\end{description}

@PACKAGE_NAME@ must also provide access to its registers and address space through
appropriate data objects.


\section*{Acknowledgements}

Martin Richards's demonstration of his BCPL-oriented Cintcode virtual machine~\cite{cintweb}
convinced me it was going to be fun working on virtual machines. He also supervised my BA dissertation project, Beetle, on which @PACKAGE_NAME@ is based.

\bibliographystyle{plain}
\bibliography{vm,rrt}


\end{document}

% LocalWords:  discontiguous
